<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>财富观</title>
    <link href="/2021/01/15/%E8%B4%A2%E5%AF%8C%E8%A7%82/"/>
    <url>/2021/01/15/%E8%B4%A2%E5%AF%8C%E8%A7%82/</url>
    
    <content type="html"><![CDATA[<h1 id="财富观"><a href="#财富观" class="headerlink" title="财富观"></a>财富观</h1><p>修改时间: Jan 15, 2021 8:42 PM<br>创建时间: Jan 12, 2021 5:45 PM</p><p>我问过许多人，问他们想要一种什么样的生活，为什么要为之努力？绝大部分人告诉我为了钱，因为金钱能买来他们想拥有的东西，包括健康，爱情，理想。因为有钱了可以有健康的生活，有钱了爱情不会变得如此易碎，有钱了能干一切想要干的事情。</p><p>正常人必须的花销:吃饭要钱，上学要钱，出去玩要钱，衣服要钱。再到成年后谈恋爱要钱，买房买车要钱，结婚要钱，装修要钱，儿女的教育要钱，儿女的衣食住行都要钱。你不单要承担你一个人的花销，还要承担一家六口甚至两家十二口的花销。100万够不够？显然不够，1000万还要看情况。以月薪1万计算，也得不吃不喝也得80多年才能过上这看似正常的生活。困在这个以金钱为核心的难题中，突然天灾人祸，一病不起更是让整个家庭蒙上阴影。而上述难题在大量金钱面前基本能迎刃而解。甚至人情冷暖也离不开金钱二字！</p><p>人生一世，极不容易，登天难，求人更难，黄连苦，无钱更苦，江湖险，人心更险，春冰薄，人情更薄。</p><p>大英雄手中枪翻江倒海，抵挡不住饥寒穷三个字。</p><p>有钱男子汉，无钱汉子难。</p><p>穷人站在十字街头耍十把钢钩，钩不着亲人骨肉。有钱人在深山老林耍刀枪棍棒，打不散无义宾朋。</p><p>我本想说赚钱不是最终目的，你的最终目的是用钱干想干的事情啊！一般都会遭来反问：竭尽全力维持生计已实属不易，更遑论成为你自己？你就是想太多，可没空想什么人生的意义，就是想赚钱，钱才能带给我快乐！有钱才能得到解放。</p><p>至于这种看法按下不表，有人觉得家庭，理想，生活远胜于金钱；有人觉得只有财富自由才能谈理想，谈家庭。最终都会有一个共识，金钱在其中承担着不可或缺的角色。</p><p>于是就有一个问题：怎样才能获得财富自由。我会以此问题逐步进行分析，找到真正的财富。</p><ul><li>首先，我根据财富是如何产生的，得出财富是现金流和金融资产。</li><li>其次，根据财富的来源归纳出能大量获得财富的可能途径有三个：规模化生产，与公司同工同酬，产出比巨大的行业。</li><li>接着，根据这些致富途径分析我应该具备阅读，写作，数学，编程，谈判的能力，这些是致富源泉。</li><li>最后，根据网上所存在的理财建议确定自我的理财方案和信条。</li></ul><h1 id="什么是财富"><a href="#什么是财富" class="headerlink" title="什么是财富"></a>什么是财富</h1><p>在许多人眼里，金钱基本上就和财富等价。实际上并不是这样的！在经济学原理中常常用人与人的物物交换逐步引出金钱的概念，进而随着历史的发展有了合法的借贷，雇佣关系。这些东西就是财富的源头。</p><p>最初的两个人一个砍柴在行，一个抓鱼在行。为了让双方都有柴和鱼，他们拿自己的一部分东西交换。一天，抓鱼的需要斗笠，而做斗笠的人需要柴火，于是抓鱼的得先去找砍柴的，再去找做斗笠的。随着需要的东西越来越多，花上大量时间交换很没有效率，于是需要一种一般等价物，就是金钱。金钱的价值就蕴含了你的劳动价值，金钱的流通就是劳动价值的流通。</p><p>金钱的实体状态一般来源于中央银行这样由统治阶级创立的机构，以暴力机关和技术壁垒保证金钱能正常流通。因此整个金钱体系都是依靠统治阶级的信用构建的，这里称之为社会信用。央行量化宽松，降低利率等金融操作都是对社会劳动价值的利用，转移和剥削。</p><p>金钱代表劳动价值，由社会信用体系发行和管理。社会信用可以合理的利用社会劳动价值。</p><p>故事的转折发生在借贷的产生。欠债还钱天经地义，但你还需要偿付利息。这意味着贷款人借出劳动价值，而要求借款人额外付出劳动价值。这相当于今天我没去菜市场买菜，借你点菜将就着吃午饭，明天不但要还菜，还要额外加根萝卜。量少还说得通，毕竟方便了借款人，当金额巨大到贷款人不需要任何劳动就可以过上比劳动人民更舒服的日子，这合理吗？这不就是合法的让借款人无偿为贷款人打工吗？最重要的是贷款人不创造任何价值！那贷款人的钱哪来的呢？</p><p>历史告诉我们，资本的积累往往是黑暗的，鸦片战争，圈地运动，人民公社化运动等等，积累了资本之后就可以合法的搜刮别人的劳动价值？乘着时代的快车喊着996福报？那些通过正当方式完成资本积累的人同样是借助黑暗资本的手。可以承认智商差距，但同在一条起跑线上，占邻居的便宜尚且不容易，占每个人10万块便宜且毫无察觉，这就不对劲了。十万乘十四亿也才十四万亿人民币，也养不出中国现在8个万亿级别的公司，数百个上亿的公司。</p><p>除了借贷，还有不合理的雇佣关系也能构成剥削他人的手段。雇主用少量钱买断雇工的时间和创造的价值，如果创造的价值大于买断价，这就带来了剩余价值，无偿为雇主提供价值。</p><p>于是，借贷的产生和不合理的雇佣关系使得资本可以合理的占有他人的劳动价值。</p><p>综上所述，财富大致可以分为两大类，一类是产生劳动价值的活动产生的收益，如生产生活，发明创造，专利权和其他可产生收入增值并流通在市场的东西。另一类是借贷凭空产生的价值这类可以笼统的称为金融资产，一般有股票，债券，共同基金，产生收入的房地产，票据，不合理的雇佣关系。</p><h1 id="如何获取财富"><a href="#如何获取财富" class="headerlink" title="如何获取财富"></a>如何获取财富</h1><p>知道了什么是财富，接下来就是获取更多财富的方法。人类的社会活动大致可以分为生产活动，政治活动，文化活动三个大的方面，目前来说也只有这三种活动能创造价值。我通过招聘网，学科分类，统计局数据，筛选并归类出四种理论上能合法获得大量财富的方式如下:</p><ol><li>命好：风口上的猪，拆迁，彩票，朋友介绍</li><li>实干：为社会创造实实在在的价值</li><li>投机：不创造价值，但依然需要强大的技能和经验</li><li>独特的人格：品牌，人设，领导者，网红</li></ol><p>可以思索一下，在我们印象中有大量财富的人是否都被归类进去了？体彩，拆迁，关系提携，四大银行15年股灾国家助力造就了富豪等属于命好；小米雷军，苹果乔布斯，华为任正非，微软比尔盖茨，阿里巴巴马云，贝佐斯，马斯克等属于实干起家；房地产商李嘉诚，罗斯柴尔德家族，洛克菲勒等属于投机行为一类；赵薇，李子柒，李佳琦，LVMH，工程院院士等属于独特的人格和品牌。</p><p>对于普通人来说，狗屎运和独特的人格都是不靠谱的，投机需要原始积累，因此靠谱的获取财富唯有实干。</p><p>根据财富的来源，一个人具有提供商品和服务这两种创造价值的方式。如果你是打工人，显而易见，你劳动的价值被看作商品，商品怎么定价你就被怎么定价。</p><p>而商品是如何定价的呢？最被广泛传播的是劳动由社会必要劳动时间来决定性衡量的。但这显然不好解释品牌溢价，地区差异，心理因素对价格的影响。</p><blockquote><p>社会必要劳动时间:在现有社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下，制造任何一个使用价值所需要的劳动时间。</p></blockquote><p>我目前更倾向于类似于模型分析的方式分析定价策略。影响价格的主要因素有：</p><ol><li>成本因素：原材料，劳动力，土地，销售渠道，研发成本，宣发成本</li><li>需求因素：供需关系，价格弹性，边际效益</li><li>竞争状态：自由市场，部分垄断，完全垄断</li><li>行政立法：补贴，限价，税收，反垄断法</li><li>社会经济状况：发展水平，通货膨胀，货币贬值</li><li>心理因素：促销策略，品牌效应</li></ol><p>总之，不得不承认商品总会有相对稳定的价格，而打工人作为商品成本因素一定会低于商品总额。你每天的工作时间直接影响你的薪资，而你的时间是有限的，单价比商品还低，因此，你的财富就是有限的时间乘以薪资，也是极其有限的，绝大部分财富被股东和老板吃了。</p><p>那么如何让实干也能成就财富自由呢？我总结了以下几个方向。</p><ol><li>提供社会不知道怎么规模化获取的东西，比如90年代的富人才能用的个人电脑，00年后的手机，甲骨文微软淘宝的软件，互联网起家时的APP开发等。</li><li>获取公司股票和期权，让公司把利益分给你，做高级打工人。这里有坑，先不细说。</li><li>寻找投入与产出不匹配的工作：文化产业，包括自媒体，音乐，专利，手稿，绘画等一切能进行价值流通和自我增值的工作。</li><li>特殊技能：由人的特质决定，是学习不来的，所谓的天赋才能。天赋造就的擅长加爱好的工作。</li></ol><p>规模化生产需要你把握社会运行规律——需要通识体系加上经济学，金融学，管理学等文科各专业知识。</p><p>获取公司股票需要你强大的业务能力——需要通识体系加上工科各专业知识。</p><p>寻找产出比高的工作需要你有专业的技能——自媒体对应通识体系加上传播学和各类媒体工具，艺术本身门槛就相对高，还比较吃背景。</p><p>为什么我总是在强调通识体系呢？</p><p>通识能力时基础，专业能力是工具，没有通识能力学不好专业能力，换谁来都一样，这是客观规律！</p><p>由此可见，高额收入来源于体系化的通识能力和过硬的专业能力。</p><h1 id="通识能力是什么"><a href="#通识能力是什么" class="headerlink" title="通识能力是什么"></a>通识能力是什么</h1><p>通识能力服务于专业能力，是专业能力的基础，也是认识世界的基础。可以这么说，所有专业能力都来自通识能力，否则就是无本之木，无源之水！这是毫无疑问的！</p><p>通识教育提供的知识框架对现代社会尤其重要。在现代社会中，知识和信息的碎片化使很多人无所适从，比如，人们可能知道利率、知道M2、知道GDP，但不知道这几个变量如何相互影响，而通识教育通过教授每一个大学生一个基本的经济学体系，可以有效地将一些常识级别的知识点串联起来，并形成体系，帮助大学生们在日后的工作和生活中接受新的知识、进行独立思考。要知道，知识的体系对学习新知和系统思考都特别重要。</p><p>通识教育对培养独立人格、培养独立思考、建立民主社会是极其有帮助的。</p><p>美国大学一般通识教育体系（不同学校分类有区别，但基本涵盖如下所有细分），分8大类N多小类：</p><ol><li>西方文化研究，主要涉及欧美的文化和历史少数文化、非西方文化研究，主要涉及亚洲、非洲、大洋洲、南美洲、美洲印地安、美国黑人等等少数民族及非“欧美主流文化”的研究。</li><li>写作，主要教授大学学术类写作的基本纲要，包括如何立论、引证、收集证据、论证、结论等写作基本要点。</li><li>专业写作，主要教授更高级写作技巧，通常与各专业课结合，提升学生在专业领域搜索、阅读文献、总结并表述自己观点的能力。</li><li>人文与艺术，主要涉及历史和艺术，比较常见的如音乐史、文学史、文学研究、作品赏析等。</li><li>自然科学与技术，主要涉及物理科学（物理、化学），生命科学（生物、植物学、神经学），天文地理等</li><li>社会与行为科学，主要涉及经济学、人类学、社会学、心理学等</li><li>数理逻辑推理，主要涉及数学、计算机编程、逻辑学、统计学等。</li><li>至少修习一门外语，常见的有法语、西班牙语、德语、中文、日文、阿拉伯语等等</li></ol><p>如此多的课程显然让人头大，不感兴趣的东西显然是读不下去的。不过我发现一个规律，我刚开始喜欢读玄幻小说，因为小说情节跌宕起伏，我能体验到男主人公的爽点。但我看多了渐渐发现没有意思，套路千篇一律，促使我继续看下去的动力就是无聊。于是我找了科幻小说，比如《三体》《2001太空漫游》，了解了对时间，空间，人生，人性和人类的思考。科幻毕竟是艺术创作，回答不了我的问题。这样我就踏上了哲学的道路，形而上学，认识论，科学，宗教，文化的内容浮现在我眼前。我渐渐的想要知道我生活在一个怎样的世界？</p><p>整个过程都不是刻意去进行的，只要我无聊的时候保持阅读，历史也好，小说也好，只要去阅读，你将会在适当的时候自发的学习通识课程，最终完成你整个通识体系的构建！</p><p>遗憾的是，隶属于形式科学的数学，隶属于计算机科学的编程不是光靠阅读就能习得的。因为历史上没有这样的先例！数学是抽象工具，最基础的工具，编程是连接现实与抽象的渠道。</p><p>综上，我将通识体系进一步凝聚成五个大方向，重要性从大到小依次排列：</p><ol><li>阅读能力：知识的获取，辨别，理解，是所有知识的来源</li><li>写作能力：知识的处理，总结，吸收和消化，是自我形成知识体系的核心</li><li>数学能力：逻辑思维，对现实世界最理性的处理方式</li><li>编程能力：逻辑在实践中的应用，未来发展的基础</li><li>谈判能力：连接自我与普通人</li></ol><p>为什么我要“画蛇添足”的加了一个谈判能力？因为这是我对近期世界的感受。最近发生的几件事我列举一下：</p><ul><li>《赛博朋克2077》游戏实物与宣传严重不符，但依然霸榜销量排行榜。</li><li>长沙“茶颜悦色”奶茶店现排队长龙上热搜，黄牛要价200一杯，至今甚至当作长沙特色而出名。</li><li>“智己”发布电动SUV，无实际参数却每天连开三场发布会，类似于众筹概念，品牌先行。</li><li>华为下架腾讯应用，疑似价钱没谈拢。据我所知国内渠道商获利占六成以上，内容商反而不如渠道商获利多。阿里京东拼多多也能侧面证明做产品不如做平台，做平台不如做渠道。</li></ul><p>管中窥豹可见一斑，你有好东西你得卖出去啊。以前还得看产品质量，现在是品牌先行，先把话说出去依然有人买单。在形成了内容茧房的今天，一个人打开手机通常也就只玩固定的几个应用。人的注意力有限，谁掌握人的注意力就掌握了渠道，谁就能赚钱。这样一种营销的概念在当代社会愈发显得重要，新出世的产品即使品质再好，没有曝光的机会，会很快被抄袭，竞品淹没在市场中。如今几十年过去了，我们竟依然熟悉耐克，阿迪达斯，李宁这类的品牌，想过为什么没有其他品牌走进我们的视野吗？</p><p>除此之外，朋友也能创造财富，寻找品行纯良，精力充沛，智慧过人的战友尤为重要，而谈判手段是能成功的最大保障，也只有谈判能力能靠谱的增加这方面的筹码。</p><p>但谈判显然没有其它的东西重要，既当销售又当工程师是最好的，只专注于工程也不错。但万万不能只当销售，销售只是手段，并不能作为靠谱的大量致富的途径。</p><p>因此，我认为的通识能力就是阅读，写作，数学，编程与谈判。通识能力也是实现财富自由最最基础的前提，没了这些你只能寄托于命运。</p><h1 id="如何理财"><a href="#如何理财" class="headerlink" title="如何理财"></a>如何理财</h1><p>首先要解决的问题就是为什么要理财？</p><p>只要随便去搜就知道，理财大多出于三个目的：1. 抵御通货膨胀。2. 投资，带来被动收入。3. 梳理财产状况做资产配置。</p><p>先来说说第一个，通货膨胀。根据经济运行原理，社会中的经济状况是周期性变化的。交易中由于借贷，普通人贷款买房，有钱人贷款做生意，越有钱的人贷款越多，期望产生更多收益。正常情况下按约还清债务和利息，这种“超前收入”则会大大促进经济发展。遗憾的是做生意也好，投资也好，并不总是赚钱的，亏钱十之八九，最后还不清债务。这种债务一方面由于利息原因越滚越大，另一方面由于贷款人本身也可能是借款人，最后导致大家都还不上债务。这个时候经济极度萎靡，由于一个人的支出是另一个人的收入，人们的消费欲望越低，赚的钱就会越少 。赚的越少越没有支出，直至债务拖垮所有有债务的人，经济面临崩盘。这个时候央行开始印钱，购买那些不良资产，企业开始债务重组，让一个人能还清另一个人的债务，最终让所有人都能还清债务。整个过程市场上凭空产生了央行的钱，这个钱可以看看美国2020年无限量量化宽松，即无限制印钱购买资产让市场债务平衡。如此庞大数量的钱去了哪？它提高了市场上所有资产的价值，进而影响消费品，农产品，让钱变得没有之前耐用了，这就是所谓的通货膨胀。</p><p>抵御通货膨胀从原理上来说，就是让央行发钱的时候让你也能得到相应的钱。而央行发钱是通过购买金融资产的形式发放，因此，通过购置金融资产就能让你得到一部分钱。但真的那么简单吗?当你购置金融资产的时候你同样会受到企业的经营状况，行业前景的影响，一样的存在较高风险，不一定只赚不亏啊！但投资有保底型投资，银行储蓄，国债等大部分情况都能保本赚利息。那买这些能否跑赢通胀呢？</p><p>根据现银行存款的基准利率是2.75%。各个银行吸引存款的利率一般设有优惠，普遍在3.3%<del>3.6%之间。大额存单的存单利率更高，一般是3.85</del>4.26%之间。国家三年期国债利率是4%，五年期国债利率是4.27%。由于近年来我们的CPI增长速度普遍在2%上下浮动，结合GDP增速，广义货币M2增长率，人均可支配收入增长率，职工工资增长率，通胀综合考虑下来也只有2.2%~2.3%之间。照此看来银行利率都是能跑赢通货膨胀率的。</p><p>因此，跑赢通胀把钱定存银行或者购买国债即可。抱着跑赢通胀的目的理财，只要有良好的储蓄习惯，通胀对穷人的影响就微乎其微。</p><p>投资，即购买金融资产。金融资产是一切可以在有组织的金融市场上进行交易、具有现实价格和未来估价的金融工具的总称。重点在未来估价上，这一点成就了金融资产的虚拟化，估价可高可低。这个估价绝大部分情况由社会总体经济状况，行业状况，企业经营状况等各方面因素共同决定，及其复杂而带有不确定性。常见的金融资产有共同基金，股票，房地产，虚拟货币，债券等。</p><p>首先需要知道的是，投资是在预测未来，至今没有人能够预测未来是毋庸置疑的。但根据经验和理论，能够大致预测出事物的发展方向也是毋庸置疑的。因此，投资并不是只能靠运气获利，绝大部分情况是运气与理论知识共同作用的结果。而你对事物了解的越深入，你对事物的发展方向也会越有把握。基于此，得到第一条准则：只有当你足够了解这种投资行为，你才能尽可能的将钱握在自己手中，而不是寄希望于命运。</p><p>即使你有充足的把握你也依然不能规避突如其来的风险。通过贷款进行投资无异于走钢丝，赚了也就是一些钱，亏了也许就是整个生活都没了。只有在基本生活水平能够保障的情况下，利用空闲资金对能力范围内的项目下注，才是明智之举。所谓空闲资金是指进行了资产配置的资金，包括保命资金(重大疾病，天灾人祸)，短期储蓄(水电煤气房租吃喝拉撒维持几个月的钱)，保险保值储蓄(养老保险，医疗保险，教育资金，买房资金)，这里怎么着至少也得200万以上吧。基于此，得到第二条准则，只有当财富累积到200万，才能用多余的钱投入到金融市场，才能尽可能规避未来的风险。</p><p>因此，投资一定是财富大于200万后，在理性的充分了解市场规律后才能去触碰的行为。</p><p>资产配置用白话就是有计划的花钱，其最基本的原理就是开源节流。什么该花？什么不该花？花多少？这三个问题往往让许多人纠结不堪。</p><p>你手机坏了，你想选一个手机，如何进行选择？这个问题首先不是去比较市面上同价位手机的性价比并分析参数，而是回到基本原理开源节流的问题上。该问问买手机这一笔支出是否符合开源节流的准则？不用说手机可以带来隐形收益，是一个必需品。但如今高度性能过剩的手机真的能充分利用上吗？cpu性能决定游戏画质；运行内存决定后台运行app的数量；几年都不看一眼的图片，视频为什么不能存云端；看不出1080p，2k的区别为什么要买2k手机屏？这些都是你为此额外付出的成本，没有产生一丁点收益，只有刚开始买手机的喜悦与自得。</p><p>作为一个穷人，我得到的每一分钱都是用一分少一分。除了维持基本生活，我花出去的钱都应该更多的返还给我，这样才能逐步的积累出财富，才能达到投资的临界线，才有提高生活水平的底气。着急的提升生活水平只会让你暂时的享受到金钱的美好，永远带不来躺着赚钱的快感。因此，不要急于提升生活水平，开源节流优化资产配置才能逐步积累下财富。</p><p>要进行资产配置首先要清楚自己的财务状况，定期梳理支付宝，银行卡的资金流向，提出优化方案。根据上述内容优化方案总结如下：</p><ol><li>不要着急提升生活水品，穷人要有穷人的样子，开源节流，理智消费，把钱花在刀刃上。</li><li>买金额大的东西一定要带来巨大的收益，不能舍不得。</li><li>能不买的东西，多问问自己真的用得上吗？</li></ol><p>其次就是配置，根据流传甚广的理财四象限法则，我做了如下修改：(以一个月的工资为基础，对下列资金按2:5:3:0的比例进行分配)</p><ol><li>应急保命金：应对天灾人祸，准备3-6月的基本生活保障金，在适当时候购入对应保险——重病险，责任险，意外险等。在有条件之后尽可能准备ICU等重大医疗事故10万左右准备金。</li><li>保值保险金：社保，房产准备金，教育金，育儿金。</li><li>短期储蓄：衣食住行，水电煤气，通勤随礼等。</li><li>投资储蓄：在资产总额尚未达到200万时，将短期储蓄的结余汇入此账号保值。</li></ol><p>对于应急保命金，由于需要随时存取，只能采用活期存款或余额宝和零钱通这样的方式。考虑到收益，将其存取到余额宝的蚂蚁心愿中暂时锁定。</p><p>对于保值保险金，社保自行缴纳，其余通过国债，稳定的共同基金，定存的方式储蓄。考虑到收益和方便，单独拿一个账户按当时的收益横向比较选择。</p><p>对于短期储蓄，理所应当通过银行卡和支付宝随时存取。</p><p>对于投资储蓄，单独开设账户，采用和保值保险金相同的方式管理。</p><h1 id="如何投资"><a href="#如何投资" class="headerlink" title="如何投资"></a>如何投资</h1><p>没有谁是生来就会投资的，这种事只能实操。因此，拿出极少的短期储蓄资金验证学习过的投资模型。不问收益，吃亏要趁早。</p><p>对于投资，按产品可以大致分为：</p><ol><li>低门槛，低风险：货币型基金，债券型基金，债券</li><li>低门槛，中低风险：指数型基金</li><li>低门槛，高风险：P2P，网商贷，期权</li><li>高门槛，中风险：股票型基金，混合型基金，股票</li><li>高门槛，高风险：信托，虚拟货币</li></ol><p>这里的门槛指的是搞明白自己做了什么要花的功夫。风险越高收益越高，低风险不是代表没有风险，仅仅是亏的概率低，损失低的意思。投资就是借钱给别人，总有几率别人会赖账。有监管赖不掉，可能会还得少一点，没监管赖掉了也就赖掉了，这就是风险高。</p><p>对于穷人投资，一定要看到得就是市场监管，这是避免别人卷钱跑路的保证。网商贷，P2P，虚拟货币等由于是新兴事物，不容易得到监管 ，在没有足够能力时，无异于飞蛾扑火，这部分最好不要碰。监管得好的就是低中风险的理财产品，低风险绝大部分情况能赚钱，即使发生意外也能不亏。中风险就是要做好亏钱的准备，这里更多的是指股票及股票型基金。</p><p>一支股票的涨跌是很难预料的，你只能通过有限的资料来了解一只股票的变化趋势。它要求一个人具备相当程度的知识，包括但不限于：</p><ol><li>经济学，金融学知识：搞清楚经济运行的规律，市场，金融，政府，企业的关系，投融资手段等。</li><li>财会类知识：公司财会的运行方式，相关概念帮助理解财报，报表等。</li><li>数学，计算机相关知识：统计，归纳，计量，建模等。</li><li>从业经验：只有有从业经验才能明白暗箱操作，后台的运行能帮助理解细微处的变化。</li><li>其他通识类知识</li></ol><p>显然，没有人能完美掌握这些知识，那我列出来的意义何在呢？因为不了解这些知识，很容易犯行内人认为的低级错误，一失足成千古恨。这是能保证不是冤大头的前提，这个行业没有真正明白规律的人，都在裸泳，只有冤大头才能带给人精收益。</p><p>如何投资？</p><ol><li>努力学习相关知识。</li><li>用相关知识，小额金钱，积极实践并记录，形成自己的投资模型。</li><li>待时机成熟随机应变。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回到刚开始的问题，</p><p>人生的真的要一辈子为钱疲于奔命吗？当然，金钱是一定要当作中心任务看待。</p><ul><li>怎样靠谱的获得金钱或者说财富？小钱打工，大钱通过规模化生产，高级打工人，产出比高的工作。</li><li>怎样才能获得这些工作？通识能力加专业能力，通识能力为主，专业能力为辅。</li><li>通识能力是什么？阅读，写作，数学，编程，谈判。</li></ul><p>而通识能力是一个一生都追求不尽的能力，只能总结出一句话”活到老学到老“。我们 一辈子不是在追求金钱，而是在追求怎么认识自己，认识世界。只追求金钱只会陷入一个死循环中：追求人生——为通识能力所困——追求通识能力——为钱所困——追求金钱——为同时能力所困。通识能力才是认识世界，改变世界的源动力。有了通识能力，才能抓住所谓的人生的意义，钱只不过是附属品。</p><p>一个人三岁经历一件事就明白了，有人活到95还没经历这个事他也明白不了。但是吃亏要趁早，一帆风顺不是好事。</p>]]></content>
    
    
    <categories>
      
      <category>世界观</category>
      
    </categories>
    
    
    <tags>
      
      <tag>世界观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS知识库</title>
    <link href="/2020/12/01/CSS%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    <url>/2020/12/01/CSS%E7%9F%A5%E8%AF%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS理论"><a href="#CSS理论" class="headerlink" title="CSS理论"></a>CSS理论</h1><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><h3 id="块级盒子和内联盒子"><a href="#块级盒子和内联盒子" class="headerlink" title="块级盒子和内联盒子"></a>块级盒子和内联盒子</h3><p>一个被定义成块级的（block）盒子会表现出以下行为:</p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li><li>每个盒子都会换行</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性可以发挥作用</li><li>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)和段落(<code>&lt;p&gt;</code>)默认情况下都是块级的盒子。</p><p>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下:</p><ul><li>盒子不会产生换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 属性将不起作用。</li><li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li><li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 <code>inline</code> 状态的盒子推开。</li></ul><p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p><p>我们通过对盒子<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><h3 id="内部和外部显示类型"><a href="#内部和外部显示类型" class="headerlink" title="内部和外部显示类型"></a>内部和外部显示类型</h3><p>同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 正常文档流 布局，也意味着它们和其他块元素以及内联元素一样。我们可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。 顾名思义，把整个html看作一个大盒子，外部显示类型就是基本的html元素显示的类型，内部显示类型就是元素内部的显示类型。即<code>display</code>属性能同时改变内部和外部的显示类型。</p><p>比如<code>display:flex</code>：外部显示类型为<code>block</code>，内部显示类型为<code>flex</code>；<br><code>display: inline-flex</code>:外部显示类型为inline，内部显示类型为<code>flex</code>；</p><h3 id="标准盒模型和IE盒模型"><a href="#标准盒模型和IE盒模型" class="headerlink" title="标准盒模型和IE盒模型"></a>标准盒模型和IE盒模型</h3><p><strong>标准盒模型</strong></p><p>CSS中组成一个块级盒子需要:</p><ul><li><strong>Content box</strong>: 这个区域是用来显示内容，大小可以通过设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>.</li><li><strong>Padding box</strong>: 包围在内容区域外部的空白区域； 大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a> 相关属性设置。</li><li><strong>Border box</strong>: 边框盒包裹内容和内边距。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 相关属性设置。</li><li><strong>Margin box</strong>: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 相关属性设置。</li></ul><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/image-20201214193019396.png" alt="image-20201214193019396"></p><p>所以整个盒子的宽度为：width+2*(padding数值+margin数值+border数值)</p><p><strong>IE盒模型</strong></p><p>你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的! 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。</p><p>默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 <code>box-sizing: border-box</code> 来实现。</p><p>在开发者模式的compute部分可以查看该元素的盒模型。 </p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/image-20201214200427472.png" alt="image-20201214200427472"></p><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p><strong>外边距可正可负可单独设置每边的外边距</strong></p><p>外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。 外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>属性一次控制一个元素的所有边距，或者每边单独使用等价的普通属性控制：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top"><code>margin-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right"><code>margin-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-bottom"><code>margin-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-left"><code>margin-left</code></a></li></ul><p><strong>外边距折叠</strong></p><p>理解外边距的一个关键是外边距折叠的概念。如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。</p><p>有许多规则规定了什么时候外边距会折叠，什么时候不会折叠。相关更多信息，请参阅 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">mastering margin collapsing</a>。现在首先要记住的事情是，外边距会折叠这个事情。如果你用外边距创建空间而没有得到你想要的效果，那这可能就是这个原因。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。为边框设置样式时，有大量的属性可以使用——有四个边框，每个边框都有样式、宽度和颜色，我们可能需要对它们进行操作。</p><p>可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a>属性一次设置所有四个边框的宽度、颜色和样式。</p><p>分别设置每边的宽度、颜色和样式，可以使用：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top"><code>border-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right"><code>border-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left"><code>border-left</code></a></li></ul><p>设置所有边的颜色、样式或宽度，请使用以下属性：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-width"><code>border-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-style"><code>border-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-color"><code>border-color</code></a></li></ul><p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-width"><code>border-top-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-style"><code>border-top-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-top-color"><code>border-top-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-width"><code>border-right-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-style"><code>border-right-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-right-color"><code>border-right-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-width"><code>border-bottom-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-style"><code>border-bottom-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom-color"><code>border-bottom-color</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-width"><code>border-left-width</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-style"><code>border-left-style</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-left-color"><code>border-left-color</code></a></li></ul><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>内边距位于边框和内容区域之间。与外边距不同，您不能有负数量的内边距，所以值必须是0或正的值。应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。我们可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>简写属性控制元素所有边，或者每边单独使用等价的普通属性：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-top"><code>padding-top</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right"><code>padding-right</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-bottom"><code>padding-bottom</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a></li></ul><h3 id="display：inline-block"><a href="#display：inline-block" class="headerlink" title="display：inline-block"></a>display：inline-block</h3><p>display有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用:您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。一个元素使用 <code>display: inline-block</code>，实现我们需要的块级的部分效果：</p><ul><li>设置<code>width</code> 和<code>height</code> 属性会生效。</li><li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li></ul><p>但是，它不会跳转到新行，如果显式添加<code>width</code> 和<code>height</code> 属性，它只会变得比其内容更大。</p><p>这类似于嵌入式的框框，当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。这种情况在导航栏中很常见。</p><h2 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h2><h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-color"><code>background-color</code></a>属性定义了CSS中任何元素的背景颜色。属性接受任何有效的<code>&lt;color&gt;值</code>。背景色扩展到元素的内容和内边距的下面。</p><p>可用的颜色值包括：十六进制，RGBA，定义好的英文颜色名。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a>属性允许在元素的背景中显示图像。如果除了背景图像外，还指定了背景颜色，则图像将显示在颜色的顶部。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat"><code>background-repeat</code></a>属性用于控制图像的平铺行为。可用的值是:</p><ul><li><code>no-repeat</code> — 不重复。</li><li><code>repeat-x</code> —水平重复。</li><li><code>repeat-y</code> —垂直重复。</li><li><code>repeat</code> — 在两个方向重复。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景。你也可以使用关键字:</p><ul><li><code>cover</code> —浏览器将使图像足够大，使它完全覆盖了盒子区，同时仍然保持其高宽比。在这种情况下，有些图像可能会跳出盒子外</li><li><code>contain</code> — 浏览器将使图像的大小适合盒子内。在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能在图像的任何一边或顶部和底部出现间隙。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position"><code>background-position</code></a>属性允许您选择背景图像显示在其应用到的盒子中的位置。<strong>注意：</strong><code>background-position</code>是<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position-x"><code>background-position-x</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-position-y"><code>background-position-y</code></a>的简写，它们允许您分别设置不同的坐标轴的值。它使用的坐标系中，框的左上角是(0,0)，框沿着水平(x)和垂直(y)轴定位。你可以使用像<code>top</code>和<code>right</code>这样的关键字(在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-image"><code>background-image</code></a>页面上查找其他的关键字)，你也可以混合使用关键字，长度值以及百分比。最后，您还可以使用4-value语法来指示到盒子的某些边的距离——在本例中，长度单位是与其前面的值的偏移量。所以在下面的CSS中，我们将背景从顶部调整20px，从右侧调整10px:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123; <br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(star.png); <br>  <span class="hljs-attribute">background-repeat</span>: no-repeat; <br>  <span class="hljs-attribute">background-position</span>: top <span class="hljs-number">20px</span> right <span class="hljs-number">10px</span>; <br>&#125; <br></code></pre></td></tr></table></figure><h4 id="渐变背景"><a href="#渐变背景" class="headerlink" title="渐变背景"></a>渐变背景</h4><p>渐变背景是由三个函数来实现的，分别是<code>linear-gradient(),radial-gradient(),repeating-linear-gradient()</code>。</p><h5 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h5><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/image-20201215182243322.png" alt="image-20201215182243322"></p><p>线性渐变由一个轴 (梯度线) 定义，其上的每个点具有两种或多种的颜色，且轴上的每个点都具有独立的颜色。为了构建出平滑的渐变，<code>linear-gradient()</code> 函数构建一系列垂直于渐变线的着色线，每一条着色线的颜色则取决于与之垂直相交的渐变线上的色点。渐变线由包含渐变图形的容器的中心点和一个角度来定义的。渐变线上的颜色值是由不同的点来定义，包括起始点，终点，以及两者之间的可选的中间点（中间点可以有多个）。起始点是渐变线上代表起始颜色值的点。起始点由渐变线和过容器顶点的垂直线之间的交叉点来定义。（垂直线跟渐变线在同一象限内）同样的，终点是渐变线上代表最终颜色值的点。终点也是由渐变线和从最近的顶点发出的垂直线之间的交叉点定义的，然而从起始点的对称点来定义终点是更容易理解的一种方式，因为终点是起点关于容器的中心点的反射点。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs hsp">linear-gradient(<br>  [ &lt;angle&gt; | to &lt;side-<span class="hljs-keyword">or</span>-corner&gt; ,]? &lt;<span class="hljs-keyword">color</span>-<span class="hljs-keyword">stop</span>-list&gt; )<br>  \---------------------------------/ \----------------------------/<br>    Definition of the gradient <span class="hljs-keyword">line</span>        List of <span class="hljs-keyword">color</span> stops<br><br>where &lt;side-<span class="hljs-keyword">or</span>-corner&gt; = [ left | right ] || [ top | bottom ]<br>  <span class="hljs-keyword">and</span> &lt;<span class="hljs-keyword">color</span>-<span class="hljs-keyword">stop</span>-list&gt; = [ &lt;linear-<span class="hljs-keyword">color</span>-<span class="hljs-keyword">stop</span>&gt; [, &lt;<span class="hljs-keyword">color</span>-hint&gt;? ]? ]<span class="hljs-meta">#, &lt;linear-color-stop&gt;</span><br>  <span class="hljs-keyword">and</span> &lt;linear-<span class="hljs-keyword">color</span>-<span class="hljs-keyword">stop</span>&gt; = &lt;<span class="hljs-keyword">color</span>&gt; [ &lt;<span class="hljs-keyword">color</span>-<span class="hljs-keyword">stop</span>-<span class="hljs-keyword">length</span>&gt; ]?<br>  <span class="hljs-keyword">and</span> &lt;<span class="hljs-keyword">color</span>-<span class="hljs-keyword">stop</span>-<span class="hljs-keyword">length</span>&gt; = [ &lt;percentage&gt; | &lt;<span class="hljs-keyword">length</span>&gt; ]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br>  <span class="hljs-keyword">and</span> &lt;<span class="hljs-keyword">color</span>-hint&gt; = [ &lt;percentage&gt; | &lt;<span class="hljs-keyword">length</span>&gt; ]<br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;side-or-corner&gt;</code></p><p>描述渐变线的起始点位置。它包含to和两个关键词：第一个指出水平位置left or right，第二个指出垂直位置top or bottom。关键词的先后顺序无影响，且都是可选的。 to top, to bottom, to left 和 to right这些值会被转换成角度0度、180度、270度和90度。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。</p></li><li><p><code>&lt;angle&gt;</code></p><p>用角度值指定渐变的方向（或角度）。角度顺时针增加。 </p></li><li><p><code>&lt;linear-color-stop&gt;</code></p><p>由一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value"><code>color</code></a>值组成，并且跟随着一个可选的终点位置（可以是一个百分比值或者是沿着渐变轴的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length">``</a>）。CSS渐变的颜色渲染采取了与SVG相同的规则。</p></li><li><p><code>&lt;color-hint&gt;</code></p><p>颜色中转点是一个插值提示，它定义了在相邻颜色之间渐变如何进行。长度定义了在两种颜色之间的哪个点停止渐变颜色应该达到颜色过渡的中点。如果省略，颜色转换的中点是两个颜色停止之间的中点。 </p></li></ul><blockquote><p>渐变由渐变轴和颜色列表两部分组成。渐变按照渐变轴方向变化，通过angle或 to top, to bottom这样的值进行定义。渐进轴以x轴为0度，逆时针为正方向。颜色列表表明在何处是颜色的终点，如：<code>red 39%</code>表明在渐进轴方向39%处开始变化。</p></blockquote><h5 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h5><p>颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值。由<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/radial-gradient"><code>radial-gradient()</code></a>函数产生。</p><p>径向渐变(Radial gradients)由其<em>中心点</em>、<em>边缘形状</em>轮廓、<em>两个或多个色值结束点（color stops）</em>定义而成。  </p><p>为了创建平滑的渐变，径向渐变函数绘制了一系列从中心点放射到边缘形状（甚至可能超出范围）的同心轮廓。边缘形状可以是圆形（circle）或椭圆形（ellipse）。色彩结束点位于虚拟渐变射线（Virtual gradient ray）上，该渐变射线从中心点水平向右延伸。 基于百分比的色彩结束位置是相对于边缘形状和此渐变射线之间的交点（代表100％）。 每个形状都是一种单色，并由其相交的渐变射线上的颜色确定。</p><h5 id="重复渐变"><a href="#重复渐变" class="headerlink" title="重复渐变"></a>重复渐变</h5><p>重复多次渐变图案直到足够填满指定元素。由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeating-linear-gradient"><code>repeating-linear-gradient()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeating-radial-gradient"><code>repeating-radial-gradient()</code></a>函数产生。</p><h4 id="多个背景图像"><a href="#多个背景图像" class="headerlink" title="多个背景图像"></a>多个背景图像</h4><p>也可以有多个背景图像——在单个属性值中指定多个<code>background-image</code>值，用逗号分隔每个值。当你这样做时，你可能会以背景图像互相重叠而告终。背景将与最后列出的背景图像层在堆栈的底部，背景图像在代码列表中最先出现的在顶端。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">background-image</span>: <span class="hljs-selector-tag">url</span>(<span class="hljs-selector-tag">image1</span><span class="hljs-selector-class">.png</span>), <span class="hljs-selector-tag">url</span>(<span class="hljs-selector-tag">image2</span><span class="hljs-selector-class">.png</span>), <span class="hljs-selector-tag">url</span>(<span class="hljs-selector-tag">image3</span><span class="hljs-selector-class">.png</span>), <span class="hljs-selector-tag">url</span>(<span class="hljs-selector-tag">image1</span><span class="hljs-selector-class">.png</span>);<br><span class="hljs-selector-tag">background-repeat</span>: <span class="hljs-selector-tag">no-repeat</span>, <span class="hljs-selector-tag">repeat-x</span>, <span class="hljs-selector-tag">repeat</span>;<br><span class="hljs-selector-tag">background-position</span>: 10<span class="hljs-selector-tag">px</span> 20<span class="hljs-selector-tag">px</span>,  <span class="hljs-selector-tag">top</span> <span class="hljs-selector-tag">right</span>;<br></code></pre></td></tr></table></figure><blockquote><p>每个背景图像默认在原点处（左上角），对其设置的参数如果全部缺省会重叠，如果部分缺省那么会按照已有的参数轮流应用于不同的图像。如上四张图片只有三个位置值，那么第四张图片将会应用第一个的位置值。</p></blockquote><h4 id="背景滚动"><a href="#背景滚动" class="headerlink" title="背景滚动"></a>背景滚动</h4><p>另一个可供选择的背景是指定他们如何滚动时，内容滚动。这是由<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment"><code>background-attachment</code></a>属性控制的，它可以接受以下值:</p><ul><li><code>scroll</code>: 使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。</li><li><code>fixed</code>: 使元素的背景固定在视图端口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。</li><li><code>local</code>: 这个值是后来添加的(它只在Internet Explorer 9+中受支持，而其他的在IE4+中受支持)，因为滚动值相当混乱，在很多情况下并不能真正实现您想要的功能。局部值将背景固定在设置的元素上，因此当您滚动元素时，背景也随之滚动。</li></ul><p><a href="https://mdn.github.io/learning-area/css/styling-boxes/backgrounds/background-attachment.html">示例</a></p><h4 id="background-的简写"><a href="#background-的简写" class="headerlink" title="background 的简写"></a>background 的简写</h4><p>查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a>的MDN页面，以查看所有的注意事项。如：</p><ul><li>每一层的语法如下：<ul><li>在每一层中，下列的值可以出现 0 次或 1 次：<ul><li><code>&lt;attachment&gt;</code></li><li><code>&lt;bg-image&gt;</code></li><li><code>&lt;position&gt;</code></li><li><code>&lt;bg-size&gt;</code></li><li><code>&lt;repeat-style&gt;</code></li></ul></li><li><code>&lt;bg-size&gt;</code> 只能紧接着 <code>&lt;position&gt;</code> 出现，以”/“分割，如： “<code>center/80%</code>“.</li><li><code>&lt;box&gt;</code> 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin"><code>background-origin</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip"><code>background-clip</code></a>。如果出现 2 次，第一次的出现设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-origin"><code>background-origin</code></a>，第二次的出现设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip"><code>background-clip</code></a>。</li><li><code>&lt;background-color&gt;</code> 只能被包含在最后一层。</li></ul></li></ul><h4 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h4><p>通过使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius"><code>border-radius</code></a>属性和与方框的每个角相关的长边来实现方框的圆角。可以使用两个长度或百分比作为值，第一个值定义水平半径，第二个值定义垂直半径。在很多情况下，您将只传递一个值，这两个值都将使用。</p><h2 id="书写模式"><a href="#书写模式" class="headerlink" title="书写模式"></a>书写模式</h2><h3 id="基本设置-1"><a href="#基本设置-1" class="headerlink" title="基本设置"></a>基本设置</h3><p>CSS中的书写模式是指文本的排列方向是横向还是纵向的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a> 属性使我们从一种模式切换到另一种模式。为此，你不必使用一种竖向的语言——你还可以更改部分文字的方向以实现创新性的布局。</p><p><code>writing-mode</code>的三个值分别是：</p><ul><li><code>horizontal-tb</code>: 块流向从上至下。对应的文本方向是横向的。</li><li><code>vertical-rl</code>: 块流向从右向左。对应的文本方向是纵向的。</li><li><code>vertical-lr</code>: 块流向从左向右。对应的文本方向是纵向的。</li></ul><p>因此，<code>writing-mode</code>属性实际上设定的是页面上块级元素的显示方向——要么是从上到下，要么是从右到左，要么是从左到右。而这决定了文本的方向。</p><h3 id="逻辑外边距、边框和内边距属性"><a href="#逻辑外边距、边框和内边距属性" class="headerlink" title="逻辑外边距、边框和内边距属性"></a>逻辑外边距、边框和内边距属性</h3><p>我们在前面两节中学习了CSS的盒模型和CSS边框。在外边距、边框和内边距属性中，你会发现许多物理属性，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-top"><code>margin-top</code></a>、 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left"><code>padding-left</code></a>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-bottom"><code>border-bottom</code></a>。就像width和height有映射，这些属性也有相应的映射。如果你用<code>writing-mode</code>把盒子<code>.box</code>的书写模式改为<code>vertical-rl</code>，你将会看到尽管盒子的物理方向变了，盒子的物理属性仍然没变，然而逻辑属性会随着书写模式一起改变。</p><p>逻辑属性是在物理属性之后出现的，因而最近才开始在浏览器中应用。你可以通过查看MDN的属性页面来了解浏览器对逻辑属性的支持情况。如果你并没有应用多种书写模式，那么现在你可能更倾向于使用物理属性，因为这些在你使用弹性布局和网格布局时非常有用。</p><h2 id="溢出处理"><a href="#溢出处理" class="headerlink" title="溢出处理"></a>溢出处理</h2><p>你也许会好奇，为什么CSS默认会采取如此不整洁的方式，让内容这么凌乱地溢出出来呢？为何不把多余的内容隐藏起来，或者让盒子变大呢？</p><p>只要有可能，CSS就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。在CSS的术语里面，这会导致一些内容消失，你的访客可能不会注意到这一点，如果消失的是表格上的提交按钮，没有人能填完这个表格，这是很麻烦的事情！所以CSS反而会把它以可见的形式溢出出去。这样做的结果就是，你会看到错误的CSS导致的一片混乱，或者最坏的情况也只是你的网站的访客会告诉你有些内容冒了出来，你的网站需要修缮。</p><h3 id="overflow属性"><a href="#overflow属性" class="headerlink" title="overflow属性"></a>overflow属性</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a>属性是你控制一个元素溢出的方式，它告诉浏览器你想怎样处理溢出。<code>overflow</code>的默认值为<code>visible</code>，这就是我们的内容溢出的时候，我们在默认情况下看到它们的原因。</p><p>如果你想在内容溢出的时候把它裁剪掉，你可以在你的盒子上设置<code>overflow: hidden</code>。这就会像它表面上所显示的那样作用——隐藏掉溢出。这可能会很自然地让东西消失掉，所以你只应该在判断隐藏内容不会引起问题的时候这样做。</p><p>也许你还会想在有内容溢出的时候加个滚动条？如果你用了<code>overflow: scroll</code>，那么你的浏览器总会显示滚动条，即使没有足够多引起溢出的内容。你可能会需要这样的样式，它避免了滚动条在内容变化的时候出现和消失。你可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-y"><code>overflow-y</code></a>属性，设置<code>overflow-y: scroll</code>来仅在<code>y</code>轴方向滚动。</p><p>如果你只是想让滚动条在有比盒子所能装下更多的内容的时候才显示，那么使用<code>overflow: auto</code>。此时由浏览器决定是否显示滚动条。桌面浏览器一般仅仅会在有足以引起溢出的内容的时候这么做。</p><p>在开发网站的时候，你应该一直把溢出的问题挂在心头，你应该用或多或少的内容测试设计，增加文本的字号，确保你的CSS可以正常地协调。改变溢出属性的值，来隐藏内容或者增加滚动条，会是你仅仅在少数特别情况下需要的，例如在你确实需要一个可滚动盒子的时候。</p><blockquote><p>实际上，现代设计中都尽可能控制height和width让盒子不溢出。overflow给出溢出时怎样处理的方法，默认是显示，另外还有hidden、scroll、auto。scroll可以在方向上控制显示滚动条。auto让浏览器自行决定是否显示滚动条。</p></blockquote><h3 id="替代元素溢出"><a href="#替代元素溢出" class="headerlink" title="替代元素溢出"></a>替代元素溢出</h3><p>图像，iframe，video这些元素是替代元素，因为CSS不能改变内部的布局。</p><p><strong>方法一：</strong></p><p>将一张图片的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>设为100%。这将会允许图片尺寸上小于但不大于盒子。这个技术也会对其他替换元素（例如<code>&lt;video&gt;</code>，或者<code>&lt;iframe&gt;</code>）起作用。</p><p><strong>方法二：</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit"><code>object-fit</code></a>属性可以在这里帮助你。当使用<code>object-fit</code>时，替换元素可以以多种方式被调整到合乎盒子的大小。</p><ul><li>contain：被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E9%82%8A">黑边</a>”。</li><li>cover：被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。</li><li>fill：被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被拉伸以适应内容框。</li><li>none：被替换的内容将保持其原有的尺寸。</li><li>scale-down：内容的尺寸与 <code>none</code> 或 <code>contain</code> 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。</li></ul><h2 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h2><p>在CSS规范和MDN的属性页上，您将能够发现值的存在，因为它们将被尖括号包围，如<code>&lt;color&gt;</code>或<code>&lt;length&gt;</code>。当您看到值<code>&lt;color&gt;</code>对特定属性有效时，这意味着您可以使用任何有效的颜色作为该属性的值，如 <code>&lt;color&gt;</code>参考页面所列。是的，CSS值倾向于使用尖括号表示，以区别于CSS属性(例如<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a>属性和 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value"><color></a> 数据类型)。您可能还会混淆CSS数据类型和HTML元素，因为它们都使用尖括号，但这不太可能——它们在完全不一样的上下文中使用。</p><h3 id="数字、长度和百分比"><a href="#数字、长度和百分比" class="headerlink" title="数字、长度和百分比"></a>数字、长度和百分比</h3><table><thead><tr><th align="left">数值类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;integer&gt;</code></td><td align="left"><code>&lt;integer&gt;</code>是一个整数，比如1024或-55。</td></tr><tr><td align="left"><code>&lt;number&gt;</code></td><td align="left"><code>&lt;number&gt;</code>表示一个小数——它可能有小数点后面的部分，也可能没有，例如0.255、128或-1.2。</td></tr><tr><td align="left"><code>&lt;dimension&gt;</code></td><td align="left"><code>&lt;dimension&gt;</code>是一个<code>&lt;number&gt;</code>，它有一个附加的单位，例如45deg、5s或10px。<code>&lt;dimension&gt;</code>是一个伞形类别，包括<code>&lt;length&gt;</code>、<code>&lt;angle&gt;</code>、<code>&lt;time&gt;</code>和<code>&lt;resolution&gt;</code>类型。</td></tr><tr><td align="left"><code>&lt;percentage&gt;</code></td><td align="left"><code>&lt;percentage&gt;</code>表示一些其他值的一部分，例如50%。百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。</td></tr></tbody></table><h4 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h4><table><thead><tr><th align="left">单位</th><th align="left">名称</th><th align="left">等价换算</th></tr></thead><tbody><tr><td align="left"><code>cm</code></td><td align="left">厘米</td><td align="left">1cm = 96px/2.54</td></tr><tr><td align="left"><code>mm</code></td><td align="left">毫米</td><td align="left">1mm = 1/10th of 1cm</td></tr><tr><td align="left"><code>Q</code></td><td align="left">四分之一毫米</td><td align="left">1Q = 1/40th of 1cm</td></tr><tr><td align="left"><code>in</code></td><td align="left">英寸</td><td align="left">1in = 2.54cm = 96px</td></tr><tr><td align="left"><code>pc</code></td><td align="left">十二点活字</td><td align="left">1pc = 1/16th of 1in</td></tr><tr><td align="left"><code>pt</code></td><td align="left">点</td><td align="left">1pt = 1/72th of 1in</td></tr><tr><td align="left"><code>px</code></td><td align="left">像素</td><td align="left">1px = 1/96th of 1in</td></tr></tbody></table><h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><table><thead><tr><th align="left">单位</th><th align="left">相对于</th></tr></thead><tbody><tr><td align="left"><code>em</code></td><td align="left">在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td align="left"><code>ex</code></td><td align="left">字符“x”的高度</td></tr><tr><td align="left"><code>ch</code></td><td align="left">数字“0”的宽度</td></tr><tr><td align="left"><code>rem</code></td><td align="left">根元素的字体大小</td></tr><tr><td align="left"><code>lh</code></td><td align="left">元素的line-height</td></tr><tr><td align="left"><code>vw</code></td><td align="left">视窗宽度的1%</td></tr><tr><td align="left"><code>vh</code></td><td align="left">视窗高度的1%</td></tr><tr><td align="left"><code>vmin</code></td><td align="left">视窗较小尺寸的1%</td></tr><tr><td align="left"><code>vmax</code></td><td align="left">视图大尺寸的1%</td></tr></tbody></table><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>现代计算机的标准颜色系统是24位的，它允许通过不同的红、绿、蓝通道的组合显示大约1670万种不同的颜色，每个通道有256个不同的值(256 x 256 x 256 = 16,777,216)。让我们来看看在CSS中指定颜色的一些方法。</p><p>第一种是颜色关键字，您可以在<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value">页面</a>上看到 <code>&lt;color&gt;</code>值的完整列表。</p><p>第二种是十六进制值，您可能遇到的下一种颜色值类型是十六进制代码。每个十六进制值由一个散列/磅符号(#)和六个十六进制数字组成，每个十六进制数字都可以取0到f(代表15)之间的16个值中的一个——所以是0123456789abcdef。每对值表示一个通道—红色、绿色和蓝色—并允许我们为每个通道指定256个可用值中的任意一个(16 x 16 = 256)。</p><p>第三种是RGB 和 RGBA的值。RGB值是一个函数—RGB()—它有三个参数，表示颜色的红色、绿色和蓝色通道值，与十六进制值的方法非常相似。RGB的不同之处在于，每个通道不是由两个十六进制数字表示的，而是由一个介于0到255之间的十进制数字表示的——这有点容易理解。RGBA中的A是不透明度。</p><blockquote><p><strong>注意</strong>: 在颜色上设置alpha通道与使用我们前面看到的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a>属性有一个关键区别。当你使用不透明度时，你让元素和它里面的所有东西都不透明，而使用RGBA颜色只让你指定的颜色不透明。</p></blockquote><p>第四种是HSL 和 HSLA 的值。与RGB相比，HSL颜色模型的支持稍差一些(在旧版本的IE中不支持)，它是在设计师们感兴趣之后实现的。<code>hsl()</code> 函数接受色调、饱和度和亮度值作为参数，而不是红色、绿色和蓝色值，这些值的不同方式组合，可以区分1670万种颜色：</p><ul><li><strong>色调</strong>： 颜色的底色。这个值在0和360之间，表示色轮周围的角度。</li><li><strong>饱和度</strong>： 颜色有多饱和？ 它的值为0 - 100%，其中0为无颜色(它将显示为灰色阴影)，100%为全色饱和度</li><li><strong>亮度</strong>：颜色有多亮？ 它从0 - 100%中获取一个值，其中0表示没有光(它将完全显示为黑色)，100%表示完全亮(它将完全显示为白色)</li></ul><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><code>&lt;image&gt;</code> 数据类型用于图像为有效值的任何地方。它可以是一个通过 <code>url()</code>函数指向的实际图像文件，也可以是一个渐变。</p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><code>&lt;position&gt;</code> 数据类型表示一组2D坐标，用于定位一个元素，如背景图像(通过 <code>background-position</code>)。它可以使用关键字(如 <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, 以及<code>center</code> )将元素与2D框的特定边界对齐，以及表示框的顶部和左侧边缘偏移量的长度。</p><p>一个典型的位置值由两个值组成——第一个值水平地设置位置，第二个值垂直地设置位置。如果只指定一个轴的值，另一个轴将默认为 <code>center</code>。</p><h3 id="字符串和标识符"><a href="#字符串和标识符" class="headerlink" title="字符串和标识符"></a>字符串和标识符</h3><p>在上面的示例中，我们看到关键字被用作值的地方(例如<code>&lt;color&gt;</code>关键字，如 <code>red</code>, <code>black</code>, <code>rebeccapurple</code>, and <code>goldenrod</code>)。这些关键字被更准确地描述为标识符，一个CSS可以理解的特殊值。因此它们没有使用引号括起来——它们不被当作字符串。</p><p>在某些地方可以使用CSS中的字符串，例如 <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements#Generating_content_with_before_and_after">在指定生成的内容时</a>。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>我们将查看的最后一种类型的值是一组称为函数的值。在编程中，函数是一段可重用的代码，可以多次运行，以完成重复的任务，对开发人员和计算机都是如此。函数通常与JavaScript、Python或c++等语言相关联，但它们也以属性值的形式存在于CSS中。我们已经在颜色部分看到了函数的作用——<code>rgb()</code>、<code>hsl()</code>等。用于从文件返回图像的值——<code>url()</code>——也是一个函数。</p><p>行为更类似于传统编程语言的值是<code>calc()</code>函数。这个函数使您能够在CSS中进行简单的计算。如果您希望计算出在为项目编写CSS时无法定义的值，并且需要浏览器在运行时为您计算出这些值，那么它特别有用。</p><blockquote><ul><li><strong><code>+</code> 和 <code>-</code> 运算符的两边必须要有空白字符。</strong>比如，<code>calc(50% -8px)</code> 会被解析成为一个无效的表达式，解析结果是：一个百分比 后跟一个负数长度值。而加有空白字符的、有效的表达式 <code>calc(8px + -50%)</code> 会被解析成为：一个长度 后跟一个加号 再跟一个负百分比。</li></ul></blockquote><h2 id="尺寸设置"><a href="#尺寸设置" class="headerlink" title="尺寸设置"></a>尺寸设置</h2><p>在受CSS设置影响之前，HTML元素有其原始的尺寸。一个直观的例子就是图像。一副图像的长和宽由这个图像文件自身确定。这个尺寸就是固有尺寸。</p><p>如果你把图片放置在网页中的时候没有在<code>&lt;img&gt;</code> 标签或CSS中设置其尺寸，那么将使用其固有尺寸显示。</p><h3 id="设置具体的尺寸"><a href="#设置具体的尺寸" class="headerlink" title="设置具体的尺寸"></a>设置具体的尺寸</h3><p>我们当然可以给设计中的元素指定具体大小。 当给元素指定尺寸（然后其内容需要适合该尺寸）时，我们将其称为<strong>外部尺寸</strong>。以上面例子中的 <code>&lt;div&gt;</code> 举例 — 我们可以给它一个具体的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 值, 然后不论我们放什么内容进去它都是该尺寸。</p><h3 id="百分数尺寸"><a href="#百分数尺寸" class="headerlink" title="百分数尺寸"></a>百分数尺寸</h3><p>当使用百分数时，你需要清楚，它是<strong>什么</strong>东西的百分数。对于一个处于另外一个容器当中的盒子，如果你给予了子盒子一个百分数作为宽度，那么它指的是父容器宽度的百分数。但外边框和内边框是个例外。</p><p>注意：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid darkblue;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10%</span>;<br>&#125;<br><br>&lt;div class=&quot;box&quot;&gt;<br>  <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">have</span> <span class="hljs-selector-tag">margin</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">padding</span> <span class="hljs-selector-tag">set</span> <span class="hljs-selector-tag">to</span> 10% <span class="hljs-selector-tag">on</span> <span class="hljs-selector-tag">all</span> <span class="hljs-selector-tag">sides</span>.<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>当你用百分数设定内外边距的时候，值是以<strong>内联尺寸</strong>进行计算的，也即对于左右书写的语言来说的宽度。在我们的例子里面，所有的内外边距是这一宽度的10%，也就是说，你可以让盒子周围的内外边距大小相同。在你以这种方式使用百分数的时候，这是一个需要记住的事实。</p><h3 id="min-和max-尺寸"><a href="#min-和max-尺寸" class="headerlink" title="min-和max-尺寸"></a>min-和max-尺寸</h3><p>除了让万物都有一个确定的大小以外，我们可以让CSS给定一个元素的最大或最小尺寸。如果你有一个包含了变化容量的内容的盒子，而且你总是想让它<strong>至少</strong>有个确定的高度，你应该给它设置一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/min-height"><code>min-height</code></a>属性。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。这在避免溢出的同时并处理变化容量的内容的时候是很有用的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width"><code>max-width</code></a>的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。</p><p>个技术是用来让图片<strong>可响应</strong>的，所以在更小的设备上浏览的时候，它们会合适地缩放。你无论怎样都不应该用这个技术先载入大原始尺寸的图片，再对它们在浏览器中进行缩放。图像应该合适地调整尺寸，以使它们不会比预计中展示时所需要的最大尺寸大。下载过大的图像会造成你的网站变慢，如果用户使用按量收费的网络连接，会让用户花更多钱。</p><h3 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h3><p>视口，即你在浏览器中看到的部分页面，也是有尺寸的。在CSS中，我们有与视口尺寸相关的度量单位，即意为视口宽度的<code>vw</code>单位，以及意为视口高度的 <code>vh</code>单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。</p><p><code>1vh</code>等于视口高度的1%，<code>1vw</code>则为视口宽度的1%.你可以用这些单位约束盒子的大小，还有文字的大小。</p><h2 id="CSS排版"><a href="#CSS排版" class="headerlink" title="CSS排版"></a>CSS排版</h2><h3 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h3><p>正常布局流(normal flow)是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式。</p><p>首先，取得元素的内容来放在一个独立的元素盒子中，然后在其周边加上内边距、边框和外边距 — 就是我们之前看到的盒子模型。</p><p>默认的，一个<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements">块级元素</a>的内容宽度是其父元素的100%，其高度与其内容高度一致。<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements">内联元素</a>的height width与内容一致。你无法设置内联元素的height width — 它们就那样置于块级元素的内容里。 如果你想控制内联元素的尺寸，你需要为元素设置<code>display: block;</code> （或者，<code>display: inline-block;</code> inline-block 混合了inline 和 block的特性。)</p><p>这样解释了独立元素的布局，但是元素之间又是如何相互影响的呢？ 正常布局流（在布局介绍里提到过）是一套在浏览器视口内放置、组织元素的系统。默认的，块级元素按照基于其父元素的<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/CSS/writing-mode">书写顺序</a>(<em>默认值:</em> horizontal-tb)的*块流动方向(block flow direction)*放置 — 每个块级元素会在上一个元素下面另起一行，它们会被设置好的margin 分隔。在英语，或者其他水平书写、自上而下模式里，块级元素是垂直组织的。</p><p>内联元素的表现有所不同 — 它们不会另起一行；只要在其父级块级元素的宽度内有足够的空间，它们与其他内联元素、相邻的文本内容（或者被包裹的）被安排在同一行。如果空间不够，溢出的文本或元素将移到新的一行。</p><p>如果两个相邻的元素都设置了margin 并且两个margin有重叠，那么更大的设置会被保留，小的则会消失 — 这被称为外边距叠加</p><h3 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h3><p>Flexbox 是CSS 弹性盒子布局模块（<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout">Flexible Box Layout</a> Module）的缩写，它被专门设计出来用于创建横向或是纵向的一维页面布局。要使用flexbox，你只需要在想要进行flex布局的父元素上应用<code>display: flex</code> ，所有直接子元素都将会按照flex进行布局。</p><p><code>flex-direction</code>控制盒子的方向，<code>align-items</code>控制盒子内容是否拉伸。</p><p>我们可以在我们的所有子元素上添加<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a> 属性，并赋值为<code>1</code>，这会使得所有的子元素都伸展并填充容器，而不是在尾部留下空白，如果有更多空间，那么子元素们就会变得更宽，反之，他们就会变得更窄。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &gt; <span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>以下简单的布局需求是难以或不可能用这样的工具（ <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats">floats</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning">positioning</a>）方便且灵活的实现的：</p><ul><li>在父内容里面垂直居中一个块内容。</li><li>使容器的所有子项占用等量的可用宽度/高度，而不管有多少宽度/高度可用。</li><li>使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。</li></ul><h4 id="模型说明"><a href="#模型说明" class="headerlink" title="模型说明"></a>模型说明</h4><p>当元素表现为 flex 框时，它们沿着两个轴来布局：</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201219121515.png" alt="image-20201219121515776"></p><ul><li><strong>主轴（main axis）</strong>是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li><li><strong>交叉轴（cross axis）</strong>是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li><li>设置了 <code>display: flex</code> 的父元素（在本例中是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section">``</a>）被称之为 <strong>flex 容器（flex container）。</strong></li><li>在 flex 容器中表现为柔性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）</li></ul><h4 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h4><p>弹性盒子提供了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 这样一个属性，它可以指定主轴的方向（弹性盒子子类放置的地方）— 它默认值是 <code>row</code>，这使得它们在按你浏览器的默认语言方向排成一排（在英语/中文浏览器中是从左到右）。你还可以使用 <code>row-reverse </code>和 <code>column-reverse </code>值反向排列 flex 项目。</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>当你在布局中使用定宽或者定高的时候，可能会出现问题即处于容器中的 弹性盒子子元素会溢出，破坏了布局。解决此问题的一种方法是将以下声明添加到 section css 规则中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">flex-wrap</span>: <span class="hljs-selector-tag">wrap</span><br><span class="hljs-selector-tag">flex</span>: 200<span class="hljs-selector-tag">px</span>;<br></code></pre></td></tr></table></figure><p>现在我们有了多行 弹性盒子— 任何溢出的元素将被移到下一行。在 article 元素上设置的 flex: 200px 规则，意味着每个元素的宽度至少是200px；</p><h4 id="flex-flow-缩写"><a href="#flex-flow-缩写" class="headerlink" title="flex-flow 缩写"></a>flex-flow 缩写</h4><p>到这里，应当注意到存在着 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap"><code>flex-wrap</code></a> — 的缩写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-flow"><code>flex-flow</code></a>。比如，你可以将</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">flex-direction</span>: <span class="hljs-selector-tag">row</span>;<br><span class="hljs-selector-tag">flex-wrap</span>: <span class="hljs-selector-tag">wrap</span>;<br><span class="hljs-comment">/*替换为*/</span><br><span class="hljs-selector-tag">flex-flow</span>: <span class="hljs-selector-tag">row</span> <span class="hljs-selector-tag">wrap</span>;<br></code></pre></td></tr></table></figure><h4 id="动态尺寸"><a href="#动态尺寸" class="headerlink" title="动态尺寸"></a>动态尺寸</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。本例中，我们设置 <code>article</code>元素的 flex 值为 1，这表示每个元素占用空间都是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为它是一个比例，这意味着将每个 flex 项的设置为 400000 的效果和 1 的时候是完全一样的。如果你设置为2，你会看到第三个 <code>article</code> 元素占用了两倍的可用宽度和剩下的一样 — 现在总共有四个比例单位可用。 前两个 flex 项各有一个，因此它们占用每个可用空间的1/4。 第三个有两个单位，所以它占用2/4或这说是1/2的可用空间。您还可以指定 flex 的最小值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这表示“每个flex 项将首先给出200px的可用空间，然后，剩余的可用空间将根据分配的比例共享“。 </p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a> 是一个可以指定最多三个不同值的缩写属性：</p><ul><li>第一个就是上面所讨论过的无单位比例。可以单独指定全写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow"><code>flex-grow</code></a> 属性的值。</li><li>第二个无单位比例 — <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink"><code>flex-shrink</code></a> — 一般用于溢出容器的 flex 项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。 这是一个相当高级的弹性盒子功能，我们不会在本文中进一步说明。</li><li>第三个是上面讨论的最小值。可以单独指定全写 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis"><code>flex-basis</code></a> 属性的值。</li></ul><p>我们建议不要使用全写属性，除非你真的需要（比如要去覆盖之前写的）。使用全写会多写很多的代码，它们也可能有点让人困惑。</p><h4 id="水平和垂直对齐"><a href="#水平和垂直对齐" class="headerlink" title="水平和垂直对齐"></a>水平和垂直对齐</h4><p>还可以使用 弹性盒子的功能让 flex 项沿主轴或交叉轴对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 控制 flex 项在交叉轴上的位置。</p><ul><li>默认的值是 <code>stretch</code>，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。我们的第一个例子在默认情况下得到相等的高度的列的原因。</li><li>在上面规则中我们使用的 <code>center</code> 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。</li><li>你也可以设置诸如 <code>flex-start</code> 或 <code>flex-end</code> 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 了解更多。</li></ul><p>你可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-self"><code>align-self</code></a> 属性覆盖 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/align-items"><code>align-items</code></a> 的行为。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/justify-content"><code>justify-content</code></a> 控制 flex 项在主轴上的位置。</p><ul><li>默认值是 <code>flex-start</code>，这会使所有 flex 项都位于主轴的开始处。</li><li>你也可以用 <code>flex-end</code> 来让 flex 项到结尾处。</li><li><code>center</code> 在 <code>justify-content</code> 里也是可用的，可以让 flex 项在主轴居中。</li><li>而我们上面用到的值 <code>space-around</code> 是很有用的——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。</li><li>还有一个值是 <code>space-between</code>，它和 <code>space-around</code> 非常相似，只是它不会在两端留下任何空间。</li></ul><h4 id="flex-项排序"><a href="#flex-项排序" class="headerlink" title="flex 项排序"></a>flex 项排序</h4><p>弹性盒子也有可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。这也是传统布局方式很难做到的一点。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:first-child</span> &#123;<br>  <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>所有 flex 项默认的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/order"><code>order</code></a> 值是 0。</li><li>order 值大的 flex 项比 order 值小的在显示顺序中更靠后。</li><li>相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是2，1，1和0，那么它们的显示顺序就分别是第四，第二，第三，和第一。</li><li>第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。</li></ul><h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>Flexbox用于设计横向或纵向的布局，而Grid布局则被设计用于同时在两个维度上把元素按行和列排列整齐。我们还分别使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows"><code>grid-template-rows</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-columns"><code>grid-template-columns</code></a> 两个属性定义了一些行和列的轨道。定义了三个<code>1fr</code>的列，还有两个<code>100px</code>的行之后，无需再在子元素上指定任何规则，它们自动地排列到了我们创建的格子当中。与弹性盒子不同的是，在定义网格后，网页并不会马上发生变化。因为<code>display: grid</code>的声明只创建了一个只有一列的网格，所以你的子项还是会像正常布局流那样从上而下一个接一个的排布。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦你拥有了一个grid，你也可以显式地将元素摆放在里面，而不是依赖于浏览器进行自动排列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;<br>    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;<br>    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定义网格"><a href="#定义网格" class="headerlink" title="定义网格"></a>定义网格</h4><p>首先，将容器的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a>属性设置为<code>grid</code>来定义一个网络。与弹性盒子不同的是，在定义网格后，网页并不会马上发生变化。因为<code>display: grid</code>的声明只创建了一个只有一列的网格，所以你的子项还是会像正常布局流那样从上而下一个接一个的排布。通过<code>grid-template-columns</code>可以加列，当然，这里可以用任何长度单位，包括百分比。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">200px</span> <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="fr单位定义网格"><a href="#fr单位定义网格" class="headerlink" title="fr单位定义网格"></a>fr单位定义网格</h5><p>除了长度和百分比，我们也可以用<code>fr</code>这个单位来灵活地定义网格的行与列的大小。这个单位表示了可用空间的一个比例。相当于将可用的父空间等比进行划分。1fr 1fr 1fr将空间分成三份，每份为一个网格。2fr 2fr 1fr将空间分成五份，前两个网格都占两份，后一个占一份。类似于这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于每次写1fr有点麻烦，也有比较简单的方法，通过repeat函数进行构建：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*该写法和上面等效*/</span><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>repeat(2, 2fr 1fr)</code>相当于填入了<code>2fr 1fr 2fr 1fr</code>。数字代表重复次数，后面是基本设置。</p><h5 id="网格间隙"><a href="#网格间隙" class="headerlink" title="网格间隙"></a>网格间隙</h5><p>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column-gap"><code>grid-column-gap</code></a> 属性来定义列间隙；使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row-gap"><code>grid-row-gap</code></a> 来定义行间隙；使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-gap"><code>grid-gap</code></a> 可以同时设定两者。间隙距离可以用任何长度单位包括百分比来表示，但不能使用<code>fr</code>单位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="显式网格和隐式网格"><a href="#显式网格和隐式网格" class="headerlink" title="显式网格和隐式网格"></a>显式网格和隐式网格</h5><p>显式网格是我们用<code>grid-template-columns</code> 或 <code>grid-template-rows</code> 属性创建的。而隐式网格则是当有内容被放到网格外时才会生成的。隐式网格中生成的行/列大小是参数默认是<code>auto</code>，大小会根据放入的内容自动调整。当然，你也可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows"><code>grid-auto-rows</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns"><code>grid-auto-columns</code></a>属性手动设定隐式网格的大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，隐式网格就是为了放显式网格放不下的元素，浏览器根据已经定义的显式网格自动生成的网格部分。</p><h5 id="minmax函数"><a href="#minmax函数" class="headerlink" title="minmax函数"></a>minmax函数</h5><p>100像素高的行/列有时可能会不够用，因为时常会有比100像素高的内容加进去。所以，我们希望可以将其设定为至少100像素，而且可以跟随内容来自动拓展尺寸保证能容纳所有内容。显而易见，你很难知道网页上某个元素的尺寸在不同情况下会变成多少，一些额外的内容或者更大的字号就会导致许多能做到像素级精准的设计出现问题。所以，我们有了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a>函数。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a> 函数为一个行/列的尺寸设置了取值范围。比如设定为 <code>minmax(100px, auto)</code>，那么尺寸就至少为100像素，并且如果内容尺寸大于100像素则会根据内容自动调整。在这里试一下把 <code>grid-auto-rows</code> 属性设置为<code>minmax</code>函数。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">display</span>: grid;<br>    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>    <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, auto);<br>    <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h5><p>某些情况下，我们需要让网格自动创建很多列来填满整个容器。通过设置<code>grid-template-columns</code>属性，我们可以实现这个效果，不过这一次我们会用到<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeat"><code>repeat</code></a>函数中的一个关键字<code>auto-fill</code>来替代确定的重复次数。而函数的第二个参数，我们使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/minmax"><code>minmax</code></a>函数来设定一个行/列的最小值，以及最大值<code>1fr</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, minmax(<span class="hljs-number">200px</span>, <span class="hljs-number">1</span>fr));<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, auto);<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="元素放置"><a href="#元素放置" class="headerlink" title="元素放置"></a>元素放置</h4><h5 id="基于线位置放置"><a href="#基于线位置放置" class="headerlink" title="基于线位置放置"></a>基于线位置放置</h5><p>在定义完了网格之后，我们要把元素放入网格中。我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。而对于阿拉伯语，第一条列分隔线在网格的最右边，因为阿拉伯文是从右往左书写的。</p><p>我们根据这些分隔线来放置元素，通过以下属性来指定从那条线开始到哪条线结束。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column-start"><code>grid-column-start</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column-end"><code>grid-column-end</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row-start"><code>grid-row-start</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row-end"><code>grid-row-end</code></a></li></ul><p>这些属性的值均为分隔线序号，你也可以用以下缩写形式来同时指定开始与结束的线。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column"><code>grid-column</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row"><code>grid-row</code></a></li></ul><p>注意开始与结束的线的序号要使用<code>/</code>符号分开。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">3</span>fr;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><span class="hljs-selector-tag">header</span>,<br><span class="hljs-selector-tag">footer</span> &#123;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>&#125;<br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#999</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code> grid-column: 1 / 3;</code>表示从第一条行分割线开始到第三条行分割线结束。由于设置的<code>grid-template-columns: 1fr 3fr;</code>表示一行有两栏三条分割线，因此，这代表占据一整行。<br><code>grid-row: 1;</code>表示从第一条列分割线开始，直至内容结束。效果如下：</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201221145920.png" alt="image-20201221145920068"></p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201221145729.png" alt="image-20201221145721843"></p><h5 id="基于区域名字放置"><a href="#基于区域名字放置" class="headerlink" title="基于区域名字放置"></a>基于区域名字放置</h5><p>另一种往网格放元素的方式是用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas"><code>grid-template-areas</code></a>属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。下列代码和上图基本一致</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-areas</span>:<br>      <span class="hljs-string">&quot;header header&quot;</span><br>      <span class="hljs-string">&quot;sidebar content&quot;</span><br>      <span class="hljs-string">&quot;footer footer&quot;</span>;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">3</span>fr;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">header</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: header;<br>&#125;<br><br><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: content;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: sidebar;<br>&#125;<br><br><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: footer;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>grid-template-areas</code>属性的使用规则如下：</p><ul><li>你需要填满网格的每个格子</li><li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li><li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li><li>一个连续的区域必须是一个矩形</li><li>使用<code>.</code>符号，让一个格子留空</li></ul><h5 id="网格排版框架"><a href="#网格排版框架" class="headerlink" title="网格排版框架"></a>网格排版框架</h5><p>网格排版框架一般由12到16列的网格构成，你可以用CSS网格系统直接实现而不需要任何第三方的工具，毕竟这是标准定义好了的。文件中包含了一个定义了12列网格的容器。我们暂时可以先用基于线的元素放置模式来将我们的内容放到这个12列的网格中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>            <span class="hljs-attribute">display</span>: grid;<br>            <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">12</span>, minmax(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>fr));<br>            <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>把一个元素“浮动”(float)起来，会改变该元素本身和在正常布局流（normal flow）中跟随它的其他元素的行为。这一元素会浮动到父元素的左上侧或右上侧，并且从正常布局流(normal flow)中移除，这时候其他的周围内容就会在这个被设置浮动(<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>)的元素周围环绕。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 属性有四个可能的值：</p><ul><li><code>left</code> — 将元素浮动到左侧。</li><li><code>right</code> — 将元素浮动到右侧。</li><li><code>none</code> — 默认值, 不浮动。</li><li><code>inherit</code> — 继承父元素的浮动属性。</li></ul><h4 id="首字下沉"><a href="#首字下沉" class="headerlink" title="首字下沉"></a>首字下沉</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br>  <span class="hljs-attribute">text-transform</span>: uppercase;<br>&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3em</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>  <span class="hljs-attribute">background</span>: red;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">4px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201221155435.png" alt="image-20201221155435003"></p><h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(1)</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">48%</span>;<br>  <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type(2)</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">48%</span>;<br>  <span class="hljs-attribute">float</span>: right;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的一件事是，当它们变得非常窄时，列就会变得很糟糕。切换回窄屏幕的单列布局通常是有意义的（如手机)，使用媒体查询可以实现这一功能。另一种选择是将宽度设置为一个固定的单位如rem或像素——你可以看到一个例子<code>two-column-layout-fixed.html</code> (<a href="https://github.com/mdn/learning-area/blob/master/css/css-layout/floats/two-column-layout-fixed.html">see source code</a>)，或者通过删除<code>max-width</code> 声明来转换您自己的示例，并改变各个宽度为 <code>900px</code>, <code>430px</code>和 <code>430px</code>。这就是<strong>固定宽度布局</strong>（<strong>fixed-width layout</strong>）</p><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装，如果没有处理这些元素，就会变得很糟糕</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">footer</span> &#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a> 可以取三个值：</p><ul><li><code>left</code>：停止任何活动的左浮动</li><li><code>right</code>：停止任何活动的右浮动</li><li><code>both</code>：停止任何活动的左右浮动</li></ul><p>你通常只想设定一个 <code>clear: both</code> 在你想让浮动停止的元素上。在某些情况下，你会想要只取消<code>left</code> 或 <code>right</code> 引用。</p><h4 id="浮动带来的问题"><a href="#浮动带来的问题" class="headerlink" title="浮动带来的问题"></a>浮动带来的问题</h4><h5 id="整个宽度可能难以计算"><a href="#整个宽度可能难以计算" class="headerlink" title="整个宽度可能难以计算"></a>整个宽度可能难以计算</h5><p>有两个方法可以解决问题，最好的方法是给你的html加上下面的css。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing"><code>box-sizing</code></a> 通过更改盒模型来拯救我们，盒子的宽度取值为 content + padding + border，而不仅是之前的content——所以当增加内边距或边界的宽度时，不会使盒子更宽——而是会使内容调整得更窄。</p><h5 id="列高度不同"><a href="#列高度不同" class="headerlink" title="列高度不同"></a>列高度不同</h5><p>列高度是不同的—— 如果列都是相同的高度，它看起来会更好。</p><p>们可以通过给所有的列固定<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a> 来解决这个问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.column</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">550px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而在许多情况下这并不理想——它使设计呆板。如果你能保证列中总是有相同数量的内容，这是可以的，但这并不总是如此——在很多类型的网站上，内容也会定期更改。这正是像flexbox这样的新布局技术所解决的问题。Flexbox可以自动地延长列，这样他们就会像最长的一列一样。你也可以考虑：</p><ol><li>将这些列的背景颜色设置为父元素的背景颜色，这样您就不会看到高度是不同的。这是目前最好的选择。</li><li>将它们设置为固定的高度，并使内容滚动<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> (参见我们溢流部分的示例。)</li><li>使用一种叫做伪列（faux columns）的技术——这包括将背景(和边界)从实际的列中提取出来，并在列的父元素上画一个伪造的背景，看起来像列的背景一样。不幸的是，这将无法处理列边界。 详见对于<a href="http://alistapart.com/article/fauxcolumns">伪列</a>和<a href="https://www.addedbytes.com/blog/code/faux-columns-for-liquid-layouts/">伪列流体布局</a>的教程。</li></ol><h5 id="清除浮动会变得复杂"><a href="#清除浮动会变得复杂" class="headerlink" title="清除浮动会变得复杂"></a>清除浮动会变得复杂</h5><p>我们在文章中建立的简单例子很容易理解，但是当布局变得更加复杂清理（clearing）也会变得更加复杂。你需要确保所有的浮动都能尽快清除，以避免它们给下方的内容制造麻烦。如果您没有一个方便的容器来进行清理，那么在必要的时候使用clearfix块。</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>定位的整个想法是允许我们覆盖默认文档流行为，以产生有趣的效果。如果你想稍微改变布局中一些盒子的位置，使它们的默认布局流程位置稍微有点古怪，不舒服的感觉呢？定位是你的工具。或者，如果您想要创建一个浮动在页面其他部分顶部的UI元素，并且/或者始终停留在浏览器窗口内的相同位置，无论页面滚动多少？定位使这种布局工作成为可能。</p><p>定位(positioning)并不是一种用来给你做主要页面布局的方式，它更像是让你去管理和微调页面中的一个特殊项的位置。有五种主要的定位类型需要我们了解：</p><ul><li>**静态定位(Static positioning)**是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。</li><li>**相对定位(Relative positioning)**允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计(design pinpointing)非常有用。</li><li>*<em>绝对定位(Absolute positioning)**将元素完全从页面的正常布局流(normal layout flow)中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 <code>&lt;html&gt;</code> 元素边缘固定，或者相对于该元素的</em>最近被定位祖先元素(nearest positioned ancestor element)*。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。</li><li>**固定定位(Fixed positioning)**与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。</li><li>**粘性定位(Sticky positioning)**是一种新的定位方式，它会让元素先保持和<code>position: static</code>一样的定位，当它的相对视口位置(offset from the viewport)达到某一个预设值时，他就会像<code>position: fixed</code>一样定位。</li></ul><h4 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h4><p>相对定位(relative positioning)让你能够把一个正常布局流(normal flow)中的元素从它的默认位置按坐标进行相对移动。</p><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>绝对定位用于将元素移出正常布局流(normal flow)，以坐标的形式相对于它的容器定位到web页面的任何位置，以创建复杂的布局。有趣的是，它经常被用于与相对定位和浮动的协同工作。绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层独立于一切。这是非常有用的：这意味着我们可以创建不干扰页面上其他元素的位置的隔离的UI功能 。例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的UI功能。</p><p>所有这些绝对定位很有趣，但还有另一件事我们还没有考虑到 ——当元素开始重叠，什么决定哪些元素出现在其他元素的顶部？ 在我们已经看到的示例中，我们在定位上下文中只有一个定位的元素，它出现在顶部，因为定位的元素胜过未定位的元素。 当我们有不止一个的时候呢？</p><p>您可以更改堆叠顺序吗？是的，您可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a>属性。网页也有一个z轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有z-index为auto，实际上为0。</p><h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><p>固定定位(fixed positioning)同绝对定位(absolute positioning)一样，将元素从文档流(document flow)当中移出了。但是，定位的坐标不会应用于”容器”边框来计算元素的位置，而是会应用于视口(viewport)边框。利用这一特性，我们可以轻松搞出一个固定位置的菜单，而不受底下的页面滚动的影响。 这意味着您可以创建固定的有用的UI项目，如持久导航菜单。</p><h4 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h4><p>粘性定位(sticky positioning)是最后一种我们能够使用的定位方式。它将默认的静态定位(static positioning)和固定定位(fixed positioning)相混合。当一个元素被指定了<code>position: sticky</code>时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了<code>position: fixed</code>一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.positioned</span> &#123;<br>  <span class="hljs-attribute">position</span>: sticky;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h3><p>表布局是不灵活的，繁重的标记，难以调试和语义上的错误（比如，屏幕阅读器用户在导航表布局方面有问题）。使用CSS表格来进行布局，在现在这个时间点应该被认为是一种传统方法，它通常会被用于兼容一些不支持Flexbox和Grid的浏览器。</p><h4 id="多列布局-1"><a href="#多列布局-1" class="headerlink" title="多列布局"></a>多列布局</h4><p>多列布局模组给了我们 一种把内容按列排序的方式，就像文本在报纸上排列那样。由于在web内容里让你的用户在一个列上通过上下滚动来阅读两篇相关的文本是一种非常低效的方式，那么把内容排列成多列可能是一种有用的技术。要把一个块转变成多列容器(multicol container)，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a>属性来告诉浏览器我们需要多少列，也可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-width"><code>column-width</code></a>来告诉浏览器以至少某个宽度的尽可能多的列来填充容器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="增加样式"><a href="#增加样式" class="headerlink" title="增加样式"></a>增加样式</h4><p>Multicol 创建的列无法单独的设定样式。 不存在让单独某一列比其他列更大的方法，同样无法为某一特定的列设置独特的背景色、文本颜色。你有两个机会改变列的样式：</p><ul><li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a> 改变列间间隙。</li><li>用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule"><code>column-rule</code></a> 在列间加入一条分割线。<code>column-rule</code> 是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule-color"><code>column-rule-color</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-rule-style"><code>column-rule-style</code></a>的缩写，接受同 <code>border</code> 一样的单位。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">column-width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">column-rule</span>: <span class="hljs-number">4px</span> dotted <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>, <span class="hljs-number">185</span>, <span class="hljs-number">227</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>值得一提的是这条分割线本身并不占用宽度。它置于用 <code>column-gap</code> 创建的间隙内。如果需要更多空间，你需要增加 <code>column-gap</code> 的值。</p><h4 id="换行-折断"><a href="#换行-折断" class="headerlink" title="换行/折断"></a>换行/折断</h4><p>多列布局的内容被拆成碎块。 和多页媒体上的内容表现大致一样 — 比如打印网页的时候。 当你把内容放入多列布局容器内，内容被拆成碎块放进列中，内容折断（译者注：比如断词断句）使得这一效果可以实现。在下面的举例中，我用 multicol 对一系列盒子布局，每一小块里有小标题和和一些文字。标题和文字可能被折断点拆开，从而降低阅读体验。</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201222135628.png" alt="image-20201222135628630"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> ...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>I am the heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> ...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>.container &#123;<br>  column-width: 250px;<br>  column-gap: 20px;<br>&#125;<br><br>.card &#123;<br>  background-color: rgb(207, 232, 220);<br>  border: 2px solid rgb(79, 185, 227);<br>  padding: 10px;<br>  margin: 0 0 1em 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fragmentation">CSS Fragmentation</a> 中声明的属性控制这一特性。 这份规范提供了一些属性来控制 multicol 和多页媒体中的内容拆分、折断。比如， 在规则 <code>.card</code> 上添加属性<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/break-inside"><code>break-inside</code></a>，并设值 <code>avoid</code> 。<code>.card</code> 是标题和文本的容器，我们不想拆开这个盒子。</p><p>现阶段，增加旧属性 <code>page-break-inside: avoid</code> 能够获得更好的浏览器支持。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">break-inside</span>: avoid;<br>  <span class="hljs-attribute">page-break-inside</span>: avoid;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">207</span>,<span class="hljs-number">232</span>,<span class="hljs-number">220</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">79</span>,<span class="hljs-number">185</span>,<span class="hljs-number">227</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1em</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>“响应式设计”这个词是<a href="https://alistapart.com/article/responsive-web-design/">Ethan Marcotte在2010年首度提出的</a>，他将其描述为三种技术的混合使用。</p><ol><li>第一个是液态网格，这早先已由Gillenwater进行探讨，可以在Marcotte的文章《<a href="https://alistapart.com/article/fluidgrids/">Fluid Grids</a>》（出版于2009年的《A List Apart》上）中读到。</li><li>第二个是<a href="http://unstoppablerobotninja.com/entry/fluid-images">液态图像</a>的理念。通过使用相当简单的将设置<code>max-width</code>属性设置为<code>100%</code>的技术，图像可以在包含它们的列变得比图像原始尺寸窄的时候，缩放得更小，但总不会变得更大。这使得图像可以被缩放，以被放到一个灵活尺寸的列，而不是溢出出去，同时也不会在列宽于图像的时候，使图像变得太大以至于画质变得粗糙。</li><li>第三个关键的组件是<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries">媒体查询</a>。媒体查询使以往Cameron Adams探讨过的、由JavaScript实现的布局类型切换，可以只使用CSS实现。和所有尺寸的屏幕都使用一种布局不同的是，布局是可以改变的：侧栏可以在小屏幕上重新布局，而替代用的导航栏也可以显示出来。</li></ol><p>需要你理解的很重要的一点是<strong>响应式Web设计不是单独的技术</strong>，它是描述Web设计的一种方式、或者是一组最佳实践的一个词，它是用来建立可以<strong>响应</strong>查看内容的设备的样式的一个词。在Marcotte’s原来的探索中，这意味着灵活网格（使用float）和媒体查询，但是在这篇文章写就的几乎十年以后，Web的响应式工作已经成为了默认做法。现代的CSS布局方式基本上就是响应式的，而且我们在Web平台上内置了新的东西，使得设计响应式站点变得容易。</p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>最简单的媒体查询语法看起来是像这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> media-type <span class="hljs-keyword">and</span> (media-feature-rule) &#123;<br>  <span class="hljs-comment">/* CSS rules go here */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它由以下部分组成：</p><ul><li>一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕）；</li><li>一个媒体表达式，是一个被包含的CSS生效所需的规则或者测试；</li><li>一组CSS规则，会在测试通过且媒体类型正确的时候应用。</li></ul><h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Media_queries#%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B">媒体类型</a></h4><p>你可以指定的媒体类型为：</p><ul><li><code>all</code></li><li><code>print</code></li><li><code>screen</code></li><li><code>speech</code></li></ul><p>下面的媒体查询将会在页面被打印的时候把body设定为只有12pt大小。当页面在浏览器中载入的时候，它将不会生效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> print &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12pt</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="媒体特征规则"><a href="#媒体特征规则" class="headerlink" title="媒体特征规则"></a>媒体特征规则</h4><p>在指定了类型以后，你可以用一条规则指向一种媒体特征。</p><h5 id="宽和高"><a href="#宽和高" class="headerlink" title="宽和高"></a>宽和高</h5><p>为了建立响应式设计（已经广受浏览器支持），我们一般最常探测的特征是视口宽度，而且我们可以使用<code>min-width</code>、<code>max-width</code>和<code>width</code>媒体特征，在视口宽度大于或者小于某个大小——或者是恰好处于某个大小——的时候，应用CSS。</p><p>这些特征是用来创建响应不同屏幕大小的布局的。例如，要想在视口正好是600像素的时候，让body的文本变为红色，你可能会使用下面的媒体查询。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">width:</span> <span class="hljs-number">600px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实践中，使用最小值和最大值对响应式设计有很多的用处，所以你会很少见到<code>width</code>或<code>height</code> 单独使用的情况。</p><h5 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h5><p>一个受到良好支持的媒体特征是<code>orientation</code>，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。要在设备处于横向的时候改变body文本颜色的话，可使用下面的媒体查询。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">orientation:</span> landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: rebeccapurple;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>标准的桌面视图是横放朝向的，在这种朝向上能够表现良好的设计，在处于竖放模式的手机或平板电脑上可能不会表现得这么好。对朝向的测试可以帮你建立一个为竖放设备优化的布局。</p><h5 id="使用指点设备"><a href="#使用指点设备" class="headerlink" title="使用指点设备"></a>使用指点设备</h5><p>作为四级规范的一部分，<code>hover</code>媒体特征被引入了进来。这种特征意味着你可以测试用户是否能在一个元素上悬浮，这也基本就是说他们正在使用某种指点设备，因为触摸屏和键盘导航是没法实现悬浮的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">hover:</span> hover) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: rebeccapurple;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们知道用户不能悬浮的话，我们可以默认显示一些交互功能。对于能够悬浮的用户，我们可以选择在悬浮在链接上的时候，让这些功能可用。</p><p>还是在四级规范中，出现了<code>pointer</code>媒体特征。它可取三个值：<code>none</code>、<code>fine</code>和<code>coarse</code>。<code>fine</code>指针是类似于鼠标或者触控板的东西，它让用户可以精确指向一片小区域。<code>coarse</code>指针是你在触摸屏上的手指。<code>none</code>值意味着，用户没有指点设备，也许是他们正只使用键盘导航，或者是语音命令。</p><p>使用<code>pointer</code>可以在用户使用屏幕时进行交互时，帮你更好地设计响应这种交互的界面。例如，如果你知道用户正在用触摸屏设备交互的时候，你可以建立更大的响应区域。</p><h4 id="复杂媒体查询"><a href="#复杂媒体查询" class="headerlink" title="复杂媒体查询"></a>复杂媒体查询</h4><h5 id="“与”逻辑"><a href="#“与”逻辑" class="headerlink" title="“与”逻辑"></a>“与”逻辑</h5><p>为了混合媒体特征，你可以以与在上面使用<code>and</code>很相同的方式，用<code>and</code>来混合媒体类型和特征。例如，我们可能会想要测得<code>min-width</code>和<code>orientation</code>，而body的文字只会在视口至少为400像素宽，且设备横放时变为蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">400px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation:</span> landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="“或”逻辑"><a href="#“或”逻辑" class="headerlink" title="“或”逻辑"></a>“或”逻辑</h5><p>如果你有一组查询，且要其中的任何一个都可以匹配的话，那么你可以使用逗号分开这些查询。在下面的示例中，文本会在视口至少为400像素宽的时候<strong>或者</strong>设备处于横放状态的时候变为蓝色。如果其中的任何一项成立，那么查询就匹配上了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width:</span> <span class="hljs-number">400px</span>), screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation:</span> landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="“非”逻辑"><a href="#“非”逻辑" class="headerlink" title="“非”逻辑"></a>“非”逻辑</h5><p>你可以用<code>not</code>操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">not</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation:</span> landscape) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CSS变换"><a href="#CSS变换" class="headerlink" title="CSS变换"></a>CSS变换</h2><p>通过改变坐标空间，<strong>CSS transforms</strong> 可以在不影响正常文档流的情况下改变作用内容的位置。可以进行的变形包括旋转，倾斜，缩放以及位移，这些变形同时适用于平面与三维空间。</p><p>有两个主要的属性被用来定义 CSS transforms：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin"><code>transform-origin</code></a></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin"><code>transform-origin</code></a></p><p>指定原点的位置。默认值为元素的中心，可以被移动。很多变形需要用到这个属性，比如旋转，缩放和倾斜，他们都需要一个指定的点作为参数。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">transform-origin</span>: 0 0;//表示以元素左上角为原点<br></code></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a></p><p>指定作用在元素上的变形。取值为空格分隔的一系列变形的列表，他们会像被组合操作请求一样被分别执行。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">none | &lt;transform-list&gt;where <br>&lt;transform-list&gt; = &lt;transform-function&gt;+where <br>&lt;transform-function&gt; = &lt;matrix()&gt; | &lt;translate()&gt; | &lt;translateX()&gt; | &lt;translateY()&gt; | &lt;scale()&gt; | &lt;scaleX()&gt; | &lt;scaleY()&gt; | &lt;rotate()&gt; | &lt;skew()&gt; | &lt;skewX()&gt; | &lt;skewY()&gt; | &lt;matrix3d()&gt; | &lt;translate3d()&gt; | &lt;translateZ()&gt; | &lt;scale3d()&gt; | &lt;scaleZ()&gt; | &lt;rotate3d()&gt; | &lt;rotateX()&gt; | &lt;rotateY()&gt; | &lt;rotateZ()&gt; | &lt;perspective()&gt;where <br>&lt;matrix()&gt; = matrix( &lt;number&gt;#&#123;6&#125; )<br>&lt;translate()&gt; = translate( &lt;length-percentage&gt; , &lt;length-percentage&gt;? )<br>&lt;translateX()&gt; = translateX( &lt;length-percentage&gt; )<br>&lt;translateY()&gt; = translateY( &lt;length-percentage&gt; )<br>&lt;scale()&gt; = scale( &lt;number&gt; , &lt;number&gt;? )<br>&lt;scaleX()&gt; = scaleX( &lt;number&gt; )<br>&lt;scaleY()&gt; = scaleY( &lt;number&gt; )<br>&lt;rotate()&gt; = rotate( [ &lt;angle&gt; | &lt;zero&gt; ] )<br>&lt;skew()&gt; = skew( [ &lt;angle&gt; | &lt;zero&gt; ] , [ &lt;angle&gt; | &lt;zero&gt; ]? )<br>&lt;skewX()&gt; = skewX( [ &lt;angle&gt; | &lt;zero&gt; ] )<br>&lt;skewY()&gt; = skewY( [ &lt;angle&gt; | &lt;zero&gt; ] )<br>&lt;matrix3d()&gt; = matrix3d( &lt;number&gt;#&#123;16&#125; )<br>&lt;translate3d()&gt; = translate3d( &lt;length-percentage&gt; , &lt;length-percentage&gt; , &lt;length&gt; )<br>&lt;translateZ()&gt; = translateZ( &lt;length&gt; )<br>&lt;scale3d()&gt; = scale3d( &lt;number&gt; , &lt;number&gt; , &lt;number&gt; )<br>&lt;scaleZ()&gt; = scaleZ( &lt;number&gt; )<br>&lt;rotate3d()&gt; = rotate3d( &lt;number&gt; , &lt;number&gt; , &lt;number&gt; , [ &lt;angle&gt; | &lt;zero&gt; ] )<br>&lt;rotateX()&gt; = rotateX( [ &lt;angle&gt; | &lt;zero&gt; ] )<br>&lt;rotateY()&gt; = rotateY( [ &lt;angle&gt; | &lt;zero&gt; ] )<br>&lt;rotateZ()&gt; = rotateZ( [ &lt;angle&gt; | &lt;zero&gt; ] )<br>&lt;perspective()&gt; = perspective( &lt;length&gt; )where <br>&lt;length-percentage&gt; = &lt;length&gt; | &lt;percentage&gt;<br></code></pre></td></tr></table></figure><h2 id="CSS过渡"><a href="#CSS过渡" class="headerlink" title="CSS过渡"></a>CSS过渡</h2><p><strong>CSS transitions</strong> 提供了一种在更改CSS属性时控制动画速度的方法。 其可以让属性变化成为一个持续一段时间的过程，而不是立即生效的。比如，将一个元素的颜色从白色改为黑色，通常这个改变是立即生效的，使用 CSS transitions 后该元素的颜色将逐渐从白色变为黑色，按照一定的曲线速率变化。这个过程可以自定义。</p><p>通常将两个状态之间的过渡称为<strong>隐式过渡（implicit transitions）</strong>，因为开始与结束之间的状态由浏览器决定。CSS transitions 可以决定哪些属性发生动画效果 (明确地列出这些属性)，何时开始 (设置 delay），持续多久 (设置 duration) 以及如何动画 (定义<em>timing function</em>，比如匀速地或先快后慢)。</p><h3 id="可过渡的属性列表"><a href="#可过渡的属性列表" class="headerlink" title="可过渡的属性列表"></a>可过渡的属性列表</h3><p>网页制作者可以定义哪个属性以哪种方式动画，这样能制作出复杂的过渡。因为有些属性动画无意义，所以 <a href="https://developer.mozilla.org/zh-CN/docs/CSS/CSS_animated_properties">可动画属性列表</a> 是一个有限集合。auto 值常常较复杂，规范指出不要在它上动画。一些用户代理，比如基于 Gecko 的，遵循这点；一些，比如基于 WebKit的，没有这么严格限制。在 <code>auto</code> 上动画结果可能不可预期，这取决于浏览器及其版本，应当避免使用。</p><p>同时应当留意这种情形，在插入元素（如 <code>.appendChild()</code>）或改变属性 <code>display: none</code> 后立即使用过渡, 元素将视为没有开始状态，始终处于结束状态。简单的解决办法，改变属性前用 <code>window.setTimeout()</code> 延迟几毫秒。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;single-transition&gt;#<br><span class="hljs-keyword">where</span> <br>&lt;single-transition&gt; = [ <span class="hljs-keyword">none</span> | &lt;single-transition-property&gt; ] || &lt;<span class="hljs-type">time</span>&gt; || &lt;<span class="hljs-keyword">timing</span>-<span class="hljs-keyword">function</span>&gt; || &lt;<span class="hljs-type">time</span>&gt;<br><br><span class="hljs-keyword">where</span> <br>&lt;single-transition-property&gt; = <span class="hljs-keyword">all</span> | &lt;custom-ident&gt;<br>&lt;<span class="hljs-keyword">timing</span>-<span class="hljs-keyword">function</span>&gt; = linear | &lt;cubic-bezier-<span class="hljs-keyword">timing</span>-<span class="hljs-keyword">function</span>&gt; | &lt;step-<span class="hljs-keyword">timing</span>-<span class="hljs-keyword">function</span>&gt;<br><br><span class="hljs-keyword">where</span> <br>&lt;cubic-bezier-<span class="hljs-keyword">timing</span>-<span class="hljs-keyword">function</span>&gt; = ease | ease-<span class="hljs-keyword">in</span> | ease-<span class="hljs-keyword">out</span> | ease-<span class="hljs-keyword">in</span>-<span class="hljs-keyword">out</span> | cubic-bezier(&lt;number &lt;a href=&quot;/zh-CN/docs/CSS/Value_definition_syntax#Brackets&quot; title=&quot;Brackets: enclose several entities, combinators, and multipliers to transform them as a single component&quot;&gt;[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]&gt;, &lt;number&gt;, &lt;number &lt;a href=&quot;/zh-CN/docs/CSS/Value_definition_syntax#Brackets&quot; title=&quot;Brackets: enclose several entities, combinators, and multipliers to transform them as a single component&quot;&gt;[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]&gt;, &lt;number&gt;)<br>&lt;step-<span class="hljs-keyword">timing</span>-<span class="hljs-keyword">function</span>&gt; = step-<span class="hljs-keyword">start</span> | step-<span class="hljs-keyword">end</span> | steps(&lt;<span class="hljs-type">integer</span>&gt;[, &lt;step-position&gt;]?)<br><br><span class="hljs-keyword">where</span> <br>&lt;step-position&gt; = jump-<span class="hljs-keyword">start</span> | jump-<span class="hljs-keyword">end</span> | jump-<span class="hljs-keyword">none</span> | jump-<span class="hljs-keyword">both</span> | <span class="hljs-keyword">start</span> | <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="定义过渡"><a href="#定义过渡" class="headerlink" title="定义过渡"></a>定义过渡</h3><p>CSS 过渡 由简写属性<a href="https://developer.mozilla.org/en-US/docs/CSS/transition"> </a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition"><code>transition</code></a> 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间。也可以用下面子属性来控制过渡的各部分：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property"><code>transition-property</code></a>：指定哪个或哪些 CSS 属性用于过渡。只有指定的属性才会在过渡中发生动画，其它属性仍如通常那样瞬间变化。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-duration"><code>transition-duration</code></a>：指定过渡的时长。或者为所有属性指定一个值，或者指定多个值，为每个属性指定不同的时长。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-timing-function"><code>transition-timing-function</code></a>：指定一个函数，定义属性值怎么变化。缓动函数 <em>Timing functions</em> 定义属性如何计算。多数 <a href="https://developer.mozilla.org/en-US/docs/CSS/timing-function">timing functions</a> 由四点定义一个 bezier 曲线。也可以从 <a href="http://easings.net/">Easing Functions Cheat Sheet</a> 选择缓动效果。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-delay"><code>transition-delay</code></a>：指定延迟，即属性开始变化时与过渡开始发生时之间的时长。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">//简写语法<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">transition</span>: &lt;property&gt; &lt;duration&gt; &lt;timing-function&gt; &lt;delay&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="检测过渡是否完成"><a href="#检测过渡是否完成" class="headerlink" title="检测过渡是否完成"></a>检测过渡是否完成</h3><p>当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 <code>transitionend</code>, 在 WebKit 下是 <code>webkitTransitionEnd</code>. 详情查看页面底部的兼容性表格。 <code>transitionend 事件提供两个属性</code>:</p><ul><li><code>propertyName</code>：字符串，指示已完成过渡的属性。</li><li><code>elapsedTime</code>：浮点数，指示当触发这个事件时过渡已运行的时间（秒）。这个值不受 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-delay"><code>transition-delay</code></a> 影响。</li></ul><p>照例可以用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/addEventListener"><code>element.addEventListener()</code></a> 方法来监听这个事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">el.addEventListener(<span class="hljs-string">&quot;transitionend&quot;</span>, updateTransition, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h3 id="属性值列表长度和持续时间不一致"><a href="#属性值列表长度和持续时间不一致" class="headerlink" title="属性值列表长度和持续时间不一致"></a>属性值列表长度和持续时间不一致</h3><p>以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property"><code>transition-property</code></a> 的值列表长度为标准，如果某个属性值列表长度短于它的，则重复其值以长度一致， 例如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">transition-property</span>: opacity, left, top, height;<br>  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">3s</span>, <span class="hljs-number">5s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将按下面这样处理:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">transition-property</span>: opacity, left, top, height;<br>  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">3s</span>, <span class="hljs-number">5s</span>, <span class="hljs-number">3s</span>, <span class="hljs-number">5s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，如果某个属性的值列表长于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition-property"><code>transition-property</code></a> 的，将被截短。 例如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">transition-property</span>: opacity, left;<br>  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">3s</span>, <span class="hljs-number">5s</span>, <span class="hljs-number">2s</span>, <span class="hljs-number">1s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将按下面这样处理:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">transition-property</span>: opacity, left;<br>  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">3s</span>, <span class="hljs-number">5s</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> <strong>animation</strong> 属性是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name"><code>animation-name</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-duration"><code>animation-duration</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-timing-function"><code>animation-timing-function</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay"><code>animation-delay</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-iteration-count"><code>animation-iteration-count</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-direction"><code>animation-direction</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-fill-mode"><code>animation-fill-mode</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-play-state"><code>animation-play-state</code></a> 属性的一个简写属性形式。CSS动画是建立在CSS过渡的基础上，因此，过渡能用的属性，动画也能用。</p><p><code>animation</code> 属性用来指定一组或多组动画，每组之间用逗号相隔。</p><p>每个动画定义中的属性值的顺序很重要：可以被解析为<code>&lt;time&gt;</code>的第一个值被分配给<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-duration"><code>animation-duration</code></a>， 第二个分配给 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-delay"><code>animation-delay</code></a>。每个动画定义中的值的顺序，对于区分 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name"><code>animation-name</code></a> 值与其他关键字也很重要。解析时，对于除 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name"><code>animation-name</code></a> 之外的有效的关键字，必须被前面的简写中没有找到值的属性所接受。此外，在序列化时，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation-name"><code>animation-name</code></a> 与以及其他属性值做区分等情况下，必须输出其他属性的默认值。</p><ul><li>single-animation-iteration-count：动画播放的次数。</li><li>single-animation-direction：动画播放的方向。</li><li>single-animation-fill-mode：确定动画在执行之前和之后这两个阶段应用的样式。</li><li>single-animation-play-state：确定动画是否在播放。</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coq">&lt;single-animation&gt;#<span class="hljs-keyword">where</span> <br>&lt;single-animation&gt; = &lt;<span class="hljs-built_in">time</span>&gt; |<span class="hljs-type">| &lt;timing</span>-function&gt; |<span class="hljs-type">| &lt;time</span>&gt; |<span class="hljs-type">| &lt;single</span>-animation-iteration-count&gt; |<span class="hljs-type">| &lt;single</span>-animation-direction&gt; |<span class="hljs-type">| &lt;single</span>-animation-fill-mode&gt; |<span class="hljs-type">| &lt;single</span>-animation-play-state&gt; |<span class="hljs-type">| [ none</span> | <span class="hljs-type">&lt;keyframes</span>-name&gt; ]<span class="hljs-keyword">where</span> <br>&lt;timing-function&gt; = linear | <span class="hljs-type">&lt;cubic</span>-bezier-timing-function&gt; | <span class="hljs-type">&lt;step</span>-timing-function&gt;<br>&lt;single-animation-iteration-count&gt; = infinite | <span class="hljs-type">&lt;number</span>&gt;<br>&lt;single-animation-direction&gt; = normal | <span class="hljs-type">reverse</span> | <span class="hljs-type">alternate</span> | <span class="hljs-type">alternate</span>-reverse<br>&lt;single-animation-fill-mode&gt; = none | <span class="hljs-type">forwards</span> | <span class="hljs-type">backwards</span> | <span class="hljs-type">both</span><br>&lt;single-animation-play-state&gt; = running | <span class="hljs-type">paused</span><br>&lt;keyframes-name&gt; = &lt;custom-<span class="hljs-keyword">ident</span>&gt; | <span class="hljs-type">&lt;string</span>&gt;<span class="hljs-keyword">where</span> <br>&lt;cubic-bezier-timing-function&gt; = ease | <span class="hljs-type">ease</span>-<span class="hljs-built_in">in</span> | <span class="hljs-type">ease</span>-out | <span class="hljs-type">ease</span>-<span class="hljs-built_in">in</span>-out | <span class="hljs-type">cubic</span>-bezier(&lt;number &lt;a href=<span class="hljs-string">&quot;/zh-CN/docs/CSS/Value_definition_syntax#Brackets&quot;</span> title=<span class="hljs-string">&quot;Brackets: enclose several entities, combinators, and multipliers to transform them as a single component&quot;</span>&gt;[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]&gt;, &lt;number&gt;, &lt;number &lt;a href=<span class="hljs-string">&quot;/zh-CN/docs/CSS/Value_definition_syntax#Brackets&quot;</span> title=<span class="hljs-string">&quot;Brackets: enclose several entities, combinators, and multipliers to transform them as a single component&quot;</span>&gt;[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]&gt;, &lt;number&gt;)<br>&lt;step-timing-function&gt; = step-start | <span class="hljs-type">step</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">steps</span>(&lt;integer&gt;[, &lt;step-position&gt;]?)<span class="hljs-keyword">where</span> <br>&lt;step-position&gt; = jump-start | <span class="hljs-type">jump</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">jump</span>-none | <span class="hljs-type">jump</span>-both | <span class="hljs-type">start</span> | <span class="hljs-type">end</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.cylon_eye</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to right,<br>      rgba(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">9</span>) <span class="hljs-number">25%</span>,<br>      <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">1</span>) <span class="hljs-number">50%</span>,<br>      <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">9</span>) <span class="hljs-number">75%</span>);<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br><br>  <span class="hljs-attribute">-webkit-animation</span>: <span class="hljs-number">4s</span> linear <span class="hljs-number">0s</span> infinite alternate move_eye;<br>          <span class="hljs-attribute">animation</span>: <span class="hljs-number">4s</span> linear <span class="hljs-number">0s</span> infinite alternate move_eye;<br>&#125;<br><br><span class="hljs-keyword">@-webkit-keyframes</span> move_eye &#123; <span class="hljs-selector-tag">from</span> &#123; <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">20%</span>; &#125; <span class="hljs-selector-tag">to</span> &#123; <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100%</span>; &#125;  &#125;<br>        <span class="hljs-keyword">@keyframes</span> move_eye &#123; <span class="hljs-selector-tag">from</span> &#123; <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">20%</span>; &#125; <span class="hljs-selector-tag">to</span> &#123; <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100%</span>; &#125;  &#125;<br></code></pre></td></tr></table></figure><h2 id="调试CSS"><a href="#调试CSS" class="headerlink" title="调试CSS"></a>调试CSS</h2><h3 id="查看服务器端源代码"><a href="#查看服务器端源代码" class="headerlink" title="查看服务器端源代码"></a>查看服务器端源代码</h3><p>按F12打开开发者模式，元素一栏实际上浏览器在渲染的 DOM 中已为你纠正了一些错误的 HTML 部分。如果你错误地闭合了元素（比如开始标签是<code>&lt;h2&gt;</code>，结束标签是<code>&lt;/h3&gt;</code>。），浏览器会尽力弄清你的意图，相比之下，View Source 就是服务器端的 HTML 源码。</p><h3 id="审查、编辑、添加CSS"><a href="#审查、编辑、添加CSS" class="headerlink" title="审查、编辑、添加CSS"></a>审查、编辑、添加CSS</h3><p>从页面上选择一个元素，可以通过以下方法：右键该元素，选择审查元素（Inspect）；从 DevTools 左侧 HTML tree 中选择该元素。如果查看 HTML 右边的 <a href="https://developer.mozilla.org/en-US/docs/Tools/Page_Inspector/UI_Tour#Rules_view">Rules view</a> 栏，你应该能看到该元素的 CSS 属性与值。另一个有用的功能是将简写属性展开的功能。</p><p>除了开关属性以外，你还能编辑它们的值。也许你会想要看看是不是另外一种颜色会更好看，或者希望微调什么东西的大小呢？开发者工具可以省去你耗费在编辑样式表和重载页面上的大量时间。</p><p>你可以使用开发者工具添加属性。你可以点击在规则中合拢的花括号，开始向里面键入一个新的声明，此时你可以开始键入新的属性，开发者工具会展示给你一个自动填充的对应属性列表。在选择了 font-size 以后，键入你想要尝试的值。你也可以点击“+”按钮以添加一个对应于相同选择器的规则，将你的新规则加到那里。</p><h3 id="解决优先级问题"><a href="#解决优先级问题" class="headerlink" title="解决优先级问题"></a>解决优先级问题</h3><p>有的时候，在开发过程中，尤其是在你需要编辑运行站点的 CSS 的时候，你将会发现你很难让一些 CSS 被应用。无论你做了什么，元素看起来就是不听 CSS 使唤。这时候大概发生的事情是，一个更明确的选择器覆盖了你的改动，此时开发者工具也能帮助你解决这个问题。</p><h3 id="如何调试前端"><a href="#如何调试前端" class="headerlink" title="如何调试前端"></a>如何调试前端</h3><ul><li><p>从问题中后退一步</p><p>任何代码问题都可能令人沮丧，尤其是 CSS 问题，因为您通常无法获得错误消息用于网络搜索来帮助您找到解决方案。 如果您感到沮丧，请暂时离开该问题一会儿—散步，喝一杯，与同事聊天，或者做一些其他事情。 有时，当您停止思考问题时，解决方案就会神奇地出现，即使没有出现，在感到清爽的时候解决起问题来要容易很多。</p></li><li><p>你有一个有效的 HTML 和 CSS 吗？</p><p>浏览器希望您的 CSS 和 HTML 能够正确编写，但是浏览器也非常宽容，即使标记或样式表中有错误，浏览器也会尽力显示您的网页。 如果您的代码有错误，浏览器需要猜测您的意思，并且可能会对您的想法做出不同的决定。 此外，两种不同的浏览器可能会以两种不同的方式来解决该问题。 因此，一个好的第一步是通过验证器运行 HTML 和 CSS，以获取并修复任何错误。</p></li><li><p>属性和值是否被你正在测试的浏览器所支持?</p><p>浏览器会忽略他们不理解的 CSS。 如果您正在测试的浏览器不支持您正在使用的属性或值，则不会奔溃，但 CSS 不会被应用。 DevTools 通常会以某种方式突出显示不支持的属性和值。您还可以查看 MDN 每个属性页底部的浏览器兼容性表。 这些向您显示浏览器对该属性的支持，如果支持该属性的某些用法，而不支持其他用法，则经常会 break down。 <a href="https://developer.mozilla.org/zh-CN/docs/">这里</a>显示了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/shape-outside"><code>shape-outside</code></a> 属性的兼容性数据。</p></li><li><p>是否有其它东西覆盖了你的 CSS?</p><p>DevTools 将向您显示 CSS 是如何应用的，您可以弄清楚如何使新选择器足够具体，以覆盖旧的 CSS 样式。</p></li><li><p>创建一个称为简化测试用例的东西</p><p>如果上述步骤未能解决问题，则您需要做更多调查。 此时最好的做法是创建一个称为简化测试用例的东西。 能够“减化问题”是一项非常有用的技能。 这将帮助您在自己的代码和同事的代码中发现问题，还使您能够报告错误并更有效地寻求帮助。</p><p>创建一个简化测试用例:</p><ol><li>如果您的标记是动态生成的（例如通过 CMS），请生成显示该问题的静态版本。 诸如 CodePen 之类的代码共享站点可用于托管简化的测试用例，因为它们可以在线访问，并且您可以轻松地与同事共享它们。 您可以先在页面上执行“查看源代码”，然后将 HTML 复制到 CodePen 中，然后获取所有相关的 CSS 和 JavaScript 并将其包括在内。 之后，您可以检查问题是否仍然明显。</li><li>如果删除 JavaScript 不能解决问题，请不要包含 JavaScript。 如果删除 JavaScript 确实消除了问题，那么请尽可能多地删除与问题无关的 JavaScript，保留导致问题的原因。</li><li>删除所有不会导致此问题的 HTML。 删除布局中的组件甚至主要元素。 在保留问题可重现的情况下把代码量尽量减少。</li><li>删除掉任何不影响问题的 CSS。</li></ol></li><li><p>通过发布到论坛或向同事寻求帮助</p></li></ul><h2 id="组织CSS"><a href="#组织CSS" class="headerlink" title="组织CSS"></a>组织CSS</h2><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><h1 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h1><h2 id="基本规则语法"><a href="#基本规则语法" class="headerlink" title="基本规则语法"></a>基本规则语法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">style-rule ::=<br>    <span class="hljs-selector-tag">selectors-list</span> &#123;<br>      properties-list<br>    &#125;<br>其中<br>selectors-list ::=<br>    <span class="hljs-selector-tag">selector</span><span class="hljs-selector-attr">[:pseudo-class]</span> <span class="hljs-selector-attr">[::pseudo-element]</span><br>    <span class="hljs-selector-attr">[, selectors-list]</span><br><br>properties-list ::= <br>    <span class="hljs-selector-attr">[property : value]</span> <span class="hljs-selector-attr">[; properties-list]</span><br></code></pre></td></tr></table></figure><p>有了选择器后，在最基本的层面上，CSS由两个组成部分组成：</p><ul><li><strong>属性：</strong>人类可读的标识符，指示您想要更改的样式特征(例如<code>font-size</code>, <code>width</code>, <code>background-color</code>) 你想改变。</li><li><strong>值：</strong>每个指定的属性都有一个值，该值指示您希望如何更改这些样式特性(例如，要将字体、宽度或背景色更改为。)</li></ul><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 <style> 标签定义内部样式表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="css">    <span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-color</span>: red&#125;</span><br><span class="css">    <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20px</span>&#125;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; margin-left: 20px&quot;</span>&gt;</span><br>    This is a paragraph<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><h4 id="全局选择器"><a href="#全局选择器" class="headerlink" title="全局选择器"></a>全局选择器</h4><p>全局选择器，是由一个星号（<code>*</code>）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容，比如，它紧随在其他元素以及邻代运算符之后的时候）。</p><h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><p>元素属性选择器大有来头，它可以选择属性，通过运算选择含有，部分含有该属性的元素等：</p><p>这些选择器允许基于一个元素自身是否存在（例如<code>href</code>）或者基于各式不同的按属性值的匹配，来选取元素。</p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[*attr*]</code></td><td align="left"><code>a[title]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td></tr><tr><td align="left"><code>[*attr*=*value*]</code></td><td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td></tr><tr><td align="left"><code>[*attr*~=*value*]</code></td><td align="left"><code>p[class~=&quot;special&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素 ，其值为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td></tr><tr><td align="left">`[<em>attr</em></td><td align="left">=<em>value</em>]`</td><td align="left">`div[lang</td></tr><tr><td align="left"><code>[*attr*^=*value*]</code></td><td align="left"><code>li[class^=&quot;box-&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td></tr><tr><td align="left"><code>[*attr*$=*value*]</code></td><td align="left"><code>li[class$=&quot;-box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td></tr><tr><td align="left"><code>[*attr**=*value*]</code></td><td align="left"><code>li[class*=&quot;box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td></tr></tbody></table><p>如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用<code>i</code>值。这个标记告诉浏览器，要以大小写不敏感的方式匹配ASCII字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式，进行匹配——HTML中是大小写敏感的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span> i]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>此外还有一个更加新的<code>s</code>值，它会强制在上下文的匹配正常为大小写不敏感的时候，强行要求匹配时大小写敏感。不过，在浏览器中它不太受支持，而且在上下文为HTML时也没啥用。</p><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><p>在html中添加class属性，然后用css的”.”可以作为选择器选中该元素。如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">ul</span>&gt;<br>  &lt;<span class="hljs-selector-tag">li</span>&gt;项目一&lt;/<span class="hljs-selector-tag">li</span>&gt;<br>  &lt;li class=&quot;special&quot;&gt;项目二&lt;/li&gt;<br>  &lt;<span class="hljs-selector-tag">li</span>&gt;项目 &lt;<span class="hljs-selector-tag">em</span>&gt;三&lt;/<span class="hljs-selector-tag">em</span>&gt;&lt;/<span class="hljs-selector-tag">li</span>&gt;<br>&lt;/<span class="hljs-selector-tag">ul</span>&gt;<br><br><span class="hljs-selector-class">.special</span> &#123;<br>  <span class="hljs-attribute">color</span>: orange;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h4><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><p>后代选择器（通常用单个空格（<code> </code>）字符表示）组合了两个选择器，如果第二个选择器匹配的元素具有与第一个选择器匹配的祖先（父母，父母的父母，父母的父母的父母等）元素，则它们将被选择。利用后代组合器的选择器称为后代选择器。</p><figure class="highlight plain"><figcaption><span>B```直接一个空格连接两个选择器，代表选择前者A的后代名为B的元素。**后代选择器选择所有的后代！**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs A"><br>&#96;&#96;&#96;css<br>ul li &#123;<br>  margin: 2em;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h4><p>子代关系选择器是个大于号（<code>&gt;</code>），只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。例如，只选中作为<code>&lt;article&gt;</code>的直接子元素的<code>&lt;p&gt;</code>元素。</p><h4 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h4><p><strong>相邻兄弟选择器</strong> (<code>+</code>) 介于两个选择器之间，当第二个元素<em>紧跟在</em>第一个元素之后，并且两个元素都是属于同一个父<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/%E5%85%83%E7%B4%A0"><code>元素</code></a>的子元素，则第二个元素将被选中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 图片后面紧跟着的段落将被选中 */</span><br><span class="hljs-selector-tag">img</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-style</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通用兄弟选择器"><a href="#通用兄弟选择器" class="headerlink" title="通用兄弟选择器"></a>通用兄弟选择器</h4><p>如果你想选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（<code>~</code>）。要选中所有的<code>&lt;p&gt;</code>元素后<em>任何地方</em>的<code>&lt;img&gt;</code>元素，我们会这样做：p~img</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。伪类就是开头为冒号的关键字。</p><h4 id="常用的伪类有"><a href="#常用的伪类有" class="headerlink" title="常用的伪类有"></a>常用的伪类有</h4><table><thead><tr><th align="left">选择器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a></td><td align="left">在用户激活（例如点击）元素的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:any-link"><code>:any-link</code></a></td><td align="left">匹配一个链接的<code>:link</code>和<code>:visited</code>状态。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:blank"><code>:blank</code></a></td><td align="left">匹配空输入值的<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">``元素</a>。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:checked"><code>:checked</code></a></td><td align="left">匹配处于选中状态的单选或者复选框。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:current"><code>:current</code></a></td><td align="left">匹配正在展示的元素，或者其上级元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:default"><code>:default</code></a></td><td align="left">匹配一组相似的元素中默认的一个或者更多的UI元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:dir"><code>:dir</code></a></td><td align="left">基于其方向性（HTML<code>dir</code>属性或者CSS<code>direction</code>属性的值）匹配一个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:disabled"><code>:disabled</code></a></td><td align="left">匹配处于关闭状态的用户界面元素</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:empty"><code>:empty</code></a></td><td align="left">匹配除了可能存在的空格外，没有子元素的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:enabled"><code>:enabled</code></a></td><td align="left">匹配处于开启状态的用户界面元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first"><code>:first</code></a></td><td align="left">匹配<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Paged_Media">分页媒体</a>的第一页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-child"><code>:first-child</code></a></td><td align="left">匹配兄弟元素中的第一个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type"><code>:first-of-type</code></a></td><td align="left">匹配兄弟元素中第一个某种类型的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a></td><td align="left">当一个元素有焦点的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-visible"><code>:focus-visible</code></a></td><td align="left">当元素有焦点，且焦点对用户可见的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus-within"><code>:focus-within</code></a></td><td align="left">匹配有焦点的元素，以及子代元素有焦点的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:future"><code>:future</code></a></td><td align="left">匹配当前元素之后的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a></td><td align="left">当用户悬浮到一个元素之上的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:indeterminate"><code>:indeterminate</code></a></td><td align="left">匹配未定态值的UI元素，通常为<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox">复选框</a>。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:in-range"><code>:in-range</code></a></td><td align="left">用一个区间匹配元素，当值处于区间之内时匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:invalid"><code>:invalid</code></a></td><td align="left">匹配诸如<code>&lt;input&gt;</code>的位于不可用状态的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:lang"><code>:lang</code></a></td><td align="left">基于语言（HTML<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/lang">lang</a>属性的值）匹配元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-child"><code>:last-child</code></a></td><td align="left">匹配兄弟元素中最末的那个元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:last-of-type"><code>:last-of-type</code></a></td><td align="left">匹配兄弟元素中最后一个某种类型的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:left"><code>:left</code></a></td><td align="left">在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Pages">分页媒体</a>中，匹配左手边的页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a></td><td align="left">匹配未曾访问的链接。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:local-link"><code>:local-link</code></a></td><td align="left">匹配指向和当前文档同一网站页面的链接。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:is"><code>:is()</code></a></td><td align="left">匹配传入的选择器列表中的任何选择器。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:not"><code>:not</code></a></td><td align="left">匹配作为值传入自身的选择器未匹配的物件。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child"><code>:nth-child</code></a></td><td align="left">匹配一列兄弟元素中的元素——兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-of-type"><code>:nth-of-type</code></a></td><td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素）——兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配元素1、3、5、7等。即所有的奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-child"><code>:nth-last-child</code></a></td><td align="left">匹配一列兄弟元素，从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-last-of-type"><code>:nth-last-of-type</code></a></td><td align="left">匹配某种类型的一列兄弟元素（比如，<code>&lt;p&gt;</code>元素），从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如2n+1匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-child"><code>:only-child</code></a></td><td align="left">匹配没有兄弟元素的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:only-of-type"><code>:only-of-type</code></a></td><td align="left">匹配兄弟元素中某类型仅有的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:optional"><code>:optional</code></a></td><td align="left">匹配不是必填的form元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:out-of-range"><code>:out-of-range</code></a></td><td align="left">按区间匹配元素，当值不在区间内的的时候匹配。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:past"><code>:past</code></a></td><td align="left">匹配当前元素之前的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:placeholder-shown"><code>:placeholder-shown</code></a></td><td align="left">匹配显示占位文字的input元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:playing"><code>:playing</code></a></td><td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:paused"><code>:paused</code></a></td><td align="left">匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-only"><code>:read-only</code></a></td><td align="left">匹配用户不可更改的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:read-write"><code>:read-write</code></a></td><td align="left">匹配用户可更改的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:required"><code>:required</code></a></td><td align="left">匹配必填的form元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:right"><code>:right</code></a></td><td align="left">在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Pages">分页媒体</a>中，匹配右手边的页。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:root"><code>:root</code></a></td><td align="left">匹配文档的根元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:scope"><code>:scope</code></a></td><td align="left">匹配任何为参考点元素的的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:valid"><code>:valid</code></a></td><td align="left">匹配诸如<code>&lt;input&gt;</code>元素的处于可用状态的元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:target"><code>:target</code></a></td><td align="left">匹配当前URL目标的元素（例如如果它有一个匹配当前<a href="https://en.wikipedia.org/wiki/Fragment_identifier">URL分段</a>的元素）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a></td><td align="left">匹配已访问链接。</td></tr></tbody></table><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号<code>::</code>。</p><p>选择一个元素的某个部分而不是元素自己。例如，<code>::first-line</code>是会选择一个元素（下面的情况中是<code>&lt;p&gt;</code>）中的第一行，类似<code>&lt;span&gt;</code>包在了第一个被格式化的行外面，然后选择这个<code>&lt;span&gt;</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="生成带有-before和-after的内容"><a href="#生成带有-before和-after的内容" class="headerlink" title="生成带有::before和::after的内容"></a>生成带有::before和::after的内容</h4><p>有一组特别的伪元素，它们和<code>content</code>属性一同使用，使用CSS将内容插入到你的文档中中。从CSS插入文本字符串，我们并不会在Web浏览器上经常这么做，因为对于一些屏幕阅读器来说，文本是不可见的，而且对于未来别人的查找和编辑也不是很方便。这些伪元素的更推荐的用法是插入一个图标，例如下面的示例加入的一个小箭头，作为一个视觉性的提示，而且我们并不希望屏幕阅读器读出它。</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/image-20201212001136817.png" alt="image-20201212001136817"></p><p>这些伪元素经常用于插入空字符串，其后可以像页面上的其他元素被样式化。</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/image-20201212001416893.png" alt="image-20201212001416893"></p><p><code>::before</code>和<code>::after</code>伪元素与<code>content</code>属性的共同使用，在CSS中被叫做“生成内容”，而且你会见到这种技术被用于完成各种任务。<a href="http://www.cssarrowplease.com/">CSS Arrow Please</a>网站就是一个著名的示例，它帮你用CSS生成一个箭头。在你创建你的箭头的时候看下CSS，你将会看到实际使用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a>伪元素。无论什么时候你看到了这些选择器，都要看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性，以了解文档中添加了什么。</p><h4 id="常用的伪元素"><a href="#常用的伪元素" class="headerlink" title="常用的伪元素"></a>常用的伪元素</h4><table><thead><tr><th align="left">选择器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a></td><td align="left">匹配出现在原有元素的实际内容之后的一个可样式化元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a></td><td align="left">匹配出现在原有元素的实际内容之前的一个可样式化元素。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-letter"><code>::first-letter</code></a></td><td align="left">匹配元素的第一个字母。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::first-line"><code>::first-line</code></a></td><td align="left">匹配包含此伪元素的元素的第一行。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::grammar-error"><code>::grammar-error</code></a></td><td align="left">匹配文档中包含了浏览器标记的语法错误的那部分。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::selection"><code>::selection</code></a></td><td align="left">匹配文档中被选择的那部分。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::spelling-error"><code>::spelling-error</code></a></td><td align="left">匹配文档中包含了浏览器标记的拼写错误的那部分。</td></tr></tbody></table><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><h3 id="无法解析"><a href="#无法解析" class="headerlink" title="无法解析"></a>无法解析</h3><p>鉴于CSS一直不断的开发，因此领先于浏览器可以识别的范围，那么你也许会好奇当浏览器遇到无法解析的CSS选择器或声明的时候会发生什么呢？答案就是浏览器什么也不会做，继续解析下一个CSS样式！</p><p>如果一个浏览器在解析你所书写的CSS规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的CSS声明。在你书写了错误的CSS代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的CSS代码的时候上述的情况同样会发生（直接忽略）。相似的，当浏览器遇到无法解析的选择器的时候，他会直接忽略整个选择器规则，然后解析下一个CSS选择器。</p><p>这样就保证了整个CSS文件可以很好的被调试。</p><h3 id="级联规则"><a href="#级联规则" class="headerlink" title="级联规则"></a>级联规则</h3><p>通常情况下，两个选择器可以选择相同的HTML元素。但是后一个会覆盖前一个的样式，这就是级联规则。</p><h3 id="冲突规则"><a href="#冲突规则" class="headerlink" title="冲突规则"></a>冲突规则</h3><h4 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h4><p>针对同级别规则！</p><p>css规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><h5 id="计算优先级"><a href="#计算优先级" class="headerlink" title="计算优先级"></a>计算优先级</h5><p>针对不同级别规则！</p><p>浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度：</p><ul><li>一个元素选择器不是很具体 — 会选择页面上该类型的所有元素 — 所以它的优先级就会低一些。</li><li>一个类选择器稍微具体点 — 它会选择该页面中有特定 <code>class</code> 属性值的元素 — 所以它的优先级就要高一点。</li></ul><p>现在让我们来看看浏览器如何计算优先级。我们已经知道一个元素选择器比类选择器的优先级更低会被其覆盖。本质上，不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。</p><p>一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：</p><ol><li><strong>千位</strong>： 如果声明在 <code>style</code> 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</li><li><strong>百位</strong>： 选择器中包含ID选择器则该位得一分。</li><li><strong>十位</strong>： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</li><li><strong>个位</strong>：选择器中包含元素、伪元素选择器则该位得一分。</li></ol><blockquote><p>稍微简化一点就是：内联样式&gt;ID选择器&gt;类选择器=属性选择器=伪类&gt;元素选择器=伪元素选择器</p></blockquote><h5 id="覆盖所有优先级"><a href="#覆盖所有优先级" class="headerlink" title="覆盖所有优先级"></a>覆盖所有优先级</h5><p>有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用 — <code>!important</code>。用于修改特定属性的值， 能够覆盖普通规则的层叠。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.better</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: gray;<br>    <span class="hljs-attribute">border</span>: none <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>覆盖 <code>!important</code> 唯一的办法就是另一个 <code>!important</code> 具有 相同<em>优先级</em> 而且顺序靠后，或者更高优先级。</p><p>了解 <code>!important</code> 是为了在阅读别人代码的时候知道有什么作用。 <strong>但是，强烈建议除了非常情况不要使用它。</strong> <code>!important</code> 改变了层叠的常规工作方式，它会使调试 CSS 问题非常困难，特别是在大型样式表中。</p><p>在一种情况下，你可能不得不使用它：当你不能编辑核心的CSS模块，不能用任何其他方式覆盖，而你又真的想要覆盖一个样式时。但说真的，如果可以避免的话就不要用它。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承也需要在上下文中去理解 —— 一些设置在父元素上的css属性是可以被子元素继承的，有些则不能。</p><p>举一个例子，如果你设置一个元素的 <code>color</code> 和 <code>font-family</code> ，每个在里面的元素也都会有相同的属性，除非你直接在元素上设置属性。一些属性是不能继承的 — 举个例子如果你在一个元素上设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 50% ，所有的后代不会是父元素的宽度的50% 。如果这个也可以继承的话，CSS就会很难使用了!</p><p>哪些属性属于默认继承很大程度上是由常识决定的。</p><h5 id="控制继承"><a href="#控制继承" class="headerlink" title="控制继承"></a>控制继承</h5><p>CSS 为控制继承提供了四个特殊的通用属性值。每个css属性都接收这些值。</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inherit"><code>inherit</code></a></p><p>设置该属性会使子元素属性和父元素相同。实际上，就是 “开启继承”.</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/initial"><code>initial</code></a></p><p>设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 <code>inherit</code> 。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset"><code>unset</code></a></p><p>将属性重置为自然值，即属性原本是啥样就是啥样。也就是如果属性是自然继承那么就是 <code>inherit</code>，否则和 <code>initial</code>一样。</p></li></ul><p>简单来说，就是inherit开启继承；initial设置为浏览器默认样式，如果没有默认样式就继承；unset意味不进行设置，当属性默认继承则继承，非继承属性则不继承，如默认继承属性color，非继承属性border。</p><p>使用方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>: green;<br>&#125;<br>          <br><span class="hljs-selector-class">.my-class-1</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: inherit;<br>&#125;<br>          <br><span class="hljs-selector-class">.my-class-2</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: initial;<br>&#125;<br>          <br><span class="hljs-selector-class">.my-class-3</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: unset;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="重置所有继承"><a href="#重置所有继承" class="headerlink" title="重置所有继承"></a>重置所有继承</h5><ul><li>all属性</li></ul><p>all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。</p><p>为什么会有这个CSS属性呢？</p><p>我们可能知道，有些CSS属性值基本上所有CSS属性都有，比方说继承inherit!我们CSS reset输入框的时候，是不是有类似这样的代码（实际可能是具体值，作用类似）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span> &#123;<br>    <span class="hljs-attribute">color</span>:inherit;<br>    <span class="hljs-attribute">font-size</span>:inherit;<br>    <span class="hljs-attribute">font-family</span>:inherit;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这类输入控件自身有内置的大小和字体，需要重置。此时，大家就会发现，这些属性值都是inherit, 要是可以合并就好了！</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span> &#123;<br>    <span class="hljs-attribute">all</span>:inherit;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="规则-1"><a href="#规则-1" class="headerlink" title="@规则"></a>@规则</h3><h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p>这是一些特殊的规则，为 CSS提供了一些关于如何表现的指导。 有些<code>@rules</code> 规则很简单，有规则名和值。例如，要将额外的样式表导入主CSS样式表，可以使用<code>@import</code>:<code>@import &#39;styles2.css&#39;;</code></p><h4 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h4><p>它允许您使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries">媒体查询 </a>来应用CSS，仅当某些条件成立(例如，当屏幕分辨率高于某一数量，或屏幕宽度大于某一宽度时)。</p><h3 id="速记属性"><a href="#速记属性" class="headerlink" title="速记属性"></a>速记属性</h3><p>一些属性，如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>*font*</code></a><em>,</em> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>*background*</code></a><em>,</em> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>*padding*</code></a><em>,</em> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>*border*</code></a><em>, and</em> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>*margin*</code></a> <em>等属性称为速记属性</em>–这是因为它们允许您在一行中设置多个属性值，从而节省时间并使代码更整洁。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* In 4-value shorthands like padding and margin, the values are applied</span><br><span class="hljs-comment">   in the order top, right, bottom, left (clockwise from the top). There are also other </span><br><span class="hljs-comment">   shorthand types, for example 2-value shorthands, which set padding/margin</span><br><span class="hljs-comment">   for top/bottom, then left/right */</span><br><span class="hljs-selector-tag">padding</span>: 10<span class="hljs-selector-tag">px</span> 15<span class="hljs-selector-tag">px</span> 15<span class="hljs-selector-tag">px</span> 5<span class="hljs-selector-tag">px</span>;<br><span class="hljs-comment">/*等价于*/</span><br><span class="hljs-selector-tag">padding-top</span>: 10<span class="hljs-selector-tag">px</span>;<br><span class="hljs-selector-tag">padding-right</span>: 15<span class="hljs-selector-tag">px</span>;<br><span class="hljs-selector-tag">padding-bottom</span>: 15<span class="hljs-selector-tag">px</span>;<br><span class="hljs-selector-tag">padding-left</span>: 5<span class="hljs-selector-tag">px</span>;<br></code></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>CSS中的注释以/<em>开头，以</em>/结尾。在下面的代码块中，注释标记了不同代码节的开始。当代码库变得更大时，这对于帮助您导航代码库非常有用–在代码编辑器中搜索注释可以高效地定位代码节。</p><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>空白是指实际空格、制表符和新行。以与HTML相同的方式，浏览器往往忽略CSS中的大部分空白；许多空白只是为了提高可读性。</p><h1 id="CSS语义"><a href="#CSS语义" class="headerlink" title="CSS语义"></a>CSS语义</h1><h2 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h2><p>虽然大多数值是相对简单的关键字或数值，但也有一些可能的值以函数的形式出现。一个例子是<em>calc()函数</em>。这个函数允许您在CSS中进行简单的计算。</p><h4 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;div class=&quot;outer&quot;&gt;&lt;div class=&quot;box&quot;&gt;The inner box is 90% - 30px.&lt;/div&gt;&lt;/div&gt;<br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">90%</span> - <span class="hljs-number">30px</span>);<br>  <span class="hljs-attribute">background-color</span>: rebeccapurple;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个函数由函数名和一些括号组成，其中放置了该函数的允许值。在上面的calc()示例中，我要求此框的宽度为包含块宽度的90%，减去30像素。这不是我可以提前计算的东西，只是在CSS中输入值，因为我不知道90%会是什么。</p><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: rebeccapurple;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0.8turn</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="CSS原理"><a href="#CSS原理" class="headerlink" title="CSS原理"></a>CSS原理</h1><h2 id="为什么使用CSS"><a href="#为什么使用CSS" class="headerlink" title="为什么使用CSS"></a>为什么使用CSS</h2><p>利用对文本进行标记，可以让文本格式化，将纯文本可以分段，列表，表格，甚至插入媒体文件。但在浏览器里呈现的方式都是默认样式——全是黑字白底，从头到脚的线性文档。因此，需要一种语言来美化这样的HTML文档，CSS应运而生。</p><h2 id="CSS是怎样工作的"><a href="#CSS是怎样工作的" class="headerlink" title="CSS是怎样工作的"></a>CSS是怎样工作的</h2><p>当浏览器展示一个文件的时候，它必须兼顾文件的内容和文件的样式信息，下面我们会了解到它处理文件的标准的流程。需要知道的是，下面的步骤是浏览加载网页的简化版本，而且不同的浏览器在处理文件的时候会有不同的方式，但是下面的步骤基本都会出现。</p><ol><li>浏览器载入HTML文件（比如从网络上获取）。</li><li>将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。</li><li>接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。</li><li>浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。</li><li>上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。</li><li>网页展示在屏幕上（这一步被称为着色）。</li></ol><p>结合下面的图示更形象：</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201225202200.png" alt="image-20201225202153369"></p><h2 id="利用CSS怎样进行排版"><a href="#利用CSS怎样进行排版" class="headerlink" title="利用CSS怎样进行排版"></a>利用CSS怎样进行排版</h2><h1 id="CSS模块"><a href="#CSS模块" class="headerlink" title="CSS模块"></a>CSS模块</h1><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><h3 id="弹性盒子-1"><a href="#弹性盒子-1" class="headerlink" title="弹性盒子"></a>弹性盒子</h3><h3 id="网格-1"><a href="#网格-1" class="headerlink" title="网格"></a>网格</h3><h3 id="浮动-1"><a href="#浮动-1" class="headerlink" title="浮动"></a>浮动</h3><h3 id="定位-1"><a href="#定位-1" class="headerlink" title="定位"></a>定位</h3><h3 id="表格布局-1"><a href="#表格布局-1" class="headerlink" title="表格布局"></a>表格布局</h3><h3 id="多列布局-2"><a href="#多列布局-2" class="headerlink" title="多列布局"></a>多列布局</h3><h3 id="响应式布局-1"><a href="#响应式布局-1" class="headerlink" title="响应式布局"></a>响应式布局</h3><h3 id="媒体查询-1"><a href="#媒体查询-1" class="headerlink" title="媒体查询"></a>媒体查询</h3><h2 id="样式化表格"><a href="#样式化表格" class="headerlink" title="样式化表格"></a>样式化表格</h2><h2 id="样式化文字"><a href="#样式化文字" class="headerlink" title="样式化文字"></a>样式化文字</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="颜色-1"><a href="#颜色-1" class="headerlink" title="颜色"></a>颜色</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color"><code>color</code></a> 属性设置选中元素的前景内容的颜色 (通常指文本，不过也包含一些其他东西，或者是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a> 属性放置在文本下方或上方的线 (underline overline)。</p><h4 id="字体种类"><a href="#字体种类" class="headerlink" title="字体种类"></a>字体种类</h4><p>你可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family"><code>font-family</code></a> 属性，这个允许你为浏览器指定一个字体 (或者一个字体的列表)，然后浏览器可以将这种字体应用到选中的元素上。</p><h5 id="网页安全字体"><a href="#网页安全字体" class="headerlink" title="网页安全字体"></a>网页安全字体</h5><p>说到字体可用性，只有某几个字体通常可以应用到所有系统，因此可以毫无顾忌地使用。这些都是所谓的 网页安全字体。</p><p>实际的Web安全字体列表将随着操作系统的发展而改变，但是可以认为下面的字体是网页安全的：</p><table><thead><tr><th align="left">字体名称</th><th align="left">泛型</th><th align="left">注意</th></tr></thead><tbody><tr><td align="left">Arial</td><td align="left">sans-serif</td><td align="left">通常认为最佳做法还是添加 Helvetica 作为 Arial 的首选替代品，尽管它们的字体面几乎相同，但 Helvetica 被认为具有更好的形状，即使Arial更广泛地可用。</td></tr><tr><td align="left">Courier New</td><td align="left">monospace</td><td align="left">某些操作系统有一个 Courier New 字体的替代（可能较旧的）版本叫Courier。使用Courier New作为Courier的首选替代方案，被认为是最佳做法。</td></tr><tr><td align="left">Georgia</td><td align="left">serif</td><td align="left"></td></tr><tr><td align="left">Times New Roman</td><td align="left">serif</td><td align="left">某些操作系统有一个 Times New Roman 字体的替代（可能较旧的）版本叫 Times。使用Times作为Times New Roman的首选替代方案，被认为是最佳做法。</td></tr><tr><td align="left">Trebuchet MS</td><td align="left">sans-serif</td><td align="left">您应该小心使用这种字体——它在移动操作系统上并不广泛。</td></tr><tr><td align="left">Verdana</td><td align="left">sans-serif</td><td align="left"></td></tr></tbody></table><blockquote><p><strong>注意</strong>: 在各种资源中，<a href="http://www.cssfontstack.com/">cssfontstack.com</a> 网站维护了一个可用在 Windows 和 Mac 操作系统上使用的网页安全字体的列表，这可以帮助决策网站的安全性。</p></blockquote><h5 id="默认字体"><a href="#默认字体" class="headerlink" title="默认字体"></a>默认字体</h5><p>CSS 定义了 5 个常用的字体名称: <code>serif, </code>sans-serif, <code>monospace</code>, <code>cursive,</code>和 <code>fantasy. </code>这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。这是一种糟糕的情况，浏览器会尽力提供一个看上去合适的字体。 <code>serif</code>, <code>sans-serif</code> 和 <code>monospace</code> 是比较好预测的，默认的情况应该比较合理，另一方面，<code>cursive</code> 和 <code>fantasy</code> 是不太好预测的，我们建议使用它们的时候应该稍微注意一些，多多测试。</p><table><thead><tr><th align="left">名称</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left"><code>serif</code></td><td align="left">有衬线的字体 （衬线一词是指字体笔画尾端的小装饰，存在于某些印刷体字体中）</td></tr><tr><td align="left"><code>sans-serif</code></td><td align="left">没有衬线的字体。</td></tr><tr><td align="left"><code>monospace</code></td><td align="left">每个字符具有相同宽度的字体，通常用于代码列表。</td></tr><tr><td align="left"><code>cursive</code></td><td align="left">用于模拟笔迹的字体，具有流动的连接笔画。</td></tr><tr><td align="left"><code>fantasy</code></td><td align="left">用来装饰的字体</td></tr></tbody></table><h5 id="字体栈"><a href="#字体栈" class="headerlink" title="字体栈"></a>字体栈</h5><p>由于你无法保证你想在你的网页上使用的字体的可用性 (甚至一个网络字体可能由于某些原因而出错), 你可以提供一个<strong>字体栈</strong> (<strong>font stack</strong>)，这样的话，浏览器就有多种字体可以选择了。只需包含一个<code>font-family属性</code>，其值由几个用逗号分离的字体名称组成。比如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Trebuchet MS&quot;</span>, Verdana, sans-serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，浏览器从列表的第一个开始，然后查看在当前机器中，这个字体是否可用。如果可用，就把这个字体应用到选中的元素中。如果不可用，它就移到列表中的下一个字体，然后再检查。</p><p>在字体栈的最后提供一个合适的通用的字体名称是个不错的办法，这样的话，即使列出的字体都无法使用，浏览器至少可以提供一个还算合适的选择。为了强调这一点，如果没有其他选项可用，那么段落将被赋予浏览器的默认衬线字体 - 通常是Time New Roman - 这对于 sans-serif 字体是不利css的！</p><h5 id="Web字体"><a href="#Web字体" class="headerlink" title="Web字体"></a>Web字体</h5><p>web字体的应用一个是在网上下载合法的字体用<code>@font-face</code>来导入到html页面，另一个是直接用网络服务商的在线字体。它会提供一个link之间嵌入到html的link里，通过css使用它。<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/%E4%B8%BA%E6%96%87%E6%9C%AC%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F/Web_%E5%AD%97%E4%BD%93">参考链接</a></p><p>首先，在CSS的开始处有一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face"><code>@font-face</code></a>块，它指定要下载的字体文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;myFont&quot;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;myFont.ttf&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个下面，你可以使用@font-face中指定的字体种类名称来将你的定制字体应用到你喜欢的任何东西上，比如说：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;myFont&quot;</span>, <span class="hljs-string">&quot;Bitstream Vera Serif&quot;</span>, serif;<br>&#125;<br></code></pre></td></tr></table></figure><p>语法确实比这更复杂，下面我们将详细介绍。</p><p>关于网页字体有两件重要的事情要记住：</p><ol><li>浏览器支持不同的字体格式，因此您需要多种字体格式以获得良好的跨浏览器支持。例如,大多数现代浏览器都支持WOFF / WOFF2(Web Open Font Format versions 1 and 2，Web开放字体格式版本1和2)，它是最有效的格式，但是旧版本IE只支持EOT (Embedded Open Type，嵌入式开放类型)的字体,你可能需要包括一个SVG版本的字体支持旧版本的iPhone和Android浏览器。我们将向您展示如何生成所需的代码。</li><li>字体一般都不能自由使用。您必须为他们付费，或者遵循其他许可条件，比如在代码中(或者在您的站点上)提供字体创建者。你不应该在没有适当的授权的情况下偷窃字体。</li></ol><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>体大小 (通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 属性设置) 可以取大多数这些单位的值 (以及其他，比如百分比 <a href="https://developer.mozilla.org/zh-CN/Learn/CSS/Introduction_to_CSS/Values_and_units#Percentages">percentages</a>)，然而你在调整字体大小时，最常用的单位是：</p><ul><li><code>px</code> (像素): 将像素的值赋予给你的文本。这是一个绝对单位， 它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。</li><li><code>em</code>: 1em 等于我们设计的当前元素的父元素上设置的字体大小 (更加具体的话，比如包含在父元素中的大写字母 M 的宽度) 如果你有大量设置了不同字体大小的嵌套元素，这可能会变得棘手, 但它是可行的，如下图所示。为什么要使用这个麻烦的单位呢? 当你习惯这样做时，那么就会变得很自然，你可以使用<code>em</code>调整任何东西的大小，不只是文本。你可以有一个单位全部都使用 em 的网站，这样维护起来会很简单。</li><li><code>rem</code>: 这个单位的效果和 <code>em</code> 差不多，除了 1<code>rem</code> 等于 HTML 中的根元素的字体大小， (i.e. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/html">``</a>) ，而不是父元素。这可以让你更容易计算字体大小，但是遗憾的是， <code>rem</code> 不支持 Internet Explorer 8 和以下的版本。如果你的项目需要支持较老的浏览器，你可以坚持使用<code>em</code> 或 <code>px</code>, 或者是 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Polyfill">polyfill</a> 就像 <a href="https://github.com/chuckcarpenter/REM-unit-polyfill">REM-unit-polyfill</a>. </li></ul><h4 id="字体样式，字体粗细，文本转换和文本装饰"><a href="#字体样式，字体粗细，文本转换和文本装饰" class="headerlink" title="字体样式，字体粗细，文本转换和文本装饰"></a>字体样式，字体粗细，文本转换和文本装饰</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style"><code>font-style</code></a>: 用来打开和关闭文本 italic (斜体)。 可能的值如下 (你很少会用到这个属性，除非你因为一些理由想将斜体文字关闭斜体状态)：</p><ul><li><code>normal</code>: 将文本设置为普通字体 (将存在的斜体关闭)</li><li><code>italic</code>: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。</li><li><code>oblique</code>: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight"><code>font-weight</code></a>: 设置文字的粗体大小。这里有很多值可选 (比如 <em>-light</em>, <em>-normal</em>, <em>-bold</em>, <em>-extrabold</em>, <em>-black</em>, 等等), 不过事实上你很少会用到 <code>normal</code> 和 <code>bold</code>以外的值：</p><ul><li><code>normal</code>, <code>bold</code>: 普通或者<strong>加粗</strong>的字体粗细</li><li><code>lighter</code>, <code>bolder</code>: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。<code>100</code>–<code>900</code>: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-transform"><code>text-transform</code></a>: 允许你设置要转换的字体。值包括：</p><ul><li><code>none</code>: 防止任何转型。</li><li><code>uppercase</code>: 将所有文本转为大写。</li><li><code>lowercase</code>: 将所有文本转为小写。</li><li><code>capitalize</code>: 转换所有单词让其首字母大写。</li><li><code>full-width</code>: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a>: 设置/取消字体上的文本装饰 (你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为：</p><ul><li><code>none</code>: 取消已经存在的任何文本装饰。</li><li><code>underline</code>: 文本下划线.</li><li><code>overline</code>: 文本上划线</li><li><code>line-through</code>: 穿过文本的线 ，即删除线</li></ul><h4 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h4><p>你可以为你的文本应用阴影，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow"><code>text-shadow</code></a> 属性。这最多需要 4 个值：</p><ol><li>阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/zh-CN/Learn/CSS/Introduction_to_CSS/Values_and_units#Length_and_size">length and size units</a>, 但是 px 是比较合适的。这个值必须指定。</li><li>阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上/向下移动阴影，而不是左/右。这个值必须指定。</li><li>模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为0，这意味着没有模糊。可以使用大多数的 CSS 单位 <a href="https://developer.mozilla.org/zh-CN/Learn/CSS/Introduction_to_CSS/Values_and_units#Length_and_size">length and size units</a>.</li><li>阴影的基础颜色，可以使用大多数的 CSS 颜色单位 <a href="https://developer.mozilla.org/zh-CN/Learn/CSS/Introduction_to_CSS/Values_and_units#Colors">CSS color unit</a>. 如果没有指定，默认为 <code>black</code>.</li></ol><p>您可以通过包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">text-shadow</span>: <span class="hljs-selector-tag">-1px</span> <span class="hljs-selector-tag">-1px</span> 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-id">#aaa</span>,<br>             0<span class="hljs-selector-tag">px</span> 4<span class="hljs-selector-tag">px</span> 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">rgba</span>(0,0,0,0.5),<br>             4<span class="hljs-selector-tag">px</span> 4<span class="hljs-selector-tag">px</span> 5<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">rgba</span>(0,0,0,0.7),<br>             0<span class="hljs-selector-tag">px</span> 0<span class="hljs-selector-tag">px</span> 7<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">rgba</span>(0,0,0,0.4);<br></code></pre></td></tr></table></figure><h3 id="文本布局"><a href="#文本布局" class="headerlink" title="文本布局"></a>文本布局</h3><h4 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h4><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align"><code>text-align</code></a> 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同：</p><ul><li><code>left</code>: 左对齐文本。</li><li><code>right</code>: 右对齐文本。</li><li><code>center</code>: 居中文字</li><li><code>justify</code>: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>，打破一些更长的词语。</li></ul><h4 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h4><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性设置文本每行之间的高，可以接受大多数单位 <a href="https://developer.mozilla.org/zh-CN/Learn/CSS/Introduction_to_CSS/Values_and_units#Length_and_size">length and size units</a>，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 来获得 <code>line-height</code>。当行与行之间拉开空间，正文文本通常看起来更好更容易阅读。推荐的行高大约是 1.5–2 (双倍间距。) 所以要把我们的文本行高设置为字体高度的1.5倍，你可以使用这个:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">line-height</span>: 1.5;<br></code></pre></td></tr></table></figure><h4 id="字母和单词间距"><a href="#字母和单词间距" class="headerlink" title="字母和单词间距"></a>字母和单词间距</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/letter-spacing"><code>letter-spacing</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-spacing"><code>word-spacing</code></a> 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。你不会经常使用它们，但是可能可以通过它们，来获得一个特定的外观，或者让较为密集的文字更加可读。它们可以接受大多数单位 <a href="https://developer.mozilla.org/zh-CN/Learn/CSS/Introduction_to_CSS/Values_and_units#Length_and_size">length and size units</a>.</p><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>以上属性让你了解如何开始在网页上设置文本， 但是你可以使用更多的属性。我们只是想介绍最重要的。一旦你习惯使用上面的内容，你还应该探索以下几点：</p><p>Font 样式:</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>: 在小型大写字母和普通文本选项之间切换。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-kerning"><code>font-kerning</code></a>: 开启或关闭字体间距选项。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-feature-settings"><code>font-feature-settings</code></a>: 开启或关闭不同的 <a href="https://en.wikipedia.org/wiki/OpenType">OpenType</a> 字体特性。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-alternates"><code>font-variant-alternates</code></a>: 控制给定的自定义字体的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-caps"><code>font-variant-caps</code></a>: 控制大写字母替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-east-asian"><code>font-variant-east-asian</code></a>: 控制东亚文字替代字形的使用, 像日语和汉语。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-ligatures"><code>font-variant-ligatures</code></a>: 控制文本中使用的连写和上下文形式。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-numeric"><code>font-variant-numeric</code></a>: 控制数字，分式和序标的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant-position"><code>font-variant-position</code></a>: 控制位于上标或下标处，字号更小的替代字形的使用。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size-adjust"><code>font-size-adjust</code></a>: 独立于字体的实际大小尺寸，调整其可视大小尺寸。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>: 在给定字体的可选拉伸版本中切换。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-underline-position"><code>text-underline-position</code></a>: 指定下划线的排版位置，通过使用 <code>text-decoration-line</code> 属性的<code>underline</code> 值。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-rendering"><code>text-rendering</code></a>: 尝试执行一些文本渲染优化。</li></ul><p>文本布局样式：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-indent"><code>text-indent</code></a>: 指定文本内容的第一行前面应该留出多少的水平空间。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-overflow"><code>text-overflow</code></a>: 定义如何向用户表示存在被隐藏的溢出内容。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a>: 定义如何处理元素内部的空白和换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>: 指定是否能在单词内部换行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction"><code>direction</code></a>: 定义文本的方向 (这取决于语言，并且通常最好让HTML来处理这部分，因为它是和文本内容相关联的。)</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/hyphens"><code>hyphens</code></a>: 为支持的语言开启或关闭连字符。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-break"><code>line-break</code></a>: 对东亚语言采用更强或更弱的换行规则。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-align-last"><code>text-align-last</code></a>: 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-orientation"><code>text-orientation</code></a>: 定义行内文本的方向。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-wrap"><code>word-wrap</code></a>: 指定浏览器是否可以在单词内换行以避免超出范围。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/writing-mode"><code>writing-mode</code></a>: 定义文本行布局为水平还是垂直，以及后继文本流的方向。</li></ul><h3 id="Font简写"><a href="#Font简写" class="headerlink" title="Font简写"></a>Font简写</h3><p>许多字体的属性也可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font"><code>font</code></a> 的简写方式来设置 . 这些是按照以下顺序来写的： <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style"><code>font-style</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-variant"><code>font-variant</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight"><code>font-weight</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch"><code>font-stretch</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a>, and <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family"><code>font-family</code></a>.</p><p>如果你想要使用 <code>font</code> 的简写形式，在所有这些属性中，只有 <code>font-size</code> 和 <code>font-family</code> 是一定要指定的。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size"><code>font-size</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 属性之间必须放一个正斜杠。</p><p>一个完整的例子如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">font</span>: <span class="hljs-selector-tag">italic</span> <span class="hljs-selector-tag">normal</span> <span class="hljs-selector-tag">bold</span> <span class="hljs-selector-tag">normal</span> 3<span class="hljs-selector-tag">em</span>/1.5 <span class="hljs-selector-tag">Helvetica</span>, <span class="hljs-selector-tag">Arial</span>, <span class="hljs-selector-tag">sans-serif</span>;<br></code></pre></td></tr></table></figure><h2 id="样式化列表"><a href="#样式化列表" class="headerlink" title="样式化列表"></a>样式化列表</h2><h3 id="列表间距"><a href="#列表间距" class="headerlink" title="列表间距"></a>列表间距</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* General styles */</span><br><br><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: Helvetica, Arial, sans-serif;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">h2</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2rem</span>;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">ol</span>,<span class="hljs-selector-tag">dl</span>,<span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5rem</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span>, <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>&#125;<br><br><span class="hljs-comment">/* Description list styles */</span><br><br><br><span class="hljs-selector-tag">dd</span>, <span class="hljs-selector-tag">dt</span> &#123;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;<br>&#125;<br><br><span class="hljs-selector-tag">dt</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">dd</span> &#123;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">1.5rem</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type"><code>list-style-type</code></a> ：设置用于列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-position"><code>list-style-position</code></a> ：设置在每个项目开始之前，项目符号是出现在列表项内，还是出现在其外。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-image"><code>list-style-image</code></a> ：允许您为项目符号使用自定义图片，而不是简单的方形或圆形。</li></ul><h3 id="管理列表计数"><a href="#管理列表计数" class="headerlink" title="管理列表计数"></a>管理列表计数</h3><p>通过在html标签中添加start，value，reverse属性可以控制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Toast pitta, leave to cool, then slice down the edge.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fry the halloumi in a shallow, non-stick pan, until browned on both sides.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Wash and chop the salad.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Fill pitta with salad, humous, and fried halloumi.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="样式化链接"><a href="#样式化链接" class="headerlink" title="样式化链接"></a>样式化链接</h2><h3 id="链接状态"><a href="#链接状态" class="headerlink" title="链接状态"></a>链接状态</h3><p>对应的 <a href="https://developer.mozilla.org/zh-CN/Learn/CSS/Introduction_to_CSS/Selectors#Pseudo-classes">伪类</a> 来应用样式:</p><ul><li><strong>Link (没有访问过的)</strong>: 这是链接的默认状态，当它没有处在其他状态的时候，它可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:link"><code>:link</code></a> 伪类来应用样式。</li><li><strong>Visited</strong>: 这个链接已经被访问过了(存在于浏览器的历史纪录), 它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:visited"><code>:visited</code></a> 伪类来应用样式。</li><li><strong>Hover</strong>: 当用户的鼠标光标刚好停留在这个链接，它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:hover"><code>:hover</code></a> 伪类来应用样式。</li><li><strong>Focus</strong>: 一个链接当它被选中的时候 (比如通过键盘的 Tab 移动到这个链接的时候，或者使用编程的方法来选中这个链接 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/focus"><code>HTMLElement.focus()</code></a>) 它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:focus"><code>:focus</code></a> 伪类来应用样式。</li><li><strong>Active</strong>: 一个链接当它被激活的时候 (比如被点击的时候)，它可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:active"><code>:active</code></a> 伪类来应用样式。</li></ul><p>浏览器默认的链接样式为：</p><ul><li>链接具有下划线。</li><li>未访问过的 (Unvisited) 的链接是蓝色的。</li><li>访问过的 (Visited) 的链接是紫色的.</li><li>悬停 (Hover) 在一个链接的时候鼠标的光标会变成一个小手的图标。</li><li>选中 (Focus) 链接的时候，链接周围会有一个轮廓，你应该可以按 tab 来选中这个页面的链接 (在 Mac 上, 你可能需要使用<em>Full Keyboard Access: All controls</em> 选项，然后再按下 Ctrl + F7 ，这样就可以起作用)</li><li>激活 (Active) 链接的时候会变成红色 (当你点击链接时，请尝试按住鼠标按钮。)</li></ul><p>这几个规则的顺序是有意义的，因为链接的样式是建立在另一个样式之上的，比如，第一个规则的样式也会在后面的规则中生效，一个链接被激活 (activated) 的时候，它也是处于悬停 (hover) 状态的。如果你搞错了顺序，那么就可能不会产生正确的效果。要记住这个顺序，你可以尝试这样帮助记忆：<strong>L</strong>o<strong>V</strong>e <strong>F</strong>ears <strong>HA</strong>te.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br><br>&#125;<br><br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br><br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#265301</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#437A16</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#BAE498</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#CDFEAA</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#265301</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#CDFEAA</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在链接中包含图标"><a href="#在链接中包含图标" class="headerlink" title="在链接中包含图标"></a>在链接中包含图标</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&quot;http&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;https://mdn.mozillademos.org/files/12982/external-link-52.png&#x27;</span>) no-repeat <span class="hljs-number">100%</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">16px</span> <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">19px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background"><code>background</code></a> 简写，而不是分别使用多个属性。我们设置了我们想要插入的图片的路径，指定了 <code>no-repeat</code> ，这样我们只插入了一次图片，然后指定位置为100%，使其出现在内容的右边，距离上方是0px。</p><p>我们也使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size"><code>background-size</code></a> 来指定要显示的背景图像的大小，为了满足响应式网站设计的需要，在图标更大，需要再重新调整它的大小的时候，这样做是很有帮助的。但是，这仅适用于IE 9及更高版本。所以你如果需要支持那些老的浏览器，只能调整图像的原始大小，然后插入。</p><p>最后，我们在链接上设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right"><code>padding-right</code></a> ，为背景图片留出空间，这样就不会让它和文本重叠了。</p><h3 id="样式化链接为按钮"><a href="#样式化链接为按钮" class="headerlink" title="样式化链接为按钮"></a>样式化链接为按钮</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Pizza<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Music<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Wombats<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Finland<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">outline</span>: none;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">19.5%</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0.625%</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">color</span>: black;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span>, <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>  <span class="hljs-attribute">background</span>: red;<br>  <span class="hljs-attribute">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们的第二条规则删除了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>ul</code></a> 元素的默认的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a>，然后设置了它的宽度是外部容器 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body"><code>body</code></a> (在这次条件下) 的 100%</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/li"><code>li</code></a> 元素通常默认是块元素，意味着它们各自会占用一行。在这个例子中，我们创建了一组水平列表的链接，所以在第三条规则中，我们设置了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 属性为 inline，这会导致列表中的每项内容都会一起出现在同一行，它们现在表现得就像内联元素。</li><li>我们首先关掉了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-decoration"><code>text-decoration</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/outline"><code>outline</code></a>，我们不希望这些破坏我们链接的样子。</li><li>接着，我们设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>inline-block</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a"><code>a</code></a> 元素默认为内联元素，而且我们不希望它们像值为 <code>block</code> 时一样，线条超出自己的内容，我们确实想要控制它们的大小<code>inline-block</code> 允许我们这样做。</li><li>接着是尺寸的设置! 我们要填满整个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/ul"><code>ul</code></a> 的宽度，为按钮之间留一些间距 (margin)  (但不是右边边缘的间距)，我们有 5 个按钮需要容纳，所以它们的大小应该一样。为了做到这一点，我们设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 为 19.5%，然后 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin-right"><code>margin-right</code></a> 为 0.625%. 你会注意到所有宽度加起来是 100.625%, 这样会让最后一个按钮溢出 <code>&lt;ul&gt;</code> ，然后显示到下一行中。但是，我们使用了下一条规则让它恢复到了 100%，这条规则选中了列表中的最后一个 <code>&lt;a&gt;</code>元素，然后删除了它的间距 (margin)。完成!</li><li>最后三条声明就比较简单了，主要是为链接各个状态添加了颜色。我们居中了每个链接中的文本，设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height"><code>line-height</code></a> 为 3， 让按钮有一些高度 (这也具有垂直居中文本的优点)，并设置文本的颜色为黑色。</li></ul><h1 id="CSS实例"><a href="#CSS实例" class="headerlink" title="CSS实例"></a>CSS实例</h1><h2 id="排版实例"><a href="#排版实例" class="headerlink" title="排版实例"></a>排版实例</h2><h3 id="实例描述"><a href="#实例描述" class="headerlink" title="实例描述"></a>实例描述</h3><p>针对一个已有的默认样式的html页面，对其进行排版。</p><ol><li>在一行中显示导航选项，并且选项之间拥有相同的空间。</li><li>导航条应随着内容一起滚动并且在触碰到视口顶部之后于顶部固定。</li><li>文章内的图片应该被文本包围。</li><li>article和aside元素应该为双列布局。它们的列尺寸应该是弹性的，以便在浏览器窗口收缩得更小的时候能够变窄。</li><li>照片应该以有 1px 间隔的两列网格显示出来。</li></ol><p>效果如下：</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201222165523.png" alt="image-20201222165523342"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>首先进行页面初始化设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">font</span>: <span class="hljs-number">1.2em</span> / <span class="hljs-number">1.2</span> Arial, Helvetica, sans-serif;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>写选择器修改文本一定要选择到文本所在的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这里如果想修改Home的颜色，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*这是不起作用的*/</span><br><span class="hljs-selector-tag">nav</span>&#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br><span class="hljs-comment">/*这才有用*/</span><br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span>&#123;<br>    <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来设置最常用的就是盒模型，改变相应的列表样式，这一步搭建网页的雏形，接下来才是美化排版。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.logo</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">200%</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">50px</span> <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">980px</span>;<br>  &#125;<br><span class="hljs-selector-class">.grid</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">980px</span>;<br>  &#125;<br><span class="hljs-selector-class">.photos</span> &#123;<br>    <span class="hljs-attribute">list-style</span>: none;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这一步我犯了很多错：</p><ul><li><p>我将列表用padding移到相应的位置，忽视了背景色将列表的小圆点覆盖了，导致看起来很别扭。</p></li><li><p>我想把正文部分缩小居中，我使用的是margin来调整，更好的应该使用max-width和padding来调整，不仅简单，还直观。</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201222163146.png" alt="image-20201222163145873"><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/20201222163225.png" alt="image-20201222163225003"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*我的还尝试了很多次才调到合适的参数*/</span><br><span class="hljs-selector-class">.grid</span>&#123;<br>  <span class="hljs-attribute">margin</span>:<span class="hljs-number">25px</span> <span class="hljs-number">75px</span> <span class="hljs-number">0px</span> <span class="hljs-number">75px</span>;<br>&#125;<br><span class="hljs-comment">/*看着简洁明了，padding用作微调*/</span><br><span class="hljs-selector-class">.grid</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">980px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>padding，margin也可以用基于父元素的大小单位em。如果用px对小尺寸屏幕有可能引起排版错乱。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从政治意识形态分析西方疫情</title>
    <link href="/2020/04/01/%E4%BB%8E%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%E5%88%86%E6%9E%90%E8%A5%BF%E6%96%B9%E7%96%AB%E6%83%85/"/>
    <url>/2020/04/01/%E4%BB%8E%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%E5%88%86%E6%9E%90%E8%A5%BF%E6%96%B9%E7%96%AB%E6%83%85/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="为什么我们要认识意识形态"><a href="#为什么我们要认识意识形态" class="headerlink" title="为什么我们要认识意识形态"></a>为什么我们要认识意识形态</h2><p>马克思在《德意志意识形态》中认为</p><blockquote><p>意识形态是一种不平等的权力关系，是统治阶级为了欺骗和使权力关系具有合法性的产物，目的是为了让大家扭曲对于现实的认识，马克思也称其为上层建筑。通常是某些社会的道德价值观形塑了意识形态的基础。</p></blockquote><p>简言之，每个人从出生开始，被动的接受一些对世界的认识，受到背景文化的影响而认为这本就合理。如今西方世界因疫情吃瘪，各大社交媒体上很多人大肆讽刺西方所谓的”自由“”民主“。对方都认为自己的制度优良，默许制度的合理性，而实际上制度的好坏那么容易区分吗？但非要说清楚哪里不一样，绝大部分人恐怕无从下口。这就是没有独立思考导致的！难道真的是”自由“民主“不好?这个问题本不是一个非黑即白的问题，各个国家都在寻找一个优良的秩序让世界更美好，只是走的路不一样罢了。要深刻认识并理解我们处在何种秩序中，必须取西方所长，补自身所短，先从认识西方开始。</p><h2 id="什么是政治意识形态"><a href="#什么是政治意识形态" class="headerlink" title="什么是政治意识形态"></a>什么是政治意识形态</h2><p>意识形态分为多种，可以从政治，社会，伦理，价值等进行分类，本文叙述的是政治意识形态，简述为意识形态。</p><p>从概念上说，意识形态是现代社会科学体系的一个概念和范畴，意指“一个行动导向的信念体系，一套以某种方式指导和激励政治行动相互联系的思想观念。政治意识形态，通常包含几个重要特征：</p><ol><li>意识形态需要解释世界。</li><li>意识形态具有改造世界的企图心。</li><li>意识形态有群众取向的特点。很多理论非常高深，普通民众不太容易理解，成功的意识形态一定会简化到普通民众能理解的层次，甚至是几个口号，如：”自由“，”民主“。</li><li>意识形态和意识形态的实践往往是两回事。</li></ol><p><strong>据我的理解，意识形态是解释世界如何运行的观念和法则，并提供某种秩序的蓝图。</strong></p><h2 id="现代意识形态的背景"><a href="#现代意识形态的背景" class="headerlink" title="现代意识形态的背景"></a>现代意识形态的背景</h2><blockquote><p>工业革命到来之前，欧洲大部分人都生活在农村，城市人口大概不足10%或15%.随着工业革命的进展，人开始脱离士地，进入工厂涌入城市。当时英国和法国主要城市的人口由数万至十万这样的量级，快速膨胀到50万、甚至是100万以上。在这一过程中，人的社会身份也随之发生变化，有产者和无产者两大阶级集团开始形成。显然两个集团都有自己的意识形态，资产者需要资产者的意识形态，无产者需要无产者的意识形态。所以，工业革命带来的是欧洲阶级结构的巨大变迁，进而塑造出互相对立的意识形态。</p><p>大概到19世纪后期，工业革命的继续发展推动了中产阶级的兴起。特别是20世纪中叶以后，欧美社会逐步进入所谓的后工业社会，美国管理学家彼得·德鲁克把这种社会形态称为知识社会，把规模日益增大的非体力劳动者称为知识工作者。这样，整个20世纪，中产阶级在社会人口中的比例逐渐增加。到了20世纪后半叶，如果要用阶级结构去划分整个社会的话，过去那种上层阶级（有产者）和下层阶级（无产者）——两阶级对立的模式开始逐步弱化，一种新的社会阶级结构正在兴起。</p><p>埃里克·赖特的相关研究显示，今天欧美主要国家中，从事简单劳动的非技术工人阶层，总体上占整个社会就业人口的比例已经降至40%以下。在最发达的欧洲国家，能够被称为白领阶层或更高阶层的人口已经占到整个社会人口比例的60%以上。这样，到了20世纪后半叶，过去（19世纪）马克思所定义的两大阶级对立的社会结构在欧美社会基本上已经瓦解。</p><p>20世纪60年代，德国首相俾斯曼最早开始尝试社会保险制度让很多普通人的生活有了保障。</p></blockquote><p>高福利促成财富分配更加平均。由于多数社会阶层收入惊人的平均（参考发达国家的<a href="https://stats.oecd.org/Index.aspx?DataSetCode=IDD#">基尼系数</a>),缓和了各个阶层产生的矛盾。我其实很难想象电影《小鬼当家》1990年所描述的世界，那个时候的中国是真的一穷二白。</p><p>西方社会比我们想象中的要富有得多，这个富有不是指工资，而是指整个社会的财富和财富分配。这个社会财富具体指什么呢？指的社会保险，养老金之类的。值得一提的是这些社会财富不是放银行存利息了，而是放入股市，中西方都一样。这就会导致一个问题，经济下行或股市大波动都会导致太过依赖社会高福利的普通人受到重大影响甚至危及到生存问题，股市即生命。而这个周期性产生的经济萧条使人们怀疑自由的资本主义，经济萧条产生的原因有两种说法。一种是马克思所说的这是资本主义的本质决定的，除非放弃资本主义才能避免；另一种说法是由于美联储过度干扰自由经济而导致经济萧条。</p><h1 id="意识形态的重要分歧"><a href="#意识形态的重要分歧" class="headerlink" title="意识形态的重要分歧"></a>意识形态的重要分歧</h1><p>现代政治的意识形态主要分为三种：自由主义，保守主义，社会主义。保守主义和社会主义从批判自由主义中诞生，各自协同发展以适应社会潮流。不同的意识形态在一些重要议题上产生分歧。</p><h2 id="个人和群体的关系"><a href="#个人和群体的关系" class="headerlink" title="个人和群体的关系"></a>个人和群体的关系</h2><ol><li><p>集体主义</p><ul><li>集中力量办大事。</li><li>有强大的集体凝聚力，强调共同体生存，从宏观角度照顾多数人利益。</li><li>相应的制度和政策落实不到个人激励上，打击个人积极性和社会创造性。（参考人民公社化运动）</li><li>掌握集体控制手段的个人和集团拥有很大权力。</li></ul></li><li><p>个人主义</p><ul><li><p>能充分发挥个性和创造精神（参考马斯克的”星链计划“，私人企业航天技术媲美国家）</p></li><li><p>必然导致贫富差距的事实</p></li></ul></li></ol><p>从政治角度出发的个人主义并不是普罗大众理解的个人主义。</p><p>个人要优先于群体。这里的优先，并不是说只要个人不要群体，而是思考问题的一种特定视角。比如，对于一种政策，不要首先说这对整个社会有利，而要问是否改善或促进了个人福利。在个人主义看来，抽象的社会是看不见的，社会是由一个个不同的个人构成的。只有这种政策相当程度上能实现了个人福利时，社会福利才能得以实现。所以，个人主义主张个人优先于群体，既是一种认知问题的视角，又是在价值上倡导个人的优先性。</p><p>澳洲跑步女，隔离期间提出”我不喝开水，我要人权，我要喝矿泉水“，这些人提出的不合理要求不管是东方还是西方，都是一种价值扭曲，都不会被意识形态承认。因为个人主义要求的是价值上的优先，而不是无理要求。从理性分析，如果人人都提出这样的要求，不管从经济上还是社会上都是应该完全否定的。这已经和意识形态无关了，而不是所谓的”自由民主“。</p><h2 id="国家的角色和作用"><a href="#国家的角色和作用" class="headerlink" title="国家的角色和作用"></a>国家的角色和作用</h2><ol><li>国家的好处：提供公共秩序，基本安全，国防力量，公共基础设施。</li><li>国家的坏处：可能过度干预社会生活，官僚化腐败。</li></ol><p>这里产生的分歧是：对国家政府的信任，一种预设国家更多的干好事，一种预设国家更多的干坏事。</p><p>美剧《纸牌屋》把美国高层政治描述为很不堪的样子（我认为是写实的QAQ），它们的对政府很不信任，因此政治上极度强调权力制衡，这也导致了民主党和共和党的内斗消耗巨额的资源或做出令人匪夷所思的决断。大家都在说西方世界的政府普遍不作为，从背景分析，我们可以知道西方的高福利对应着高的社会保险金。而社会保险金在股市里，由于大部分普通民众依靠这笔养老金，股市一定要维稳，经济=生命。要在经济停摆和疫情扩散之间做一个选择题，受到国情限制是很难做出选择的。具体情况远没有这么简单，但西方世界希腊债务危机，法国黄马甲运动，英国脱欧这些重大事件全都是福利和经济之间的矛盾。政治影响经济，经济影响福利，福利降低引发社会问题，这里面一定有因果关系的。</p><p>不可否认的是我们对政府也不是完全信任，但是我们的价值观认同我们的国家。疫情开始一声令下，绝大部分人老老实实呆在家里，积极响应号召。各个地区强大的凝聚力是很令每一个人骄傲的。</p><h2 id="自由及其限度"><a href="#自由及其限度" class="headerlink" title="自由及其限度"></a>自由及其限度</h2><p>自由有两级，一级是自由至上主义，将国家限制在很小的权力范围内。一级是极权主义，将社会方方面面进行控制。如今的意识形态在两者之间。大卫休谟说过这样一段话：</p><blockquote><p>在所有政府内部始终存在权威与自由之间的斗争，有时候是公开的，有时是隐蔽的，两者之中从无一方在争斗中占据绝对上风。在每一个政府中自由都必须做出重大牺牲，而限制自由的权威，绝不能而且也不应该在任何的政治中，成为全面专制，不受控制。必须承认自由乃文明社会的尽善化，但仍然必须承认权威乃其生存之必需。</p></blockquote><h2 id="平等问题"><a href="#平等问题" class="headerlink" title="平等问题"></a>平等问题</h2><p>不同的意识形态对平等的看法差异很大。保守主义强调的是既有秩序和社会等级，所以保守主义并不热爱平等。自由主义强调的是自由优先，在自由主义框架中平等的价值显然要低于自由的价值。但与此同时，自由主义主张机会的平等和形式的平等，或者说是法律面前人人平等。当然，社会主义更多地主张结果的平等和实质的平等。所以，不同意识形态具有差异很大的平等观。</p><h1 id="现代主要的意识形态"><a href="#现代主要的意识形态" class="headerlink" title="现代主要的意识形态"></a>现代主要的意识形态</h1><table><thead><tr><th></th><th>自由主义</th><th>保守主义</th><th>社会主义</th></tr></thead><tbody><tr><td>主张</td><td>反对封建主义和封建制，绝对君主制和专制主义，反对重商主义</td><td>中世纪精神</td><td>共产主义</td></tr><tr><td>重要原则</td><td>个人主义 个人自由 理性原则 平等原则 宽容原则 被统治者同意原则 宪政原则 自由放任原则</td><td>捍卫传统 经验主义 人类不完善 社会作为有机体 重视等级秩序和权威 重视家庭 重视认同宗教 重视道德 尊重财产权</td><td>强调共同体 平等主义 博爱原则 阶级原则 财产的社会控制原则 满足需求原则</td></tr><tr><td>历程</td><td>古典自由主义-&gt;新古典自由主义</td><td>保守主义-&gt;新保守主义</td><td>理想国-&gt;空想社会主义-&gt;科学社会主义-&gt;改良社会主义</td></tr></tbody></table><p>古典自由主义向新古典自由主义转变的主要原因是经济危机，贫富悬殊，大企业垄断。（凯恩斯经济政策受到质疑）</p><p>保守主义向新保守主义转变的主要原因是社会福利包袱重，经济干预越陷越深，整个社会活力和创新精神下降。（撒切尔夫人改革与里根革命）根据我的观察，英国如今还是老样子。</p><p>我们每个人看待事物都有盲点，解决的方式最好就是多个角度看问题，这些角度不用自己想，都在书上。面对一件时事新闻，我很惊讶于某些异常新颖的观点，为什么我就想不到？政府给抗疫医护子女加分为什么不合理？医务人员的补贴被回收又该如何思考？西方如此黑我们该不该黑回去？又该采取何种方式？这些问题都是政治问题，政治看似离我们很远又离我们很近，当我们真正遇到问题时不能透过问题看本质，吃了亏也只能安慰”吃一堑长一智“。为了应对这样的情形，只有平时多加思考努力总结方能坐看云起时。</p>]]></content>
    
    
    <categories>
      
      <category>世界观</category>
      
    </categories>
    
    
    <tags>
      
      <tag>世界观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>魔鬼眼中的自然界</title>
    <link href="/2020/04/01/%E9%AD%94%E9%AC%BC%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%87%AA%E7%84%B6%E7%95%8C/"/>
    <url>/2020/04/01/%E9%AD%94%E9%AC%BC%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%87%AA%E7%84%B6%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="魔鬼眼中的自然界"><a href="#魔鬼眼中的自然界" class="headerlink" title="魔鬼眼中的自然界"></a>魔鬼眼中的自然界</h1><p>这篇文章是来自知乎专栏的读后感，<a href="https://zhuanlan.zhihu.com/p/28266445">原文链接</a>。</p><h1 id="不可预测的未来"><a href="#不可预测的未来" class="headerlink" title="不可预测的未来"></a>不可预测的未来</h1><p>从已知科学的角度上来说，基本微粒可以构成万事万物，不管是生物还是非生物，实体还是精神，都是由基本微粒构成的。这就说明是不是只要知道每一个基本微粒的存在状态，就能合成任何事物？是不是已知一个基本微粒的状态，就必然可以预测它未来的所有状态，而不带一点不确定性？但实际上存在三个问题：</p><ol><li>已知夸克是最小的基本微粒，但夸克是否可分？分了之后是否还可分？这目前无法得到肯定答案。</li><li>事物普遍都不是独立存在的，受到环境的影响。因此在理论上是不可能得到基本微粒的运动轨迹，只能无限趋近。</li><li>若已知的基本微粒构成事物，当微粒数量增加的时候会出现某些在小尺度上不存在的特征。</li></ol><p>由此可知，当且仅当在孤立系统中才会存在确定性，但现实中并不存在孤立系统，只能通过逼近的方式进行描述。数学采用抽象的概念构造模型，而模型是物理中对现实生活的抽象，以此构建定律来描述现实世界。事物运行本身有无规律，和事物的规律我们没法描述，只能管中窥豹对于我们来说并无区别，可以断定的是目前人类绝无可能达到全知全能境界。</p><p>随着需要对现实世界的描述越来越精确，科学上不可避免地要用概率来描述这个世界。而概率反映的，不是运动的不确定，而是我们对运动的无知。如果你随手丢硬币，其正反面出现是随机的。但硬币是可预测的，而且是可以在一定程度上做到随心所欲控制哪一面朝上的。现实中我们无法事先猜测结果，不是因为它的未来不确定，而是相反，它的未来仍然是确定的，但是第一，我们对抛硬币预测不够准；第二，我们对抛出硬币的初始状态控制不够准。这是一个有着注定命运的硬币，因为我们的不够精确，所以它看似是随机的。随机之所以是随机，是因为人们对它认知的缺失，而不是它“本身”不确定。– 我们虽然对未来无知，但是未来就在那里，只是我们看不到而已。世间的一切，莫不如此。</p><p>根据上述讨论，世界本身是人类不可琢磨透的，但是是可琢磨，可深入的。我们不知道世界是怎么构建的，唯有利用数学这样的工具构造不断拟合世界的模型。事实证明随着拟合的精度不断提高，对现实生活的指导意义也越强。从时间层面上来看，预言的时间越长越具体，误差就越大，需要的前提的精度也越高。目前来说，不可预测未来，但可创造未来。如今通过利用数学中适用于现实精度的规则，创造了现代文明。</p><h1 id="数学是什么"><a href="#数学是什么" class="headerlink" title="数学是什么"></a>数学是什么</h1><blockquote><p>In mathematics you don’t understand things, you just get used to them.”<br>“在数学中，你不是去理解它们，而只是去习惯它们而已”<br>–约翰·冯·诺伊曼:–回复一个物理学家朋友，他说“我担心我不理解特征线法。”</p></blockquote><p>我对此的理解是数学本身就是物理世界的抽象，以此构建的抽象世界只是一个规则的世界，遵循规则做事即可。如果非要去理解为什么要有这么一条规则，和问为什么世界上有石头没什么区别。为了理解这一句话，我看到有很多对我触动的话。</p><blockquote><ul><li>数学是通过理性建立起来的纯粹世界。-威廉·华兹华斯</li><li>数学是科学的皇后，数论是数学的皇后。-高斯</li><li>数学是替不同的东西取相同名字的艺术。-庞加莱</li><li>数学是透过在纸上的无意义的记号，建立简单法则的游戏。-希尔伯特</li><li>做数学的艺术在于找到一个特例，其中隐含了所有推广的胚芽。-希尔伯特</li><li>如果人们不相信数学简单，那是因为他们不知道真实世界有多复杂。-约翰·冯·诺伊曼</li><li>“对这个真实世界而言，纯数学只是个抽象的存在。纯数学在处理该领域中专门与技术上的主题时，具有特别</li><li>精确的语言，但是这种精确的语言在你处理现实世界的真实物体时，并没有任何精确的意义。除非纯数学中的某些特殊的细微之处能够仔细的凸显出来，否则只能用来炫耀卖弄，而且还会引发混淆。”-费曼</li></ul></blockquote><p>数学是从现实生活中创建的一个自洽的简化的世界，用精炼，优美的语言描述着世界。规则本身是不可理解的，但规则来源于现实世界。因此，你并不需要去“理解”它，而只需要去“习惯”它。那么数学是怎么来的呢？</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/%E9%AD%94%E9%AC%BC%E7%9C%BC%E4%B8%AD%E7%9A%84%E7%9A%84%E8%87%AA%E7%84%B6%E7%95%8C_1.png"></p><p>为了尽可能的精确描述这个世界，最好是定量描述，通过创建数学模型的方式用种种数字或数字的特定结构来表示一些物理现实，用数学运算和变换过程来表示事物的物理变化，求解过程便是事物的演化过程。其物理现实的抽象可以是数，可以是数字的特定结构如几何图形，数形是不分家的。数字本身可以抽象质量，大小，位置，速度，甚至状态，数字的变化就是状态的变化。</p><blockquote><p>图形与物理现实的数学模型存在一一对应的关系，而数学模型与图形也存在一一对应的关系。如果是一一对应，那么我们就可以从图形的变化反映出（“映射”）出数字的变化，而从数字的变化反映出实际系统的变化。这种一一对应关系，在数学上叫做“互射”，而由互射联系的两种结构，叫做“同构”。</p></blockquote><p>数学对现实的描述类似于照哈哈镜一样，虽然看起来不同，但是包含了你真实样子的所有信息。而镜子相当于是描述你样子的空间，凸面镜换凹面镜就是空间变换。当找到一个平面镜就是找到了一个和现实无限逼近的空间。这其中有一个很重要的概念是一一对应，这告诉我们不同空间的物体信息是守恒的。一一对应这种性质，在数学的一个分支，拓扑数学中是一个非常重要的概念。它可以描述那些虽然表面上形状变化很大，但是实际上它们“基本上”的形状却是一模一样的。</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/%E9%AD%94%E9%AC%BC%E7%9C%BC%E4%B8%AD%E7%9A%84%E8%87%AA%E7%84%B6%E7%95%8C_2.png"></p><h1 id="世界是个毛线球"><a href="#世界是个毛线球" class="headerlink" title="世界是个毛线球"></a>世界是个毛线球</h1><blockquote><p>“In theory, theory and practice are the same. In practice, they are not”<br>“理论上，理论和现实是一回事。现实中，它们不是”<br>– 爱因斯坦</p></blockquote><blockquote><p>引用费曼物理学讲义里的一段话：<strong>“……给定任一精确度，无论它精确到怎样的程度，我们都能找到一个足够长的时间，以致无法对这么长的时间作出有效预言。其实要点在于这段时间并不长。如果精度为十亿分之一，这个时间并不是数百万年。事实上，这个时间随着误差呈对数式增长。结果发现只是在很短很短（tiny tiny）的时间里我们就失去所有信息。如果精确度提高到十亿乘以十亿再乘以十亿分之一 – 那么不管我们说多少个十亿，只要最后不再说下去 – .我们总能找到一个时间，过此时间后再也不能预言会发生什么了！因此，诸如以下的说法……说什么量子力学将我们从绝对机械论的宇宙下拯救出来是不公正的，因为从实际的观点来说，在经典力学中早已存在着不确定性了”</strong></p></blockquote><p>我们都知道蝴蝶效应，一方面世界并不是一个孤立的系统，另一方面预言对初始条件有极端敏感性，没办法保证初始条件完全相同。因此，在我们看起来能接受的误差范围内给定同样的初始条件会得到完全不同的结果，甚至保证了初始条件完全相同，也会存在观察者效应。如果脱离了观察，实际上一切都变得毫无意义了。这实际上也陷入了罗素悖论（也叫理发师悖论）。在我们的观察、认知、思考、研究过程中，我们只能去对付那些我们意识中存在的东西。</p><blockquote><p>观测者效应（Observer effect），是指“观测”这种行为对被观测对象造成一定影响的效应。<br>在量子力学实验中，如果要测算一个电子所处的速度，就要用两个光子隔一段时间去撞击这个电子，但第一个光子就已经把这个电子撞飞了，便改变了电子的原有速度，我们便无法测出真正准确的速度（不确定原理）。时间流逝的快慢也会受到观测者的影响，用很高的频率去观测粒子的衰变，反而使得粒子长时间不衰变[2]。<br>这种效应在生活中极其常见。有人称：“‘螳螂吃夫’是众人皆知的常见生物现象。但后来却有学者发现自然界中其实并不存在这一现象，雌螳螂之所以吃掉雄螳螂，是因为观察者在场引起了它的紧张，误把自己的丈夫当成了敌人”云云，然而，此种说法是否正确尚有疑问。</p></blockquote><p>总之，世界是混沌的，目前来说没办法预测，犹如一个毛线球，但可以借助数学这一工具对世界进行描述。但由于人类自身的认知局限性会导致悖论的出现，精确预言一件事物只是痴心妄想。值得庆幸的是，在宏观的角度上，有物理定律对世界有比较好的拟合，以此对世界有了更好的认识。我印象比较深刻的就是电路中阻抗的定义，将物理世界的不确定性限定在一个范围，构建了确定的计算机这种东西。由于材料本身的限制，才会导致计算机的突破瓶颈。计算机是人类世界利用数学和逻辑创造出来的伟大发明，不确定中创造确定，真的让人震撼。</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><ol><li>预言未来是愚蠢的，反观历史的理由是避免踩坑，以史为鉴可以知兴替，不是为了预测未来。因此，加杠杆买股票买彩票投机也是愚蠢的。</li><li>数学本身是对世界规则的抽象，平常人并不需要学习数学，而应该学习应用数学。学习数学原理和逻辑学本身并不能教会你如何应用，菜鸡也推动不了数学发展。因此，在熟悉数学规则(大量刷题）后尽快应用才能提高解决现实问题的能力。</li><li>数学是解决问题的工具，计算机是加快解决问题的效率工具。数据结构与算法是数学在计算机领域的具体实践。</li></ol>]]></content>
    
    
    <categories>
      
      <category>世界观</category>
      
    </categories>
    
    
    <tags>
      
      <tag>世界观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哲学，科学与宗教</title>
    <link href="/2020/03/13/%E5%93%B2%E5%AD%A6%EF%BC%8C%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%AE%97%E6%95%99/"/>
    <url>/2020/03/13/%E5%93%B2%E5%AD%A6%EF%BC%8C%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%AE%97%E6%95%99/</url>
    
    <content type="html"><![CDATA[<p>2000多年前，人们想要探究世界的本源，中西方以两种不同的根基建立对世界的解释。东方哲学立意于道，西方哲学立意于理。<br>前者要求人们有一定的悟性，有一种玄妙的奇点，有人能理解，也有人终其一生也不能理解，是基于内心感受的一种体系，一种感性的认知。由于我并没有系统化了解中国哲学史，只能粗浅的表达这种博大精深的文化。<br>后者试图建立一种感性与理性结合的形式。利用全知全能的形象承认客观存在，有了存在才能用理性建立理论体系。后又摈弃了世界本源这样的形而上学，从认识论的角度出发，转向理性主义和经验主义。理性主义强调只有通过严密的逻辑推理才能承认事实，如数学，逻辑学，理论计算机科学这样高度抽象的学科才是对世界的描述。经验主义认为通过对现实的归纳更能体现事物的属性，如虫鱼鸟兽，草木之花能按照呈现出来的形象来认识，知更鸟和杜鹃鸟一定是不一样的。于是从波普尔提出可证伪的对科学的定义，结合了理性主义和经验主义发展了科学，而后诞生于哲学的科学脱离了哲学范畴而自成一体。科学给我们的是一套针对客观实在的工具，恰如斧头刨子，想做出什么样的作品取决于自己的意识，而不是工具。当然还有其它工具，事实证明还是科学好用。</p><p>因此，我认为中西方的文化差异不在于科学和道的差异，而在于古希腊奠定的以柏拉图为核心的$柏拉图主义^1$和以$《周易》^2$为开端的一系列道。这样的东西我统称为哲学。</p><p>那这就不得不谈谈宗教和哲学的关系。<br>从历史角度看，先有哲学后有宗教。从联系上来看，宗教诞生于哲学。但对东西方宗教我发现有一些共同点，如：宗教往往伴随着政治。西方基督教成为罗马统治的工具，东方儒家成为汉王朝统治的工具。这些宗教是对哲学的改造，宗教已经脱离了哲学目的，而借助哲学驶向另一个终点，目的不再单纯。将哲学与宗教混为一谈这是绝大部分人的误解，这也是我不承认宗教最主要的原因。因此，我认为在没有鉴别力之前应该去没有被宗教改造过的典籍中寻求信仰力量。<br>宗教还有一个重要的特征是能覆盖极大的受众群体，即使像文盲这样没有任何文化修养的人也可利用艺术形式传达教义。西方的基督大教堂金碧辉煌，庄严肃穆。东方佛祖巨身环绕着十大门徒，梵音绕梁，殿外吠舍镇压一切虚妄。这样的震撼无一不为了传教。这样的阵仗绝不是柏拉图，老子这些大思想家所推崇的。<br>哲学和宗教只有一墙之隔，宗教因传教而广泛被世人认知，思考哲学的人绝不会建立组织传教，更多的是自我感悟。我觉得下面这个故事很有意思。</p><blockquote><p>一个人走过海旁，看见另一个人想跳海自杀。<br>他走上前去劝说「先生，不要跳下去！」<br>那人问道：「为什么？」<br>他说：「生命是美好的嘛！你是无神论者还是有宗教信仰？」<br>那人答：「我有宗教信仰。」<br>「佛教、道教、回教还是基督教？」<br>「基督教」<br>「罗马天主教还是新教？」<br>「新教」<br>「我也是新教呢！圣公会还是浸信会？」<br>「浸信会」<br>「太好啦！我也是浸信会，你是Baptist Church of God还是Baptist church of the Lord? 」<br>「Baptist Church of God. 」<br>「真是太奇妙啦！我也是，那你是原教旨的Baptist Church of God还是改革派的？」<br>「改革派的」<br>「1879年的改革派还是1915年的？」<br>「1915年的改革派。」</p><p>那人朝他屁股一脚把他踢进海里：「异端！去死吧！」</p></blockquote><p>得益于晓萌姐姐的点拨，我曾试图在科学中寻找生活的真谛，这显然是头铁。我曾读完西方哲学史，没有明悟这一点显然无意识相信了理性主义的科学权威。从境界上来说，中国的道更是对生活的高度升华，这对生活这样的非理性主义能解释的东西显然道更能提供指导意义。</p><p>但我不认同晓萌姐姐的另一个观点——宗教哲学科学殊途同归。原因在于宗教和科学是工具（至少科学是毫无争议的工具），世人都明白是双刃剑，但哲学很少有人认为是双刃剑，因为哲学是一种个人的思考活动，哲学这个概念更倾向于个人思考而不是某一流派。宗教从自立门派那一刻开始，就多多少少失去了兼容并包的客观性。那些优秀的宗教思想固然存在，但有组织形式使得这样一个针对个人修身养性变得不再单纯，至少对某些利益集团是这样的。</p><p>总结一下，科学脱离于哲学，宗教是哲学的畸形延伸，哲学本身才是个人对生活的思考。宗教混杂着精华与糟粕可能正因如此。</p><p><img src="%E5%93%B2%E5%AD%A6%EF%BC%8C%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%AE%97%E6%95%99%5C%E5%93%B2%E5%AD%A6%E7%A7%91%E5%AD%A6%E5%AE%97%E6%95%99.png" alt="image-20200313110806130"></p><p>注：</p><ol><li>苏格拉底是柏拉图的老师，一说柏拉图的主要思想来自苏格拉底而奉其为西方哲学的鼻祖，但有文字记载仅仅来自柏拉图，因此后世称之为柏拉图主义。</li><li>中国哲学是否是严格意义上的哲学存在争议，但我认为是哲学，其开端是先秦文学，后被孕育在中华文化中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>世界观</category>
      
    </categories>
    
    
    <tags>
      
      <tag>世界观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像处理入门</title>
    <link href="/2020/03/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/"/>
    <url>/2020/03/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="图像处理入门"><a href="#图像处理入门" class="headerlink" title="图像处理入门"></a>图像处理入门</h1><h2 id="图像数据读取展示"><a href="#图像数据读取展示" class="headerlink" title="图像数据读取展示"></a>图像数据读取展示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2 <span class="hljs-comment">#opencv读取的格式是BGR</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br>%matplotlib inline <br><br>img=cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cv_show</span>(<span class="hljs-params">name,img</span>):</span><br>    cv2.imshow(name,img) <br>    cv2.waitKey(<span class="hljs-number">0</span>)       <span class="hljs-comment">#任意键退出</span><br>    cv2.destroyAllWindows()<br><br><span class="hljs-comment">#保存</span><br>cv2.imwrite(<span class="hljs-string">&#x27;mycat.png&#x27;</span>,img)<br>    <br></code></pre></td></tr></table></figure><h2 id="视频读取与展示"><a href="#视频读取与展示" class="headerlink" title="视频读取与展示"></a>视频读取与展示</h2><ul><li>cv2.VideoCapture可以捕获摄像头，用数字来控制不同的设备，例如0,1。</li><li>如果是视频文件，直接指定好路径即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">video = cv2.VideoCapture(<span class="hljs-string">&#x27;test.mp4&#x27;</span>)<br><span class="hljs-keyword">while</span> video.isOpened():<br>    ret, frame = video.read()<br>    <span class="hljs-keyword">if</span> frame <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> ret == <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 将每一帧转化成灰度图</span><br>        gray = cv2.cvtColor(frame,  cv2.COLOR_BGR2GRAY)<br>        cv2.imshow(<span class="hljs-string">&#x27;result&#x27;</span>, gray)<br>       <span class="hljs-comment">#每一帧等待100ms或者按退出键退出</span><br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">100</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-number">27</span>:<br>            <span class="hljs-keyword">break</span><br>video.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h2 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h2><h3 id="截取图像部分数据"><a href="#截取图像部分数据" class="headerlink" title="截取图像部分数据"></a>截取图像部分数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#截取图像[纵，横]</span><br>img=cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>)<br>cat=img[<span class="hljs-number">0</span>:<span class="hljs-number">50</span>,<span class="hljs-number">0</span>:<span class="hljs-number">200</span>] <br>cv_show(<span class="hljs-string">&#x27;cat&#x27;</span>,cat)<br></code></pre></td></tr></table></figure><h3 id="颜色通道提取"><a href="#颜色通道提取" class="headerlink" title="颜色通道提取"></a>颜色通道提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将img的颜色提取出来形成一个数组</span><br>b,g,r=cv2.split(img)<br><span class="hljs-comment"># 将三个颜色通道合成图像</span><br>img=cv2.merge((b,g,r))<br></code></pre></td></tr></table></figure><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><ul><li>BORDER_REPLICATE：复制法，也就是复制最边缘像素。</li><li>BORDER_REFLECT：反射法，对感兴趣的图像中的像素在两边进行复制</li><li>BORDER_REFLECT_101：反射法，也就是以最边缘像素为轴，对称，gfedcb|abcdefgh|gfedcba</li><li>BORDER_WRAP：外包装法</li><li>BORDER_CONSTANT：常量法，常数值填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">top_size,bottom_size,left_size,right_size = (<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>)<br>replicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Creplicate.png" alt="1565682071522"></p><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Creflect.png" alt="1565682166355"></p><h3 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h3><p>作用于各个像素的颜色通道</p><h3 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h3><p>只能同样大小的图片才能融合，按透明度权重拼成一张图片<img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Cres.png" alt="1565683031832"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img_dog = cv2.resize(img_dog, (<span class="hljs-number">500</span>, <span class="hljs-number">414</span>))<br>res = cv2.addWeighted(img_cat, <span class="hljs-number">0.4</span>, img_dog, <span class="hljs-number">0.6</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">#按倍数更改大小</span><br>res = cv2.resize(img, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), fx=<span class="hljs-number">4</span>, fy=<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h1 id="图像基本处理"><a href="#图像基本处理" class="headerlink" title="图像基本处理"></a>图像基本处理</h1><h2 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)<br><br>img_gray.shape<br></code></pre></td></tr></table></figure><h2 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h2><ul><li>H - 色调（主波长）。</li><li>S - 饱和度（纯度/颜色的阴影）。</li><li>V值（强度）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hsv=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)<br></code></pre></td></tr></table></figure><h2 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h2><h4 id="ret-dst-cv2-threshold-src-thresh-maxval-type"><a href="#ret-dst-cv2-threshold-src-thresh-maxval-type" class="headerlink" title="ret, dst = cv2.threshold(src, thresh, maxval, type)"></a>ret, dst = cv2.threshold(src, thresh, maxval, type)</h4><ul><li>src： 输入图，只能输入单通道图像，通常来说为灰度图</li><li>dst： 输出图</li><li>thresh： 阈值</li><li>maxval： 当像素值超过了阈值（或者小于阈值，根据type来决定），所赋予的值</li><li>type：二值化操作的类型，包含以下5种类型： cv2.THRESH_BINARY； cv2.THRESH_BINARY_INV； cv2.THRESH_TRUNC； cv2.THRESH_TOZERO；cv2.THRESH_TOZERO_INV</li><li>cv2.THRESH_BINARY 超过阈值部分取maxval（最大值），否则取0</li><li>cv2.THRESH_BINARY_INV THRESH_BINARY的反转</li><li>cv2.THRESH_TRUNC 大于阈值部分设为阈值，否则不变</li><li>cv2.THRESH_TOZERO 大于阈值部分不改变，否则设为0</li><li>cv2.THRESH_TOZERO_INV THRESH_TOZERO的反转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">ret, thresh1 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>ret, thresh2 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)<br>ret, thresh3 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TRUNC)<br>ret, thresh4 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO)<br>ret, thresh5 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO_INV)<br><br>titles = [<span class="hljs-string">&#x27;Original Image&#x27;</span>, <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-string">&#x27;BINARY_INV&#x27;</span>, <span class="hljs-string">&#x27;TRUNC&#x27;</span>, <span class="hljs-string">&#x27;TOZERO&#x27;</span>, <span class="hljs-string">&#x27;TOZERO_INV&#x27;</span>]<br>images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>), plt.imshow(images[i], <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(titles[i])<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Cthresh.png" alt="1565683500580"></p><h2 id="图像平滑"><a href="#图像平滑" class="headerlink" title="图像平滑"></a>图像平滑</h2><p>用一个3*3的核来处理图像,res = np.hstack((dilate_1,dilate_2,dilate_3))用来将图像相减表现变化趋势</p><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">blur</span> = cv<span class="hljs-number">2</span>.blur(img, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">box</span> = cv<span class="hljs-number">2</span>.boxFilter(img,-<span class="hljs-number">1</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), normalize=True)  <br></code></pre></td></tr></table></figure><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">aussian</span> = cv<span class="hljs-number">2</span>.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">1</span>)  <br></code></pre></td></tr></table></figure><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">median</span> = cv<span class="hljs-number">2</span>.medianBlur(img, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h2 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h2><h3 id="腐蚀操作"><a href="#腐蚀操作" class="headerlink" title="腐蚀操作"></a>腐蚀操作</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kernel</span> = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),np.uint<span class="hljs-number">8</span>) <br><span class="hljs-attribute">erosion</span> = cv<span class="hljs-number">2</span>.erode(img,kernel,iterations = <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="膨胀操作"><a href="#膨胀操作" class="headerlink" title="膨胀操作"></a>膨胀操作</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kernel</span> = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),np.uint<span class="hljs-number">8</span>) <br><span class="hljs-attribute">dige_dilate</span> = cv<span class="hljs-number">2</span>.dilate(img,kernel,iterations = <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="开运算与闭运算"><a href="#开运算与闭运算" class="headerlink" title="开运算与闭运算"></a>开运算与闭运算</h3><ul><li>开：先腐蚀，再膨胀</li><li>闭：先膨胀，再腐蚀</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kernel</span> = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.uint<span class="hljs-number">8</span>) <br><span class="hljs-attribute">opening</span> = cv<span class="hljs-number">2</span>.morphologyEx(img, cv<span class="hljs-number">2</span>.MORPH_OPEN, kernel)<br><br><span class="hljs-attribute">kernel</span> = np.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),np.uint<span class="hljs-number">8</span>) <br><span class="hljs-attribute">closing</span> = cv<span class="hljs-number">2</span>.morphologyEx(img, cv<span class="hljs-number">2</span>.MORPH_CLOSE, kernel)<br></code></pre></td></tr></table></figure><h3 id="梯度运算"><a href="#梯度运算" class="headerlink" title="梯度运算"></a>梯度运算</h3><p>先膨胀，再腐蚀，二者相减得梯度</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dilate</span> = cv2.dilate(pie,kernel,iterations = <span class="hljs-number">5</span>)<br><span class="hljs-attr">erosion</span> = cv2.erode(pie,kernel,iterations = <span class="hljs-number">5</span>)<br><span class="hljs-attr">res</span> = np.hstack((dilate,erosion))<br><br><span class="hljs-attr">gradient</span> = cv2.morphologyEx(pie, cv2.MORPH_GRADIENT, kernel)<br></code></pre></td></tr></table></figure><h3 id="顶帽与黑帽"><a href="#顶帽与黑帽" class="headerlink" title="顶帽与黑帽"></a>顶帽与黑帽</h3><ul><li>顶帽 = 原始输入-开运算结果</li><li>黑帽 = 闭运算-原始输入</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">tophat = cv2.morphology<span class="hljs-constructor">Ex(<span class="hljs-params">img</span>, <span class="hljs-params">cv2</span>.MORPH_TOPHAT, <span class="hljs-params">kernel</span>)</span><br>blackhat  = cv2.morphology<span class="hljs-constructor">Ex(<span class="hljs-params">img</span>,<span class="hljs-params">cv2</span>.MORPH_BLACKHAT, <span class="hljs-params">kernel</span>)</span><br></code></pre></td></tr></table></figure><h3 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h3><p>算子也是用来算梯度的</p><ul><li><p>sobel算子</p><p>dst = cv2.Sobel(src, ddepth, dx, dy, ksize)</p><ul><li>ddepth:图像的深度</li><li>dx和dy分别表示水平和竖直方向</li><li>ksize是Sobel算子的大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#先读取为灰度图</span><br>img = cv2.imread(<span class="hljs-string">&#x27;pie.png&#x27;</span>,cv2.IMREAD_GRAYSCALE)<br><span class="hljs-comment">#分别计算x和y方向的梯度再求和</span><br>sobelx = cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,ksize=<span class="hljs-number">3</span>)<br>sobelx = cv2.convertScaleAbs(sobelx)<br>cv_show(sobelx,<span class="hljs-string">&#x27;sobelx&#x27;</span>)<br><br>sobely = cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,ksize=<span class="hljs-number">3</span>)<br>sobely = cv2.convertScaleAbs(sobely)  <br>cv_show(sobely,<span class="hljs-string">&#x27;sobely&#x27;</span>)<br><br>sobelxy = cv2.addWeighted(sobelx,<span class="hljs-number">0.5</span>,sobely,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>)<br>cv_show(sobelxy,<span class="hljs-string">&#x27;sobelxy&#x27;</span>)<br><br><span class="hljs-comment">#不建议同时求x和y方向的梯度，处理得没分别处理的好</span><br>sobelxy=cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,ksize=<span class="hljs-number">3</span>)<br>sobelxy = cv2.convertScaleAbs(sobelxy) <br>cv_show(sobelxy,<span class="hljs-string">&#x27;sobelxy&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>scharr算子</p></li><li><p>laplacian算子</p></li><li><p>不同算子的差异</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#不同算子的差异</span><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>,cv2.IMREAD_GRAYSCALE)<br>sobelx = cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,ksize=<span class="hljs-number">3</span>)<br>sobely = cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,ksize=<span class="hljs-number">3</span>)<br>sobelx = cv2.convertScaleAbs(sobelx)   <br>sobely = cv2.convertScaleAbs(sobely)  <br>sobelxy =  cv2.addWeighted(sobelx,<span class="hljs-number">0.5</span>,sobely,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>)  <br><br>scharrx = cv2.Scharr(img,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>scharry = cv2.Scharr(img,cv2.CV_64F,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>scharrx = cv2.convertScaleAbs(scharrx)   <br>scharry = cv2.convertScaleAbs(scharry)  <br>scharrxy =  cv2.addWeighted(scharrx,<span class="hljs-number">0.5</span>,scharry,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>) <br><br>laplacian = cv2.Laplacian(img,cv2.CV_64F)<br>laplacian = cv2.convertScaleAbs(laplacian)   <br><br>res = np.hstack((sobelxy,scharrxy,laplacian))<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><ul><li><ol><li>使用高斯滤波器，以平滑图像，滤除噪声。</li></ol></li><li><ol start="2"><li>计算图像中每个像素点的梯度强度和方向。</li></ol></li><li><ol start="3"><li>应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</li></ol></li><li><ol start="4"><li>应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。</li></ol></li><li><ol start="5"><li>通过抑制孤立的弱边缘最终完成边缘检测。</li></ol></li></ul><p>高斯滤波器</p><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Ccanny_1.png" alt="canny_1"></p><p>计算梯度和方向</p><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Ccanny_2.png" alt="canny_2"></p><p>非极大值抑制</p><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Ccanny_3.png" alt="canny_3"></p><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Ccanny_6.png" alt="canny_6"></p><p>双阈值检测</p><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Ccanny_5.png" alt="canny_5"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">img=cv2.imread(<span class="hljs-string">&quot;lena.jpg&quot;</span>,cv2.IMREAD_GRAYSCALE)<br><br>v1=cv2.Canny(img,<span class="hljs-number">80</span>,<span class="hljs-number">150</span>)<br>v2=cv2.Canny(img,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>)<br><br>res = np.hstack((v1,v2))<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h3><p>向下采样方法</p><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5CPyramid_2.png" alt="Pyramid_2"></p><p>向上采样方法</p><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5CPyramid_3.png" alt="Pyramid_3"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">up=cv2.pyr<span class="hljs-constructor">Up(<span class="hljs-params">img</span>)</span><br>cv<span class="hljs-constructor">_show(<span class="hljs-params">up</span>,&#x27;<span class="hljs-params">up</span>&#x27;)</span><br>down=cv2.pyr<span class="hljs-constructor">Down(<span class="hljs-params">img</span>)</span><br>cv<span class="hljs-constructor">_show(<span class="hljs-params">down</span>,&#x27;<span class="hljs-params">down</span>&#x27;)</span><br></code></pre></td></tr></table></figure><h3 id="图像轮廓"><a href="#图像轮廓" class="headerlink" title="图像轮廓"></a>图像轮廓</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">findContours(image, mode, <span class="hljs-function"><span class="hljs-keyword">method</span>[, <span class="hljs-title">contours</span>[, <span class="hljs-title">hierarchy</span>[, <span class="hljs-title">offset</span>]]]) -&gt; <span class="hljs-title">contours</span>, <span class="hljs-title">hierarchy</span></span><br></code></pre></td></tr></table></figure><p>mode:轮廓检索模式</p><ul><li>RETR_EXTERNAL ：只检索最外面的轮廓；</li><li>RETR_LIST：检索所有的轮廓，并将其保存到一条链表当中；</li><li>RETR_CCOMP：检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界;</li><li>RETR_TREE：检索所有的轮廓，并重构嵌套轮廓的整个层次;</li></ul><p>method:轮廓逼近方法</p><ul><li>CHAIN_APPROX_NONE：以Freeman链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列）。</li><li>CHAIN_APPROX_SIMPLE:压缩水平的、垂直的和斜的部分，也就是，函数只保留他们的终点部分</li></ul><p>为了更高的准确率，使用二值图像。</p><p>绘制轮廓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;contours.png&#x27;</span>)<br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>cv_show(thresh,<span class="hljs-string">&#x27;thresh&#x27;</span>)<br><br>contours,hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br><br><span class="hljs-comment">#传入绘制图像，轮廓，轮廓索引，颜色模式，线条厚度</span><br><span class="hljs-comment"># 注意需要copy,要不原图会变。。。</span><br>draw_img = img.copy()<br>res = cv2.drawContours(draw_img, contours, -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Ccontours.png" alt="1565696283439"></p><p>这轮廓用来找物体应该易于和环境分开才行</p><p>轮廓特征(对于那种形不成必和轮廓的没有效果)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">cnt = contours[<span class="hljs-number">0</span>]<br><span class="hljs-comment">#面积</span><br>cv2.contourArea(cnt)<br><span class="hljs-comment">#周长，True表示闭合的</span><br>cv2.arcLength(cnt,<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>轮廓近似</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">approx<span class="hljs-constructor">PolyDP(<span class="hljs-params">curve</span>, <span class="hljs-params">epsilon</span>, <span class="hljs-params">closed</span>[, <span class="hljs-params">approxCurve</span>])</span> -&gt; approxCurve<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;contours2.png&#x27;</span>)<br><br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br>cnt = contours[<span class="hljs-number">0</span>]<br><br>draw_img = img.copy()<br>res = cv2.drawContours(draw_img, [cnt], -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br><br>epsilon = <span class="hljs-number">0.15</span>*cv2.arcLength(cnt,<span class="hljs-literal">True</span>) <br>approx = cv2.approxPolyDP(cnt,epsilon,<span class="hljs-literal">True</span>)<br><br>draw_img = img.copy()<br>res = cv2.drawContours(draw_img, [approx], -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure><p>边界矩形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;contours.png&#x27;</span>)<br><br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br>cnt = contours[<span class="hljs-number">0</span>]<br><br>x,y,w,h = cv2.boundingRect(cnt)<br>img = cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)<br>cv_show(img,<span class="hljs-string">&#x27;img&#x27;</span>)<br><br>area = cv2.contourArea(cnt)<br>x, y, w, h = cv2.boundingRect(cnt)<br>rect_area = w * h<br>extent = <span class="hljs-built_in">float</span>(area) / rect_area<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;轮廓面积与边界矩形比&#x27;</span>,extent)<br></code></pre></td></tr></table></figure><p>外接圆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(x,y),radius = cv2.minEnclosingCircle(cnt) <br>center = (<span class="hljs-built_in">int</span>(x),<span class="hljs-built_in">int</span>(y)) <br>radius = <span class="hljs-built_in">int</span>(radius) <br>img = cv2.circle(img,center,radius,(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)<br>cv_show(img,<span class="hljs-string">&#x27;img&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>作用：</p><ul><li>高频：变化剧烈的灰度分量，例如边界</li><li>低频：变化缓慢的灰度分量，例如一片大海</li><li>低通滤波器：只保留低频，会使得图像模糊</li><li>高通滤波器：只保留高频，会使得图像细节增强</li></ul><p>运用：</p><ul><li>opencv中主要就是cv2.dft()和cv2.idft()，输入图像需要先转换成np.float32 格式。</li><li>得到的结果中频率为0的部分会在左上角，通常要转换到中心位置，可以通过shift变换来实现。</li><li>cv2.dft()返回的结果是双通道的（实部，虚部），通常还需要转换成图像格式才能展示（0,255）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>,<span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br>dft = cv2.dft(img_float32, flags = cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><span class="hljs-comment"># 得到灰度图能表示的形式</span><br>magnitude_spectrum = <span class="hljs-number">20</span>*np.log(cv2.magnitude(dft_shift[:,:,<span class="hljs-number">0</span>],dft_shift[:,:,<span class="hljs-number">1</span>]))<br><br>plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>),plt.imshow(magnitude_spectrum, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>,<span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br>dft = cv2.dft(img_float32, flags = cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><br>rows, cols = img.shape<br>crow, ccol = <span class="hljs-built_in">int</span>(rows/<span class="hljs-number">2</span>) , <span class="hljs-built_in">int</span>(cols/<span class="hljs-number">2</span>)     <span class="hljs-comment"># 中心位置</span><br><br><span class="hljs-comment"># 低通滤波</span><br>mask = np.zeros((rows, cols, <span class="hljs-number">2</span>), np.uint8)<br>mask[crow-<span class="hljs-number">30</span>:crow+<span class="hljs-number">30</span>, ccol-<span class="hljs-number">30</span>:ccol+<span class="hljs-number">30</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># IDFT</span><br>fshift = dft_shift*mask<br>f_ishift = np.fft.ifftshift(fshift)<br>img_back = cv2.idft(f_ishift)<br>img_back = cv2.magnitude(img_back[:,:,<span class="hljs-number">0</span>],img_back[:,:,<span class="hljs-number">1</span>])<br><br>plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>),plt.imshow(img_back, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Result&#x27;</span>), plt.xticks([]), plt.yticks([])<br><br>plt.show() <br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Cfft.png" alt="1565697691400"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>,<span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br>dft = cv2.dft(img_float32, flags = cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><br>rows, cols = img.shape<br>crow, ccol = <span class="hljs-built_in">int</span>(rows/<span class="hljs-number">2</span>) , <span class="hljs-built_in">int</span>(cols/<span class="hljs-number">2</span>)     <span class="hljs-comment"># 中心位置</span><br><br><span class="hljs-comment"># 高通滤波</span><br>mask = np.ones((rows, cols, <span class="hljs-number">2</span>), np.uint8)<br>mask[crow-<span class="hljs-number">30</span>:crow+<span class="hljs-number">30</span>, ccol-<span class="hljs-number">30</span>:ccol+<span class="hljs-number">30</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># IDFT</span><br>fshift = dft_shift*mask<br>f_ishift = np.fft.ifftshift(fshift)<br>img_back = cv2.idft(f_ishift)<br>img_back = cv2.magnitude(img_back[:,:,<span class="hljs-number">0</span>],img_back[:,:,<span class="hljs-number">1</span>])<br><br>plt.subplot(<span class="hljs-number">121</span>),plt.imshow(img, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>),plt.imshow(img_back, cmap = <span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Result&#x27;</span>), plt.xticks([]), plt.yticks([])<br><br>plt.show()   <br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%5Cdft.png" alt="1565697714813"></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/03/09/Git/"/>
    <url>/2020/03/09/Git/</url>
    
    <content type="html"><![CDATA[<p>全文参考自书籍Pro Git，<a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p> 版本控制系统是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。因此从大的方向上来说产生了三种版本控制系统——本地版本控制系统，集中式版本控制系统，分布式版本控制系统。</p><p>本地式版本控制系统的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新恢复出各个版本的文件内容。缺点是对协同合作不友好。</p><p>集中式版本控制系统有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。缺点是如果这个集中管理的服务器出故障，那么所有写作人员都会受到影响。</p><p>分布式版本控制系统让客户端并不只提取最新版本的文件，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。而Git就是一个分布式版本控制系统，基于Git有代码托管平台Github。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="在Linux上安装"><a href="#在Linux上安装" class="headerlink" title="在Linux上安装"></a>在Linux上安装</h3><p>如果你想在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。 如果以 Fedora 上为例，你可以使用 yum：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> sudo yum install git</span><br></code></pre></td></tr></table></figure><p>如果你在基于 Debian 的发行版上，请尝试用 apt-get：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install git</span><br></code></pre></td></tr></table></figure><p>要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 <a href="http://git-scm.com/download/linux%E3%80%82">http://git-scm.com/download/linux。</a></p><h3 id="在windows上安装"><a href="#在windows上安装" class="headerlink" title="在windows上安装"></a>在windows上安装</h3><p>在 Windows 上安装 Git 也有几种安装方法。 官方版本可以在 Git 官方网站下载。 打开 <a href="http://git-scm.com/download/win%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%BC%80%E5%A7%8B%E3%80%82">http://git-scm.com/download/win，下载会自动开始。</a> 要注意这是一个名为 Git for Windows 的项目（也叫做 msysGit），和 Git 是分别独立的项目；更多信息请访问 <a href="http://msysgit.github.io/%E3%80%82">http://msysgit.github.io/。</a></p><p>另一个简单的方法是安装 GitHub for Windows。 该安装程序包含图形化和命令行版本的 Git。 它也能支持 Powershell，提供了稳定的凭证缓存和健全的换行设置。 稍后我们会对这方面有更多了解，现在只要一句话就够了，这些都是你所需要的。 你可以在 GitHub for Windows 网站下载，网址为 <a href="http://windows.github.com/">http://windows.github.com</a>。</p><h2 id="初次运行的配置"><a href="#初次运行的配置" class="headerlink" title="初次运行的配置"></a>初次运行的配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置，三种配置优先级依次递增：</p><ol><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li><li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li></ol><h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><hr><p>我用的是windows10，在运行过程中中文无法正常显示，需要进行以下设置：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global core.quotepath <span class="hljs-literal">false</span></span><br></code></pre></td></tr></table></figure><p>这样能显示中文，但是是乱码，接着在git bash的界面中右击空白处，弹出菜单，选择<code>选项-&gt;文本-&gt;本地Locale</code>，设置为<code>zh_CN</code>，而旁边的字符集选框选为<code>UTF-8</code>。英文显示则是：<code>Options-&gt;Text-&gt;Locale改为zh_CN，Character set改为UTF-8</code>。</p><p>接着是修改log编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs consol">$ git config --global i18n.commitencoding utf-8  --注释：该命令表示提交命令的时候使用utf-8编码集提交<br><br>$ git config --global i18n.logoutputencoding utf-8 --注释：该命令表示日志输出时使用utf-8编码集显示<br><br>$ export LESSCHARSET&#x3D;utf-8  --注释：设置LESS字符集为utf-8<br></code></pre></td></tr></table></figure><hr><p>如果你的git bash终端没有菜单选项显示，还可以通过直接修改配置文件的方式来解决中文乱码问题。</p><p>进入git的安装目录</p><ol><li>编辑<code>etc\gitconfig</code>文件，也有些windows系统是存放在<code>C:\Users\Administrator\.gitconfig</code>路径或<code>安装盘符:\Git\mingw64\etc\gitconfig</code>，在文件末尾增加以下内容：</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[gui]</span>  <br>    <span class="hljs-attr">encoding</span> = utf-<span class="hljs-number">8</span>  <br>    <span class="hljs-comment"># 代码库统一使用utf-8  </span><br><span class="hljs-section">[i18n]</span>  <br>    <span class="hljs-attr">commitencoding</span> = utf-<span class="hljs-number">8</span>  <br>    <span class="hljs-comment"># log编码  </span><br><span class="hljs-section">[svn]</span>  <br>    <span class="hljs-attr">pathnameencoding</span> = utf-<span class="hljs-number">8</span>  <br>    <span class="hljs-comment"># 支持中文路径  </span><br><span class="hljs-section">[core]</span><br>    <span class="hljs-attr">quotepath</span> = <span class="hljs-literal">false</span> <br>    <span class="hljs-comment"># status引用路径不再是八进制（反过来说就是允许显示中文了）</span><br></code></pre></td></tr></table></figure><ol><li>编辑<code>etc\git-completion.bash</code>文件,在文件末尾增加以下内容：</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 让ls命令能够正常显示中文</span><br><span class="hljs-keyword">alias</span> <span class="hljs-keyword">ls</span>=&#x27;<span class="hljs-keyword">ls</span> <span class="hljs-params">--show-control-chars</span> <span class="hljs-params">--color=auto</span>&#x27; <br></code></pre></td></tr></table></figure><ol><li>编辑<code>etc\inputrc</code>文件，修改output-meta和convert-meta属性值：</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">set</span> output-meta <span class="hljs-keyword">on</span>  <span class="hljs-comment"># bash可以正常输入中文  </span><br><span class="hljs-keyword">set</span> convert-meta off  <br></code></pre></td></tr></table></figure><ol><li>编辑profile文件，在文件末尾添加如下内容：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LESSHARESET</span>=utf-8<br></code></pre></td></tr></table></figure><h3 id="换行符设置"><a href="#换行符设置" class="headerlink" title="换行符设置"></a>换行符设置</h3><p>简单来说，如果core.autocrlf=true ，我们工作区的文件都应该用 CRLF 来换行。如果改动文件时引入了 LF，或者设置 core.autocrlf 之前，工作区已经有 LF 换行符。提交改动时，git 会警告你哪些文件不是纯 CRLF 文件，但 git 不会擅自修改工作区的那些文件，而是对暂存区（我们对工作区的改动）进行修改。也因此，当我们进行 git add 的操作时，只要 git 发现改动的内容里有 LF 换行符，就还会出现这个警告。设置 core.autocrlf=true, 只要保持工作区都是纯 CRLF 文件，编辑器用 CRLF 换行，就不会出现警告了（题主提的问题 2）。git 默认让版本库里用 LF 换行，只要保持这条规则，多人协作就不会出什么大问题。git 的 Windows 客户端基本都会默认设置 core.autocrlf=trueLinux 最好不要设置 core.autocrlf，因为这个配置算是为 Windows 平台定制。如果 Windows 上设置 core.autocrlf=false，仓库里也没有配置 .gitattributes，很容易引入 CRLF 或者混合换行符</p><p>我目前的解决办法是：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ git config –-global core.<span class="hljs-built_in">auto</span>crlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">&quot;John Doe&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> git config --global user.email johndoe@example.com</span><br></code></pre></td></tr></table></figure><p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>配置默认使用的文本编辑器，可以这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global core.editor vim</span><br></code></pre></td></tr></table></figure><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --list</span><br>user.name=John Doe<br>user.email=johndoe@example.com<br>color.status=auto<br>color.branch=auto<br>color.interactive=auto<br>color.diff=auto<br>...<br></code></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config </code>： 来检查 Git 的某一项配置</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config user.name</span><br>John Doe<br></code></pre></td></tr></table></figure><h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">help</span> &lt;verb&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git &lt;verb&gt; --<span class="hljs-built_in">help</span></span><br><span class="hljs-meta">$</span><span class="bash"> man git-&lt;verb&gt;</span><br></code></pre></td></tr></table></figure><p>例如，要想获得 config 命令的手册，执行</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">help</span> config</span><br></code></pre></td></tr></table></figure><h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h3><p>有两种创建 Git 项目仓库的主要方式。 第一种是将已有项目或目录导入为 Git 仓库； 第二种是从其它服务器克隆一个已存在的 Git 仓库。</p><h4 id="在已存在目录中初始化仓库"><a href="#在已存在目录中初始化仓库" class="headerlink" title="在已存在目录中初始化仓库"></a>在已存在目录中初始化仓库</h4><p>如果你打算使用 Git 来对已有项目进行追踪，你需要进入项目目录并输入：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git init</span><br></code></pre></td></tr></table></figure><p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p><p>如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 <code>git add</code> 命令来指定所需的文件来进行追踪，然后执行 <code>git commit</code> ：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add *.c</span><br><span class="hljs-meta">$</span><span class="bash"> git add LICENSE</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&#x27;initial project version&#x27;</span></span><br></code></pre></td></tr></table></figure><p>稍后我们再逐一解释这些指令的行为。 现在，你已经得到了一个存在被追踪文件与初始提交的 Git 仓库。</p><h4 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h4><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。</p><p>克隆仓库的命令是 <code>git clone [url]</code> 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2</span><br></code></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 <code>libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></code></pre></td></tr></table></figure><p>这将执行与上一条命令相同的操作，但目标目录名变为了 <code>mylibgit</code>。</p><p>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 SSH 传输协议，比如 <code>user@server:path/to/repo.git</code> 。 </p><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。</p><p><img src="Git%5Cgit%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96%E5%91%A8%E6%9C%9F.png" alt="image-20200221093730676"></p><h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>nothing to commit, working directory clean<br></code></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。</p><p>现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;My Project&#x27;</span> &gt; README</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>    README<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure><p>在状态报告中可以看到新建的 README 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p><h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add README</span><br></code></pre></td></tr></table></figure><p>此时再运行 <code>git status</code> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br></code></pre></td></tr></table></figure><p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 <code>git add</code> 时的版本将被留存在历史记录中。 你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add (files)</code> 命令，开始跟踪当前目录下的文件。 <code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h4 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h4><p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 <code>git add</code> 将”CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> vim CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br>    modified:   CONTRIBUTING.md<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>怎么回事？ 现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本。 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p><p>总结起来就是每一次修改都需要<code>git add</code> 更新状态：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status -s</span><br> M README<br>MM Rakefile<br>A  lib/git.rb<br>M  lib/simplegit.rb<br>?? LICENSE.txt<br></code></pre></td></tr></table></figure><p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 你可能注意到了 <code>M</code> 有两个可以出现的位置，出现在右边的 <code>M</code> 表示该文件被修改了但是还没被放入暂存区，出现在靠左边的 <code>M</code> 表示该文件被修改了并被放入了暂存区。 例如，上面的状态报告显示： <code>README</code> 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code> 文件被修改了并已将修改后的文件放入了暂存区。 而 <code>Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> cat .gitignore</span><br>*.[oa]<br>*~<br></code></pre></td></tr></table></figure><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>*</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> , <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p><p>我们再看一个 .gitignore 文件的例子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">#</span><span class="bash"> no .a files</span><br>*.a<br><br><span class="hljs-meta">#</span><span class="bash"> but <span class="hljs-keyword">do</span> track lib.a, even though you<span class="hljs-string">&#x27;re ignoring .a files above</span></span><br>!lib.a<br><br><span class="hljs-meta">#</span><span class="bash"> only ignore the TODO file <span class="hljs-keyword">in</span> the current directory, not subdir/TODO</span><br>/TODO<br><br><span class="hljs-meta">#</span><span class="bash"> ignore all files <span class="hljs-keyword">in</span> the build/ directory</span><br>build/<br><br><span class="hljs-meta">#</span><span class="bash"> ignore doc/notes.txt, but not doc/server/arch.txt</span><br>doc/*.txt<br><br><span class="hljs-meta">#</span><span class="bash"> ignore all .pdf files <span class="hljs-keyword">in</span> the doc/ directory</span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure><blockquote><p> GitHub 有一个十分详细的针对数十种项目及语言(包括python，ROS)的 <code>.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它。</p></blockquote><h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>如果 <code>git status</code> 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。 稍后我们会详细介绍 <code>git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好下次提交？ 虽然 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，但 <code>git diff</code> 将通过文件补丁的格式更加具体地显示哪些行发生了改变。</p><p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    modified:   README<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git diff</span><br>diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md<br>index 8ebb991..643e24f 100644<br>--- a/CONTRIBUTING.md<br>+++ b/CONTRIBUTING.md<br>@@ -65,7 +65,8 @@ branch directly, things can get messy.<br> Please include a nice description of your changes when you submit your PR;<br> if we have to read the whole diff to figure out why you&#x27;re contributing<br> in the first place, you&#x27;re less likely to get feedback and have your change<br>-merged in.<br>+merged in. Also, split your changes into comprehensive chunks if your patch is<br>+longer than a dozen lines.<br><br> If you are starting to work on a particular area, feel free to submit a PR<br> that highlights your work in progress (and note in the PR title that it&#x27;s<br></code></pre></td></tr></table></figure><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。</p><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git diff --staged</span><br>diff --git a/README b/README<br>new file mode 100644<br>index 0000000..03902a1<br>--- /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+My Project<br></code></pre></td></tr></table></figure><p>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p><p>像之前说的，暂存 <code>CONTRIBUTING.md</code> 后再编辑，可以使用 <code>git status</code> 查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;# test line&#x27;</span> &gt;&gt; CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    modified:   CONTRIBUTING.md<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>现在运行 <code>git diff</code> 看暂存前后的变化：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git diff</span><br>diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md<br>index 643e24f..87f08c8 100644<br>--- a/CONTRIBUTING.md<br>+++ b/CONTRIBUTING.md<br>@@ -119,3 +119,4 @@ at the<br><span class="hljs-meta"> #</span><span class="bash"><span class="hljs-comment"># Starter Projects</span></span><br><br> See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).<br>+# test line<br></code></pre></td></tr></table></figure><p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化：（–staged 和 –cached 是同义词）</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git diff --cached</span><br>diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md<br>index 8ebb991..643e24f 100644<br>--- a/CONTRIBUTING.md<br>+++ b/CONTRIBUTING.md<br>@@ -65,7 +65,8 @@ branch directly, things can get messy.<br> Please include a nice description of your changes when you submit your PR;<br> if we have to read the whole diff to figure out why you&#x27;re contributing<br> in the first place, you&#x27;re less likely to get feedback and have your change<br>-merged in.<br>+merged in. Also, split your changes into comprehensive chunks if your patch is<br>+longer than a dozen lines.<br><br> If you are starting to work on a particular area, feel free to submit a PR<br> that highlights your work in progress (and note in the PR title that it&#x27;s<br></code></pre></td></tr></table></figure><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过但没有暂存的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git commit</span><br></code></pre></td></tr></table></figure><p>这种方式会启动文本编辑器以便输入本次提交的说明。 （默认会启用 shell 的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 <a href="https://git-scm.com/book/zh/v2/ch00/ch01-introduction">起步</a> 介绍的方式，使用 <code>git config --global core.editor</code> 命令设定你喜欢的编辑软件。）</p><p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-meta"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta"># On branch master</span><br><span class="hljs-meta"># Changes to be committed:</span><br><span class="hljs-meta">#new file:   README</span><br><span class="hljs-meta">#modified:   CONTRIBUTING.md</span><br><span class="hljs-meta">#</span><br>~<br>~<br>~<br><span class="hljs-string">&quot;.git/COMMIT_EDITMSG&quot;</span> <span class="hljs-number">9</span>L, <span class="hljs-number">283</span>C<br></code></pre></td></tr></table></figure><p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 （如果想要更详细的对修改了哪些内容的提示，可以用 <code>-v</code> 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p><p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span><br>[master 463dc4f] Story 182: Fix benchmarks for speed<br> 2 files changed, 2 insertions(+)<br> create mode 100644 README<br></code></pre></td></tr></table></figure><p>好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p><h4 id="跳过暂存区域"><a href="#跳过暂存区域" class="headerlink" title="跳过暂存区域"></a>跳过暂存区域</h4><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;added new benchmarks&#x27;</span></span><br>[master 83e38c7] added new benchmarks<br> 1 file changed, 5 insertions(+), 0 deletions(-)<br></code></pre></td></tr></table></figure><p>看到了吗？提交之前不再需要 <code>git add</code> 文件“CONTRIBUTING.md”了。 这是因为 <code>-a</code> 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心；有时这个选项会将不需要的文件添加到提交中。</p><h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> rm PROJECTS.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Changes not staged for commit:<br>  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        deleted:    PROJECTS.md<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure><p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rm PROJECTS.md</span><br>rm &#x27;PROJECTS.md&#x27;<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    deleted:    PROJECTS.md<br></code></pre></td></tr></table></figure><p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rm --cached README</span><br></code></pre></td></tr></table></figure><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。 比方说：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rm <span class="hljs-built_in">log</span>/\*.<span class="hljs-built_in">log</span></span><br></code></pre></td></tr></table></figure><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rm \*~</span><br></code></pre></td></tr></table></figure><p>该命令为删除以 <code>~</code> 结尾的所有文件。</p><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p><p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git mv file_from file_to</span><br></code></pre></td></tr></table></figure><p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git mv README.md README</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    renamed:    README.md -&gt; README<br></code></pre></td></tr></table></figure><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> mv README.md README</span><br><span class="hljs-meta">$</span><span class="bash"> git rm README.md</span><br><span class="hljs-meta">$</span><span class="bash"> git add README</span><br></code></pre></td></tr></table></figure><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，<code>mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code> 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p><p>我们使用一个非常简单的 “simplegit” 项目作为示例。 运行下面的命令获取该项目：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/schacon/simplegit-progit</span><br></code></pre></td></tr></table></figure><p>当你在此项目中运行 <code>git log</code> 命令时，可以看到下面的输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span></span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br><br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><br>    removed unnecessary test<br><br>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 10:31:28 2008 -0700<br><br>    first commit<br></code></pre></td></tr></table></figure><p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。</p><p>其中一个比较有用的选项是 <code>-p</code>，它会显示每次提交所引入的差异。 与此同时，你也可以使用 <code>-2</code> 选项来仅显示最近的两次提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> -p -2</span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br><br>diff --git a/Rakefile b/Rakefile<br>index a874b73..8f94139 100644<br>--- a/Rakefile<br>+++ b/Rakefile<br>@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27;<br> spec = Gem::Specification.new do |s|<br>     s.platform  =   Gem::Platform::RUBY<br>     s.name      =   &quot;simplegit&quot;<br>-    s.version   =   &quot;0.1.0&quot;<br>+    s.version   =   &quot;0.1.1&quot;<br>     s.author    =   &quot;Scott Chacon&quot;<br>     s.email     =   &quot;schacon@gee-mail.com&quot;<br>     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;<br><br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><br>    removed unnecessary test<br><br>diff --git a/lib/simplegit.rb b/lib/simplegit.rb<br>index a0a60ae..47c6340 100644<br>--- a/lib/simplegit.rb<br>+++ b/lib/simplegit.rb<br>@@ -18,8 +18,3 @@ class SimpleGit<br>     end<br><br> end<br>-<br>-if $0 == __FILE__<br>-  git = SimpleGit.new<br>-  puts git.show<br>-end<br>\ No newline at end of file<br></code></pre></td></tr></table></figure><p>该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 选项：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br><br> Rakefile | 2 +-<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br><br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><br>    removed unnecessary test<br><br> lib/simplegit.rb | 5 -----<br> 1 file changed, 5 deletions(-)<br><br>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 10:31:28 2008 -0700<br><br>    first commit<br><br> README           |  6 ++++++<br> Rakefile         | 23 +++++++++++++++++++++++<br> lib/simplegit.rb | 25 +++++++++++++++++++++++++<br> 3 files changed, 54 insertions(+)<br></code></pre></td></tr></table></figure><p>正如你所看到的，<code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><p>另一个非常有用的选项是 <code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=oneline</span><br>ca82a6dff817ec66f44342007202690a93763949 changed the version number<br>085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test<br>a11bef06a3f659402fe7563abf99ad00de2209e6 first commit<br></code></pre></td></tr></table></figure><p>但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h - %an, %ar : %s&quot;</span></span><br>ca82a6d - Scott Chacon, 6 years ago : changed the version number<br>085bb3b - Scott Chacon, 6 years ago : removed unnecessary test<br>a11bef0 - Scott Chacon, 6 years ago : first commit<br></code></pre></td></tr></table></figure><h4 id="定制输出格式"><a href="#定制输出格式" class="headerlink" title="定制输出格式"></a>定制输出格式</h4><p><a href="https://git-scm.com/book/zh/v2/ch00/rpretty_format"><code>git log --pretty=format</code> 常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>%H</code></td><td align="left">提交的完整哈希值</td></tr><tr><td align="left"><code>%h</code></td><td align="left">提交的简写哈希值</td></tr><tr><td align="left"><code>%T</code></td><td align="left">树的完整哈希值</td></tr><tr><td align="left"><code>%t</code></td><td align="left">树的简写哈希值</td></tr><tr><td align="left"><code>%P</code></td><td align="left">父提交的完整哈希值</td></tr><tr><td align="left"><code>%p</code></td><td align="left">父提交的简写哈希值</td></tr><tr><td align="left"><code>%an</code></td><td align="left">作者名字</td></tr><tr><td align="left"><code>%ae</code></td><td align="left">作者的电子邮件地址</td></tr><tr><td align="left"><code>%ad</code></td><td align="left">作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td align="left"><code>%ar</code></td><td align="left">作者修订日期，按多久以前的方式显示</td></tr><tr><td align="left"><code>%cn</code></td><td align="left">提交者（committer）的名字</td></tr><tr><td align="left"><code>%ce</code></td><td align="left">提交者的电子邮件地址</td></tr><tr><td align="left"><code>%cd</code></td><td align="left">提交日期</td></tr><tr><td align="left"><code>%cr</code></td><td align="left">提交日期（距今多长时间）</td></tr><tr><td align="left"><code>%s</code></td><td align="left">提交说明</td></tr></tbody></table><p>你一定奇怪 <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git">分布式 Git</a> 再详细介绍两者之间的细微差别。</p><p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h %s&quot;</span> --graph</span><br>* 2d3acf9 ignore errors from SIGCHLD on trap<br>*  5e3ee11 Merge branch &#x27;master&#x27; of git://github.com/dustin/grit<br>|\<br>| * 420eac9 Added a method for getting the current branch.<br>* | 30e367c timeout code and tests<br>* | 5a09431 add timeout protection to grit<br>* | e1193f8 support for heads with slashes in them<br>|/<br>* d6016bc require time for xmlschema<br>*  11d191e Merge branch &#x27;defunkt&#x27; into local<br></code></pre></td></tr></table></figure><p>这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。</p><p>以上只是简单介绍了一些 <code>git log</code> 命令支持的选项。 <a href="https://git-scm.com/book/zh/v2/ch00/rlog_options"><code>git log</code> 的常用选项</a> 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-p</code></td><td align="left">按补丁格式显示每个提交引入的差异。</td></tr><tr><td align="left"><code>--stat</code></td><td align="left">显示每次提交的文件修改统计信息。</td></tr><tr><td align="left"><code>--shortstat</code></td><td align="left">只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td align="left"><code>--name-only</code></td><td align="left">仅在提交信息后显示已修改的文件清单。</td></tr><tr><td align="left"><code>--name-status</code></td><td align="left">显示新增、修改、删除的文件清单。</td></tr><tr><td align="left"><code>--abbrev-commit</code></td><td align="left">仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td></tr><tr><td align="left"><code>--relative-date</code></td><td align="left">使用较短的相对时间而不是完整格式显示日期（比如，“2 weeks ago”）。</td></tr><tr><td align="left"><code>--graph</code></td><td align="left">在日志旁以 ASCII 图形显示分支与合并历史。</td></tr><tr><td align="left"><code>--pretty</code></td><td align="left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（用来定义自己的格式）。</td></tr></tbody></table><h4 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h4><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出一部分的提交。 之前你已经看到过 <code>-2</code> 选项了，它只会显示最近的两条提交， 实际上，你可以使用类似 <code>-</code> 的选项，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的 <code>n</code> 条提交。 不过实践中这个选项不是很常用，因为 Git 默认会将所有的输出传送到分页程序中，所以你一次只会看到一页的内容。</p><p>但是，类似 <code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所有提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --since=2.weeks</span><br></code></pre></td></tr></table></figure><p>该命令可用的格式十分丰富——可以是类似 <code>&quot;2008-01-15&quot;</code> 的具体的某一天，也可以是类似 <code>&quot;2 years 1 day 3 minutes ago&quot;</code> 的相对日期。</p><p>还可以过滤出匹配指定条件的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。 （请注意，如果你要同时对作者和提交说明进行过滤，就必须添加 <code>--all-match</code> 选项，否则该命令将会匹配满足其中任意一个条件的提交）</p><p>另一个非常有用的过滤器是 <code>-S</code>，它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> -Sfunction_name</span><br></code></pre></td></tr></table></figure><p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p><p>在 <a href="https://git-scm.com/book/zh/v2/ch00/rlimit_options">限制 <code>git log</code> 输出的选项</a> 中列出了常用的选项</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-(n)</code></td><td align="left">仅显示最近的 n 条提交。</td></tr><tr><td align="left"><code>--since</code>, <code>--after</code></td><td align="left">仅显示指定时间之后的提交。</td></tr><tr><td align="left"><code>--until</code>, <code>--before</code></td><td align="left">仅显示指定时间之前的提交。</td></tr><tr><td align="left"><code>--author</code></td><td align="left">仅显示作者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--committer</code></td><td align="left">仅显示提交者匹配指定字符串的提交。</td></tr><tr><td align="left"><code>--grep</code></td><td align="left">仅显示提交说明中包含指定字符串的提交。</td></tr><tr><td align="left"><code>-S</code></td><td align="left">仅显示添加或删除内容匹配指定字符串的提交。</td></tr></tbody></table><p>来看一个实际的例子，如果要查看 2008 年 10 月期间 Git 源代码仓库中，由 Junio Hamano 提交的修改了测试文件并且尚未合并的提交，可以使用下面的命令:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%h - %s&quot;</span> --author=gitster --since=<span class="hljs-string">&quot;2008-10-01&quot;</span> \</span><br><span class="bash">   --before=<span class="hljs-string">&quot;2008-11-01&quot;</span> --no-merges -- t/</span><br>5610e3b - Fix testcase failure when extended attributes are in use<br>acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API<br>f563754 - demonstrate breakage of detached checkout with symbolic link HEAD<br>d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths<br>51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD<br>b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch<br></code></pre></td></tr></table></figure><p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p><h3 id="取消操作"><a href="#取消操作" class="headerlink" title="取消操作"></a>取消操作</h3><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git commit --amend</span><br></code></pre></td></tr></table></figure><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&#x27;initial commit&#x27;</span></span><br><span class="hljs-meta">$</span><span class="bash"> git add forgotten_file</span><br><span class="hljs-meta">$</span><span class="bash"> git commit --amend</span><br></code></pre></td></tr></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p><h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add *</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    renamed:    README.md -&gt; README<br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>在 “Changes to be committed” 文字正下方，提示使用 <code>git reset HEAD ...</code> 来取消暂存。 所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git reset HEAD CONTRIBUTING.md</span><br>Unstaged changes after reset:<br>MCONTRIBUTING.md<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    renamed:    README.md -&gt; README<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>这个命令有点儿奇怪，但是起作用了。 <code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p><p>到目前为止这个神奇的调用就是你需要对 <code>git reset</code> 命令了解的全部。我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_reset">重置揭密</a> 中了解 <code>reset</code> 的更多细节以及如何掌握它做一些真正有趣的事。</p><h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，<code>git status</code> 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console">Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure><p>它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -- CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    renamed:    README.md -&gt; README<br></code></pre></td></tr></table></figure><p>可以看到那些修改已经被撤消了。</p><p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 介绍保存进度与分支；这些通常是更好的做法。</p><blockquote><p>你需要知道 <code>git checkout -- [file]</code> 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失——你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p></blockquote><p>记住，在 Git 中任何 <em>已提交的</em> 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复（阅读 <a href="https://git-scm.com/book/zh/v2/ch00/r_data_recovery">数据恢复</a> 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p><h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 </p><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/schacon/ticgit</span><br>Cloning into &#x27;ticgit&#x27;...<br>remote: Reusing existing pack: 1857, done.<br>remote: Total 1857 (delta 0), reused 0 (delta 0)<br>Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.<br>Resolving deltas: 100% (772/772), done.<br>Checking connectivity... done.<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ticgit</span><br><span class="hljs-meta">$</span><span class="bash"> git remote</span><br>origin<br></code></pre></td></tr></table></figure><p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>originhttps://github.com/schacon/ticgit (fetch)<br>originhttps://github.com/schacon/ticgit (push)<br></code></pre></td></tr></table></figure><p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> grit</span><br><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>bakkdoor  https://github.com/bakkdoor/grit (fetch)<br>bakkdoor  https://github.com/bakkdoor/grit (push)<br>cho45     https://github.com/cho45/grit (fetch)<br>cho45     https://github.com/cho45/grit (push)<br>defunkt   https://github.com/defunkt/grit (fetch)<br>defunkt   https://github.com/defunkt/grit (push)<br>koke      git://github.com/koke/grit.git (fetch)<br>koke      git://github.com/koke/grit.git (push)<br>origin    git@github.com:mojombo/grit.git (fetch)<br>origin    git@github.com:mojombo/grit.git (push)<br></code></pre></td></tr></table></figure><p>这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。</p><p>注意这些远程仓库使用了不同的协议；我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server">在服务器上搭建 Git</a> 中了解关于它们的更多信息。</p><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 <code>git remote add  </code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote</span><br>origin<br><span class="hljs-meta">$</span><span class="bash"> git remote add pb https://github.com/paulboone/ticgit</span><br><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>originhttps://github.com/schacon/ticgit (fetch)<br>originhttps://github.com/schacon/ticgit (push)<br>pbhttps://github.com/paulboone/ticgit (fetch)<br>pbhttps://github.com/paulboone/ticgit (push)<br></code></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git fetch pb</span><br>remote: Counting objects: 43, done.<br>remote: Compressing objects: 100% (36/36), done.<br>remote: Total 43 (delta 10), reused 31 (delta 5)<br>Unpacking objects: 100% (43/43), done.<br>From https://github.com/paulboone/ticgit<br> * [new branch]      master     -&gt; pb/master<br> * [new branch]      ticgit     -&gt; pb/ticgit<br></code></pre></td></tr></table></figure><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p><h4 id="从远程仓库抓取或拉取"><a href="#从远程仓库抓取或拉取" class="headerlink" title="从远程仓库抓取或拉取"></a>从远程仓库抓取或拉取</h4><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git fetch [remote-name]</span><br></code></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 了解更多信息），可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin master</span><br></code></pre></td></tr></table></figure><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 了解如何推送到远程仓库服务器的详细信息。</p><h4 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote show origin</span><br>* remote origin<br>  Fetch URL: https://github.com/schacon/ticgit<br>  Push  URL: https://github.com/schacon/ticgit<br>  HEAD branch: master<br>  Remote branches:<br>    master                               tracked<br>    dev-branch                           tracked<br>  Local branch configured for &#x27;git pull&#x27;:<br>    master merges with remote master<br>  Local ref configured for &#x27;git push&#x27;:<br>    master pushes to master (up to date)<br></code></pre></td></tr></table></figure><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p><p>这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote show origin</span><br>* remote origin<br>  URL: https://github.com/my-org/complex-project<br>  Fetch URL: https://github.com/my-org/complex-project<br>  Push  URL: https://github.com/my-org/complex-project<br>  HEAD branch: master<br>  Remote branches:<br>    master                           tracked<br>    dev-branch                       tracked<br>    markdown-strip                   tracked<br>    issue-43                         new (next fetch will store in remotes/origin)<br>    issue-45                         new (next fetch will store in remotes/origin)<br>    refs/remotes/origin/issue-11     stale (use &#x27;git remote prune&#x27; to remove)<br>  Local branches configured for &#x27;git pull&#x27;:<br>    dev-branch merges with remote dev-branch<br>    master     merges with remote master<br>  Local refs configured for &#x27;git push&#x27;:<br>    dev-branch                     pushes to dev-branch                     (up to date)<br>    markdown-strip                 pushes to markdown-strip                 (up to date)<br>    master                         pushes to master                         (up to date)<br></code></pre></td></tr></table></figure><p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code>git pull</code> 时哪些分支会自动合并。</p><h4 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h4><p>如果想要重命名引用的名字可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote rename pb paul</span><br><span class="hljs-meta">$</span><span class="bash"> git remote</span><br>origin<br>paul<br></code></pre></td></tr></table></figure><p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 <code>git remote rm</code> ：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote rm paul</span><br><span class="hljs-meta">$</span><span class="bash"> git remote</span><br>origin<br></code></pre></td></tr></table></figure><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 <code>git tag</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v0.1<br>v1.3<br></code></pre></td></tr></table></figure><p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p><p>你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag -l <span class="hljs-string">&#x27;v1.8.5*&#x27;</span></span><br>v1.8.5<br>v1.8.5-rc0<br>v1.8.5-rc1<br>v1.8.5-rc2<br>v1.8.5-rc3<br>v1.8.5.1<br>v1.8.5.2<br>v1.8.5.3<br>v1.8.5.4<br>v1.8.5.5<br></code></pre></td></tr></table></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p><p>一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。</p><p>然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p><h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="hljs-string">&quot;my version 1.4&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v0.1<br>v1.3<br>v1.4<br></code></pre></td></tr></table></figure><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p><p>通过使用 <code>git show</code> 命令可以看到标签信息与对应的提交信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git show v1.4</span><br>tag v1.4<br>Tagger: Ben Straub &lt;ben@straub.cc&gt;<br>Date:   Sat May 3 20:19:12 2014 -0700<br><br>my version 1.4<br><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br></code></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag v1.4-lw</span><br><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v0.1<br>v1.3<br>v1.4<br>v1.4-lw<br>v1.5<br></code></pre></td></tr></table></figure><p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git show v1.4-lw</span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br></code></pre></td></tr></table></figure><h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=oneline</span><br>15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;<br>a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support<br>0d52aaab4479697da7686c15f77a3d64d9165190 one more thing<br>6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;<br>0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function<br>4682c3261057305bdd616e23b64b0857d832627b added a todo file<br>166ae0c4d3f420721acbb115cc33848dfcc2121a started write support<br>9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile<br>964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo<br>8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme<br></code></pre></td></tr></table></figure><p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag -a v1.2 9fceb02</span><br></code></pre></td></tr></table></figure><p>可以看到你已经在那次提交上打上标签了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v0.1<br>v1.2<br>v1.3<br>v1.4<br>v1.4-lw<br>v1.5<br><br><span class="hljs-meta">$</span><span class="bash"> git show v1.2</span><br>tag v1.2<br>Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Feb 9 15:32:16 2009 -0800<br><br>version 1.2<br>commit 9fceb02d0ae598e95dc970b74767f19372d61af8<br>Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;<br>Date:   Sun Apr 27 20:43:35 2008 -0700<br><br>    updated rakefile<br>...<br></code></pre></td></tr></table></figure><h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin [tagname]</code>。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin v1.5</span><br>Counting objects: 14, done.<br>Delta compression using up to 8 threads.<br>Compressing objects: 100% (12/12), done.<br>Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.<br>Total 14 (delta 3), reused 0 (delta 0)<br>To git@github.com:schacon/simplegit.git<br> * [new tag]         v1.5 -&gt; v1.5<br></code></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin --tags</span><br>Counting objects: 1, done.<br>Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.<br>Total 1 (delta 0), reused 0 (delta 0)<br>To git@github.com:schacon/simplegit.git<br> * [new tag]         v1.4 -&gt; v1.4<br> * [new tag]         v1.4-lw -&gt; v1.4-lw<br></code></pre></td></tr></table></figure><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d </code>。例如，可以使用下面的命令删除掉一个轻量级标签：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag -d v1.4-lw</span><br>Deleted tag &#x27;v1.4-lw&#x27; (was e7d5add)<br></code></pre></td></tr></table></figure><p>应该注意的是上述命令并不会从任何远程仓库中移除这个标签，你必须使用 <code>git push  :refs/tags/</code> 来更新你的远程仓库：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin :refs/tags/v1.4-lw</span><br>To /git@github.com:schacon/simplegit.git<br> - [deleted]         v1.4-lw<br></code></pre></td></tr></table></figure><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令，虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态——这个状态有些不好的副作用：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout 2.0.0</span><br>Note: checking out &#x27;2.0.0&#x27;.<br><br>You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.<br><br>If you want to create a new branch to retain commits you create, you may<br>do so (now or later) by using -b with the checkout command again. Example:<br><br>  git checkout -b &lt;new-branch&gt;<br><br>HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final<br><br><span class="hljs-meta">$</span><span class="bash"> git checkout 2.0-beta-0.1</span><br>Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final<br>HEAD is now at df3f601... add atlas.json and cover image<br></code></pre></td></tr></table></figure><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b version2 v2.0.0</span><br>Switched to a new branch &#x27;version2&#x27;<br></code></pre></td></tr></table></figure><p>当然，如果在这之后又进行了一次提交，<code>version2</code> 分支会因为这个改动向前移动，<code>version2</code> 分支就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就应该当心了。</p><h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。</p><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.co checkout</span><br><span class="hljs-meta">$</span><span class="bash"> git config --global alias.br branch</span><br><span class="hljs-meta">$</span><span class="bash"> git config --global alias.ci commit</span><br><span class="hljs-meta">$</span><span class="bash"> git config --global alias.st status</span><br></code></pre></td></tr></table></figure><p>这意味着，当要输入 <code>git commit</code> 时，只需要输入 <code>git ci</code>。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p><p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.unstage <span class="hljs-string">&#x27;reset HEAD --&#x27;</span></span><br></code></pre></td></tr></table></figure><p>这会使下面的两个命令等价：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git unstage fileA</span><br><span class="hljs-meta">$</span><span class="bash"> git reset HEAD -- fileA</span><br></code></pre></td></tr></table></figure><p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code> 命令，像这样：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.last <span class="hljs-string">&#x27;log -1 HEAD&#x27;</span></span><br></code></pre></td></tr></table></figure><p>这样，可以轻松地看到最后一次提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git last</span><br>commit 66938dae3329c7aebe598c2246a8e6af90d04646<br>Author: Josh Goebel &lt;dreamer3@example.com&gt;<br>Date:   Tue Aug 26 19:48:51 2008 +0800<br><br>    test for current head<br><br>    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;<br></code></pre></td></tr></table></figure><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.visual <span class="hljs-string">&#x27;!gitk&#x27;</span></span><br></code></pre></td></tr></table></figure><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p><p>有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。</p><p>或许你还记得之前的内容，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p><p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p><p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add README test.rb LICENSE</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&#x27;The initial commit of my project&#x27;</span></span><br></code></pre></td></tr></table></figure><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p><p><img src="Git%5Cgit_%E9%A6%96%E6%AC%A1%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1.png" alt="image-20200221185759349"></p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p><blockquote><p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p></blockquote><p><img src="Git%5Cgit_%E5%88%86%E6%94%AF.png" alt="image-20200221190056356"></p><h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch testing</span><br></code></pre></td></tr></table></figure><p>这会在当前所在的提交对象上创建一个指针。</p><p><img src="Git%5Cgit_%E5%88%86%E6%94%AF.png" alt="image-20200221190314721"></p><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p><p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate</span><br>f30ab (HEAD, master, testing) add feature #32 - ability to add new<br>34ac2 fixed bug #1328 - stack overflow under certain conditions<br>98ca9 initial commit of my project<br></code></pre></td></tr></table></figure><p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout testing</span><br></code></pre></td></tr></table></figure><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> vim test.rb</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;made a change&#x27;</span></span><br></code></pre></td></tr></table></figure><p><img src="Git%5Cgit_%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF.png" alt="image-20200221190530844"></p><p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br></code></pre></td></tr></table></figure><p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向另一个方向进行开发。</p><blockquote><p>分支切换会改变你工作目录中的文件。在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p></blockquote><p>我们不妨再稍微做些修改并提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> vim test.rb</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;made other changes&#x27;</span></span><br></code></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="Git%5Cgit_%E5%88%86%E6%94%AF%E5%88%86%E5%8F%89.png" alt="image-20200221190834692"></p><p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate --graph --all</span><br>* c2b9e (HEAD, master) made other changes<br>| * 87ab2 (testing) made a change<br>|/<br>* f30ab add feature #32 - ability to add new formats to the<br>* 34ac2 fixed bug #1328 - stack overflow under certain conditions<br>* 98ca9 initial commit of my project<br></code></pre></td></tr></table></figure><p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p><p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p><h3 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h3><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b iss53</span><br>Switched to a new branch &quot;iss53&quot;<br></code></pre></td></tr></table></figure><p>它是下面两条命令的简写：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch iss53</span><br><span class="hljs-meta">$</span><span class="bash"> git checkout iss53</span><br></code></pre></td></tr></table></figure><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经在处理该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> vim index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;added a new footer [issue 53]&#x27;</span></span><br></code></pre></td></tr></table></figure><p><img src="Git%5Cgit_%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF.png" alt="image-20200221191300889"></p><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_stashing">储藏与清理</a> 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br>Switched to branch &#x27;master&#x27;<br></code></pre></td></tr></table></figure><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p><p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b hotfix</span><br>Switched to a new branch &#x27;hotfix&#x27;<br><span class="hljs-meta">$</span><span class="bash"> vim index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;fixed the broken email address&#x27;</span></span><br>[hotfix 1fb7853] fixed the broken email address<br> 1 file changed, 2 insertions(+)<br></code></pre></td></tr></table></figure><p><img src="Git%5Cgit_%E5%88%86%E6%94%AF2.png" alt="image-20200221191348528"></p><p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge hotfix</span><br>Updating f42c576..3a0874c<br>Fast-forward<br> index.html | 2 ++<br> 1 file changed, 2 insertions(+)<br></code></pre></td></tr></table></figure><p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -d hotfix</span><br>Deleted branch hotfix (3a0874c).<br></code></pre></td></tr></table></figure><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout iss53</span><br>Switched to branch &quot;iss53&quot;<br><span class="hljs-meta">$</span><span class="bash"> vim index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;finished the new footer [issue 53]&#x27;</span></span><br>[iss53 ad82d7a] finished the new footer [issue 53]<br>1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure><p><img src="Git%5Cgit_%E5%88%86%E6%94%AF3.png" alt="image-20200221191502537"></p><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p><h4 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h4><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br>Switched to branch &#x27;master&#x27;<br><span class="hljs-meta">$</span><span class="bash"> git merge iss53</span><br>Merge made by the &#x27;recursive&#x27; strategy.<br>index.html |    1 +<br>1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。</p><p><img src="Git%5Cgit_%E4%B8%89%E6%96%B9%E5%90%88%E5%B9%B6.png" alt="image-20200221191739143"></p><p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><p><img src="Git%5Cgit_%E4%B8%89%E6%96%B9%E5%90%88%E5%B9%B62.png" alt="image-20200221191815081"></p><p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -d iss53</span><br></code></pre></td></tr></table></figure><h4 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h4><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git merge iss53</span><br>Auto-merging index.html<br>CONFLICT (content): Merge conflict in index.html<br>Automatic merge failed; fix conflicts and then commit the result.<br></code></pre></td></tr></table></figure><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>You have unmerged paths.<br>  (fix conflicts and run &quot;git commit&quot;)<br><br>Unmerged paths:<br>  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)<br><br>    both modified:      index.html<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>=======<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br> please contact us at support@github.com<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html<br></code></pre></td></tr></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br>please contact us at email.support@github.com<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git mergetool</span><br><br>This message is displayed because &#x27;merge.tool&#x27; is not configured.<br>See &#x27;git mergetool --tool-help&#x27; or &#x27;git help config&#x27; for more details.<br>&#x27;git mergetool&#x27; will now attempt to use one of the following tools:<br>opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge<br>Merging:<br>index.html<br><br>Normal merge conflict for &#x27;index.html&#x27;:<br>  &#123;local&#125;: modified file<br>  &#123;remote&#125;: modified file<br>Hit return to start merge resolution tool (opendiff):<br></code></pre></td></tr></table></figure><p>如果你想使用除默认工具（在这里 Git 使用 <code>opendiff</code> 做为默认的合并工具，因为作者在 Mac 上运行该程序）外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。</p><p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>All conflicts fixed but you are still merging.<br>  (use &quot;git commit&quot; to conclude merge)<br><br>Changes to be committed:<br><br>    modified:   index.html<br></code></pre></td></tr></table></figure><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs console">Merge branch &#x27;iss53&#x27;<br><br>Conflicts:<br>    index.html<br><span class="hljs-meta">#</span><br><span class="bash"><span class="hljs-comment"># It looks like you may be committing a merge.</span></span><br><span class="hljs-meta">#</span><span class="bash"> If this is not correct, please remove the file</span><br><span class="hljs-meta">#</span><span class="bash">.git/MERGE_HEAD</span><br><span class="hljs-meta">#</span><span class="bash"> and try again.</span><br><br><br><span class="hljs-meta">#</span><span class="bash"> Please enter the commit message <span class="hljs-keyword">for</span> your changes. Lines starting</span><br><span class="hljs-meta">#</span><span class="bash"> with <span class="hljs-string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta">#</span><span class="bash"> On branch master</span><br><span class="hljs-meta">#</span><span class="bash"> All conflicts fixed but you are still merging.</span><br><span class="hljs-meta">#</span><br><span class="bash"><span class="hljs-comment"># Changes to be committed:</span></span><br><span class="hljs-meta">#</span><span class="bash">modified:   index.html</span><br><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure><p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch</span><br>  iss53<br>* master<br>  testing<br></code></pre></td></tr></table></figure><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -v</span><br>  iss53   93b412c fix javascript issue<br>* master  7a98805 Merge branch &#x27;iss53&#x27;<br>  testing 782fd34 add scott to the author list in the readmes<br></code></pre></td></tr></table></figure><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch --merged</span><br>  iss53<br>* master<br></code></pre></td></tr></table></figure><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch --no-merged</span><br>  testing<br></code></pre></td></tr></table></figure><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -d testing</span><br>error: The branch &#x27;testing&#x27; is not fully merged.<br>If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.<br></code></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><p>现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？ 在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p><h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><p><img src="Git%5Cgit_%E6%B8%90%E8%BF%9B%E7%A8%B3%E5%AE%9A%E5%88%86%E6%94%AF.png" alt="image-20200221192402784"></p><p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p><h4 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h4><p>特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p><p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code> 分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code> 的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p><p><img src="Git%5Cgit_%E7%89%B9%E6%80%A7%E5%88%86%E6%94%AF.png" alt="image-20200221192511297"></p><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p><p><img src="Git%5Cgit_%E7%89%B9%E6%80%A7%E5%88%86%E6%94%AF2.png" alt="image-20200221192546452"></p><p>我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git">分布式 Git</a> 中向你揭示更多有关分支工作流的细节，因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。</p><p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。</p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><h4 id="远程分支-1"><a href="#远程分支-1" class="headerlink" title="远程分支"></a>远程分支</h4><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 <code>git ls-remote [remote]</code> 来显式地获得远程引用的完整列表，或者通过 <code>git remote show [remote]</code> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p><p>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p><p>它们以 <code>(remote)/(branch)</code> 形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支；但是在服务器上的分支会指向 <code>origin/iss53</code> 的提交。</p><p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据，创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p><blockquote><p>“origin” 并无特殊含义</p><p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 <code>git clone</code> 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。</p></blockquote><p><img src="Git%5C%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="image-20200221201134137"></p><p>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p><p><img src="Git%5C%E6%9C%AC%E5%9C%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E5%8F%89.png" alt="image-20200221201257270"></p><p>如果要同步数据，运行 <code>git fetch origin</code> 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p><p><img src="Git%5C%E5%90%8C%E6%AD%A5%E4%BB%93%E5%BA%93.png" alt="image-20200221201330149"></p><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个 sprint 团队。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch02-git-basics">Git 基础</a> 中详细说明。 将这个远程仓库命名为 <code>teamone</code>，将其作为完整 URL 的缩写。</p><p><img src="Git%5C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%931.png" alt="image-20200221201411043"></p><p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。</p><p><img src="C:\Users\www43\AppData\Roaming\Typora\typora-user-images\image-20200221201445030.png" alt="image-20200221201445030"></p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为 <code>serverfix</code> 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push (remote) (branch)</code>:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin serverfix</span><br>Counting objects: 24, done.<br>Delta compression using up to 8 threads.<br>Compressing objects: 100% (15/15), done.<br>Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.<br>Total 24 (delta 2), reused 0 (delta 0)<br>To https://github.com/schacon/simplegit<br> * [new branch]      serverfix -&gt; serverfix<br></code></pre></td></tr></table></figure><p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals">Git 内部原理</a> 的 <code>refs/heads/</code> 部分，但是现在可以先把它放在儿。 你也可以运行 <code>git push origin serverfix:serverfix</code>，它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p><blockquote><p>如何避免每次输入密码</p><p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p><p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code> </code> 来设置它。</p><p>想要了解更多关于不同验证缓存的可用选项，查看 <a href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching">凭证存储</a>。</p></blockquote><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git fetch origin</span><br>remote: Counting objects: 7, done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 3 (delta 0)<br>Unpacking objects: 100% (3/3), done.<br>From https://github.com/schacon/simplegit<br> * [new branch]      serverfix    -&gt; origin/serverfix<br></code></pre></td></tr></table></figure><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支——只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p><p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b serverfix origin/serverfix</span><br>Branch serverfix set up to track remote branch serverfix from origin.<br>Switched to a new branch &#x27;serverfix&#x27;<br></code></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p><h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout --track origin/serverfix</span><br>Branch serverfix set up to track remote branch serverfix from origin.<br>Switched to a new branch &#x27;serverfix&#x27;<br></code></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b sf origin/serverfix</span><br>Branch sf set up to track remote branch serverfix from origin.<br>Switched to a new branch &#x27;sf&#x27;<br></code></pre></td></tr></table></figure><p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -u origin/serverfix</span><br>Branch serverfix set up to track remote branch serverfix from origin.<br></code></pre></td></tr></table></figure><p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -vv</span><br>  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets<br>  master    1ae2a45 [origin/master] deploying index fix<br>* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it<br>  testing   5ea463a trying something new<br></code></pre></td></tr></table></figure><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：<code>$ git fetch --all; git branch -vv</code></p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin --delete serverfix</span><br>To https://github.com/schacon/simplegit<br> - [deleted]         serverfix<br></code></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p><h4 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h4><p>请回顾之前在 <a href="https://git-scm.com/book/zh/v2/ch00/r_basic_merging">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p><p><img src="Git%5Cimage-20200221203157771.png" alt="image-20200221203157771"></p><p>整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><p><img src="Git%5Cimage-20200221203219206.png" alt="image-20200221203219206"></p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在上面这个例子中，运行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout experiment</span><br><span class="hljs-meta">$</span><span class="bash"> git rebase master</span><br>First, rewinding head to replay your work on top of it...<br>Applying: added staged command<br></code></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p><p><img src="Git%5Cimage-20200221203308092.png" alt="image-20200221203308092"></p><p>现在回到 <code>master</code> 分支，进行一次快进合并。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge experiment</span><br></code></pre></td></tr></table></figure><p><img src="Git%5Cimage-20200221203335262.png" alt="image-20200221203335262"></p><p>此时，<code>C4&#39;</code> 指向的快照就和上面使用 <code>merge</code> 命令的例子中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p><p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h4 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h4><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <a href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_e">从一个特性分支里再分出一个特性分支的提交历史</a> 中的例子那样。 你创建了一个特性分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p><p><img src="Git%5Cimage-20200221203426765.png" alt="image-20200221203426765"></p><p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rebase --onto master server client</span><br></code></pre></td></tr></table></figure><p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的修改，然后把它们在 <code>master</code> 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。</p><p><img src="Git%5Cimage-20200221203449597.png" alt="image-20200221203449597"></p><p>现在可以快进合并 <code>master</code> 分支了。（如图 <a href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_g">快进合并 master 分支，使之包含来自 client 分支的修改</a>）：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge client</span><br></code></pre></td></tr></table></figure><p><img src="Git%5Cimage-20200221203509968.png" alt="image-20200221203509968"></p><p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rebase master server</span><br></code></pre></td></tr></table></figure><p>如图 <a href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_h">将 server 中的修改变基到 master 上</a> 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p><p><img src="Git%5Cimage-20200221203545556.png" alt="image-20200221203545556"></p><p>然后就可以快进合并主分支 master 了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge server</span><br></code></pre></td></tr></table></figure><p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成图 <a href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_i">最终的提交历史</a> 中的样子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -d client</span><br><span class="hljs-meta">$</span><span class="bash"> git branch -d server</span><br></code></pre></td></tr></table></figure><p><img src="Git%5Cimage-20200221203608742.png" alt="image-20200221203608742"></p><h4 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h4><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p><p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p><p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p><p><img src="Git%5Cimage-20200221203643244.png" alt="image-20200221203643244"></p><p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p><p><img src="Git%5Cimage-20200221203708356.png" alt="image-20200221203708356"></p><p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="Git%5Cimage-20200221203726498.png" alt="image-20200221203726498"></p><p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p><p><img src="Git%5Cimage-20200221203751115.png" alt="image-20200221203751115"></p><p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p><h4 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a>用变基解决变基</h4><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p><p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p><p>举个例子，如果遇到前面提到的 <a href="https://git-scm.com/book/zh/v2/ch00/r_pre_merge_rebase_work">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</a> 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p><ul><li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li><li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li><li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li><li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li></ul><p>从而我们将得到与 <a href="https://git-scm.com/book/zh/v2/ch00/r_merge_rebase_work">你将相同的内容又合并了一次，生成了一个新的提交</a> 中不同的结果，如图 <a href="https://git-scm.com/book/zh/v2/ch00/r_rebase_rebase_work">在一个被变基然后强制推送的分支上再次执行变基</a> 所示。</p><p><img src="Git%5Cimage-20200221203831054.png" alt="image-20200221203831054"></p><p>要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p><p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p><p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h4 id="变基VS合并"><a href="#变基VS合并" class="headerlink" title="变基VS合并"></a>变基VS合并</h4><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p><h2 id="服务器上的Git协议"><a href="#服务器上的Git协议" class="headerlink" title="服务器上的Git协议"></a>服务器上的Git协议</h2><p>到目前为止，你应该已经有办法使用 Git 来完成日常工作。 然而，为了使用 Git 协作功能，你还需要有远程的 Git 仓库。 尽管在技术上你可以从个人仓库进行推送（push）和拉取（pull）来修改内容，但不鼓励使用这种方法，因为一不留心就很容易弄混其他人的进度。 此外，你希望你的合作者们即使在你的电脑未联机时亦能存取仓库 — 拥有一个更可靠的公用仓库十分有用。 因此，与他人合作的最佳方法即是建立一个你与合作者们都有权利访问，且可从那里推送和拉取资料的共用仓库。</p><p>架设一台 Git 服务器并不难。 首先，选择你希望服务器使用的通讯协议。 在本章第一节将介绍可用的协议以及各自优缺点。 下面一节将解释使用那些协议的典型设置及如何在你的服务器上运行。 最后，如果你不介意托管你的代码在其他人的服务器，且不想经历设置与维护自己服务器的麻烦，可以试试我们介绍的几个仓库托管服务。</p><p>如果你对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个代码托管服务的帐户然后继续下一章，我们会在那里讨论分散式源码控制环境的林林总总。</p><p>一个远程仓库通常只是一个裸仓库（bare repository）——即一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照；存放的只有 Git 的资料。 简单的说，裸仓库就是你工程目录内的 <code>.git</code> 子目录内容，不包含其他资料。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。 在此，我们将会讨论那些协议及哪些情形应该使用（或避免使用）他们。</p><h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是硬盘内的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p><p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> /opt/git/project.git</span><br></code></pre></td></tr></table></figure><p>或你可以执行这个命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> file:///opt/git/project.git</span><br></code></pre></td></tr></table></figure><p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references）或对象（object）的干净版本库副本– 通常是在从其他版本控制系统导入后或一些类似情况（参见 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals">Git 内部原理</a> for maintenance tasks）需要这么做。 在此我们将使用普通路径，因为这样通常更快。</p><p>要增加一个本地版本库到现有的 Git 项目，可以执行如下的命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote add local_proj /opt/git/project.git</span><br></code></pre></td></tr></table></figure><p>然后，就可以像在网络上一样从远端版本库推送和拉取更新了。</p><hr><p>优点</p><p>基于文件系统的版本库的优点是简单，并且直接使用了现有的文件权限和网络访问权限。 如果你的团队已经有共享文件系统，建立版本库会十分容易。 只需要像设置其他共享目录一样，把一个裸版本库的副本放到大家都可以访问的路径，并设置好读/写的权限，就可以了， 我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server">在服务器上搭建 Git</a> 讨论如何导出一个裸版本库。</p><p>这也是快速从别人的工作目录中拉取更新的方法。 如果你和别人一起合作一个项目，他想让你从版本库中拉取更新时，运行类似 <code>git pull /home/john/project</code> 的命令比推送到服务器再取回简单多了。</p><hr><p>缺点</p><p>这种方法的缺点是，通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问。 如果你想从家里推送内容，必须先挂载一个远程磁盘，相比网络连接的访问方式，配置不方便，速度也慢。</p><p>值得一提的是，如果你使用的是类似于共享挂载的文件系统时，这个方法不一定是最快的。 访问本地版本库的速度与你访问数据的速度是一样的。 在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</p><p>最终，这个协议并不保护仓库避免意外的损坏。 每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</p><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。 我们先了解一下新的“智能” HTTP 协议。</p><h5 id="智能（Smart）HTTP协议"><a href="#智能（Smart）HTTP协议" class="headerlink" title="智能（Smart）HTTP协议"></a>智能（Smart）HTTP协议</h5><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p><p>事实上，类似 GitHub 的服务，你在网页上看到的 URL （比如， <code>https://github.com/schacon/simplegit[]</code>），和你在克隆、推送（如果你有权限）时使用的是一样的。</p><h5 id="哑（Dumb）-HTTP-协议"><a href="#哑（Dumb）-HTTP-协议" class="headerlink" title="哑（Dumb） HTTP 协议"></a>哑（Dumb） HTTP 协议</h5><p>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了（见 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_hooks">Git 钩子</a>）。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。 下面是设置从 HTTP 访问版本库的方法：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /var/www/htdocs/</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> --bare /path/to/git_project gitproject.git</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> gitproject.git</span><br><span class="hljs-meta">$</span><span class="bash"> mv hooks/post-update.sample hooks/post-update</span><br><span class="hljs-meta">$</span><span class="bash"> chmod a+x hooks/post-update</span><br></code></pre></td></tr></table></figure><p>这样就可以了。 Git 自带的 <code>post-update</code> 挂钩会默认执行合适的命令（<code>git update-server-info</code>），来确保通过 HTTP 的获取和克隆操作正常工作。 这条命令会在你通过 SSH 向版本库推送之后被执行；然后别人就可以通过类似下面的命令来克隆：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://example.com/gitproject.git</span><br></code></pre></td></tr></table></figure><p>这里我们用了 Apache 里设置了常用的路径 <code>/var/www/htdocs</code>，不过你可以使用任何静态 web 服务器 —— 只需要把裸版本库放到正确的目录下就可以。 Git 的数据是以基本的静态文件形式提供的（详情见 <a href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals">Git 内部原理</a>）。</p><p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p><hr><p>优点</p><p>我们将只关注智能 HTTP 协议的优点。</p><p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p><p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p><p>另一个好处是 HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p><hr><p>缺点</p><p>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与 “智能” HTTP 协议相比就几乎没有优势了。</p><p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 OSX 的 Keychain 或者 Windows 的凭证管理器。 参考 <a href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching">凭证存储</a> 如何安全地保存 HTTP 密码。</p><h4 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h4><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下服务器已经支持通过 SSH 访问 —— 即使没有也很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p><p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> ssh://user@server/project.git</span><br></code></pre></td></tr></table></figure><p>或者使用一个简短的 scp 式的写法：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> user@server:project.git</span><br></code></pre></td></tr></table></figure><p>你也可以不指定用户，Git 会使用当前登录的用户名。</p><p>优势<br>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p><p>缺点<br>SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。</p><h4 id="Git协议"><a href="#Git协议" class="headerlink" title="Git协议"></a>Git协议</h4><p>接下来是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 git-daemon-export-ok 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p><p>优点<br>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><p>缺点<br>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 git:// 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 xinetd 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p>]]></content>
    
    
    <categories>
      
      <category>编程工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>政府官方网站</title>
    <link href="/2020/03/02/%E6%94%BF%E5%BA%9C%E5%AE%98%E6%96%B9%E7%BD%91%E7%AB%99/"/>
    <url>/2020/03/02/%E6%94%BF%E5%BA%9C%E5%AE%98%E6%96%B9%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="政府官方网站"><a href="#政府官方网站" class="headerlink" title="政府官方网站"></a>政府官方网站</h1><a class="btn" href="/assets"  target="_blank">中国行政体系思维导图</a><h3 id="国务院"><a href="#国务院" class="headerlink" title="国务院"></a><a href="http://www.gov.cn/index.htm">国务院</a></h3><h4 id="26个组成部门"><a href="#26个组成部门" class="headerlink" title="26个组成部门"></a>26个组成部门</h4><ul><li><a href="http://www.fmprc.gov.cn/web/">外交部</a></li><li><a href="http://www.mod.gov.cn/">国防部</a></li><li><a href="http://www.ndrc.gov.cn/">国家发展和改革委员会</a></li><li><a href="http://www.moe.gov.cn/">教育部</a></li><li><a href="http://www.most.gov.cn/">科学技术部</a></li><li><a href="http://www.miit.gov.cn/">工业和信息化部</a></li><li><a href="http://www.seac.gov.cn/">国家民族事务委员会</a></li><li><a href="http://www.mps.gov.cn/">公安部</a></li><li><a href="None">国家安全部</a></li><li><a href="http://www.mca.gov.cn/">民政部</a></li><li><a href="http://www.moj.gov.cn/">司法部</a></li><li><a href="http://www.mof.gov.cn/index.htm">财政部</a></li><li><a href="http://www.mohrss.gov.cn/">人力资源和社会保障部</a></li><li><a href="http://www.mnr.gov.cn/">自然资源部</a></li><li><a href="http://www.mee.gov.cn/">生态环境部</a></li><li><a href="http://www.mohurd.gov.cn/">住房和城乡建设部</a></li><li><a href="http://www.mot.gov.cn/">交通运输部</a></li><li><a href="http://www.mwr.gov.cn/">水利部</a></li><li><a href="http://www.moa.gov.cn/">农业农村部</a></li><li><a href="http://www.mofcom.gov.cn/">商务部</a></li><li><a href="http://www.mct.gov.cn/">文化和旅游部</a></li><li><a href="http://www.nhc.gov.cn/">国家卫生健康委员会</a></li><li><a href="http://www.mva.gov.cn/">退役军人事务部</a></li><li><a href="http://www.mem.gov.cn/">应急管理部</a></li><li><a href="http://www.pbc.gov.cn/">人民银行</a></li><li><a href="http://www.audit.gov.cn/">审计署</a></li></ul><h4 id="1个直属特设机构"><a href="#1个直属特设机构" class="headerlink" title="1个直属特设机构"></a>1个直属特设机构</h4><ul><li><a href="http://www.sasac.gov.cn/">国务院国有资产监督管理委员会</a></li></ul><h4 id="10个直属机构"><a href="#10个直属机构" class="headerlink" title="10个直属机构"></a>10个直属机构</h4><ul><li><a href="http://www.customs.gov.cn/">海关总署</a></li><li><a href="http://www.samr.gov.cn/">国家市场监督管理总局</a></li><li><a href="http://www.sport.gov.cn/">国家体育总局</a></li><li><a href="http://www.cidca.gov.cn/">国家国际发展合作署</a></li><li><a href="http://www.counsellor.gov.cn/">国务院参事室</a></li><li><a href="http://www.chinatax.gov.cn/">国家税务总局</a></li><li><a href="http://www.nrta.gov.cn/">国家广播电视总局</a></li><li><a href="http://www.stats.gov.cn/">国家统计局</a></li><li><a href="http://www.nhsa.gov.cn/">国家医疗保障局</a></li><li><a href="http://www.ggj.gov.cn/">国家机关事务管理局</a></li></ul><h4 id="2个国务院办事机构"><a href="#2个国务院办事机构" class="headerlink" title="2个国务院办事机构"></a>2个国务院办事机构</h4><ul><li><a href="http://www.hmo.gov.cn/">国务院港澳事务办公室</a></li><li><a href="http://www.gov.cn/guoqing/2018-06/22/content_5300522.htm">国务院研究室</a></li></ul><h4 id="9个国务院直属事业单位"><a href="#9个国务院直属事业单位" class="headerlink" title="9个国务院直属事业单位"></a>9个国务院直属事业单位</h4><ul><li><a href="http://203.192.6.89/xhs/">新华通讯社</a></li><li><a href="http://www.cas.ac.cn/">中国科学院</a></li><li><a href="http://cass.cssn.cn/">中国社会科学院</a></li><li><a href="http://www.cae.cn/">中国工程院</a></li><li><a href="http://www.drc.gov.cn/">国务院发展研究中心</a></li><li><a href="None">中央广播电视总台</a></li><li><a href="http://www.cma.gov.cn/">中国气象局</a></li><li><a href="http://www.cbirc.gov.cn/cn/view/pages/index/index.html">中国银行保险监督管理委员会</a></li><li><a href="http://www.csrc.gov.cn/pub/newsite/">中国证券监督管理委员会</a></li></ul><h4 id="15个国务院部委管理的国家局"><a href="#15个国务院部委管理的国家局" class="headerlink" title="15个国务院部委管理的国家局"></a>15个国务院部委管理的国家局</h4><ul><li><a href="http://www.gjxfj.gov.cn/">国家信访局</a></li><li><a href="http://www.nea.gov.cn/">国家能源局</a></li><li><a href="http://www.tobacco.gov.cn/html/">国家烟草专卖局</a></li><li><a href="http://www.caac.gov.cn/index.html">中国民用航空局</a></li><li><a href="http://www.ncha.gov.cn/">国家文物局</a></li><li><a href="http://www.chinacoal-safety.gov.cn/">国家煤矿安全监察局</a></li><li><a href="http://www.nmpa.gov.cn/WS04/CL2042/">国家药品监督管理局</a></li><li><a href="http://www.chinagrain.gov.cn/index.html">国家粮食和物资储备局</a></li><li><a href="http://www.sastind.gov.cn/">国家国防科技工业局</a></li><li><a href="http://www.mps.gov.cn/n2254996/">国家移民管理局</a></li><li><a href="http://www.nra.gov.cn/">国家铁路局</a></li><li><a href="http://www.spb.gov.cn/">国家邮政局</a></li><li><a href="http://www.satcm.gov.cn/">国家中医药管理局</a></li><li><a href="http://www.safe.gov.cn/">国家外汇管理局</a></li><li><a href="http://www.cnipa.gov.cn/">国家知识产权局</a></li></ul><h3 id="中宣部组织部部分部门"><a href="#中宣部组织部部分部门" class="headerlink" title="中宣部组织部部分部门"></a>中宣部组织部部分部门</h3><ul><li><a href="http://www.cnca.gov.cn/">国家认证认可监督管理委员会</a></li><li><a href="http://www.sac.gov.cn/">国家标准化管理委员会</a></li><li><a href="http://www.ncac.gov.cn/">国家新闻出版署（国家版权局）</a></li><li><a href="http://www.scio.gov.cn/index.htm">国务院新闻办公室</a></li><li><a href="None">国家外国专家局</a></li><li><a href="http://www.ggj.gov.cn/">国家机关事务管理局</a></li><li><a href="http://www.ccps.gov.cn/">国家行政学院</a></li><li><a href="http://www.scs.gov.cn/">国家公务员局</a></li><li><a href="http://www.saac.gov.cn/">国家档案局</a></li><li><a href="http://www.gjbmj.gov.cn/">国家保密局</a></li><li><a href="http://www.oscca.gov.cn/">国家密码管理局</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息搜集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的Hexo</title>
    <link href="/2020/02/28/%E6%88%91%E7%9A%84Hexo/"/>
    <url>/2020/02/28/%E6%88%91%E7%9A%84Hexo/</url>
    
    <content type="html"><![CDATA[<p>本文记录我对hexo改造的历程，由于网上资源杂乱无章，花费了大量时间试错，故在此立文以警后来者少进坑。</p><h1 id="基础美化"><a href="#基础美化" class="headerlink" title="基础美化"></a>基础美化</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>根据官网教程，博客基于node.js和git，利用npm安装hexo的命令行工具hexo-cli并将其加入环境变量执行hexo的初始化hexo init生成以下目录结构：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<br>├── node_modules       <span class="hljs-regexp">//</span>依赖安装目录<br>├── scaffolds          <span class="hljs-regexp">//</span>模板文件夹，新建的文章将会从此目录下的文件中继承格式<br>|   ├── draft.md         <span class="hljs-regexp">//</span>草稿模板<br>|   ├── page.md          <span class="hljs-regexp">//</span>页面模板<br>|   └── post.md          <span class="hljs-regexp">//</span>文章模板<br>├── source             <span class="hljs-regexp">//</span>资源文件夹，用于放置图片、数据、文章等资源<br>|   └── _posts           <span class="hljs-regexp">//</span>放置文章的地方<br>├── themes             <span class="hljs-regexp">//</span>主题文件夹<br>|   └── landscape        <span class="hljs-regexp">//</span>默认主题<br>├── .gitignore         <span class="hljs-regexp">//</span>指定不纳入git版本控制的文件<br>├── _config.yml        <span class="hljs-regexp">//</span>站点配置文件<br>├── db.json            <br>├── package.json<br>└── package-lock.json<br></code></pre></td></tr></table></figure><p>对hexo的优化都是基于主题文件夹下的主题文件进行修改，偶尔会编辑站点配置文件增加插件声明内容。</p><p>在根目录下执行如下命令启动 hexo 的内置 Web 服务器</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>该命令将会调用 Markdown 引擎解析项目中的博客内容生成网页资源，资源将会存于内存中，所以用户执行完命令之后在项目文件夹中是找不到相关的 Web 资源目录的。该命令还会启动一个简易的 Web 服务器用于提供对内存中网页资源的访问（工作机制类似于 webpack-dev-server），Web 服务器默认监听 4000 端口，用户可在浏览器中通过地址 <code>localhost:4000</code> 访问博客。</p><p>此外，可以通过添加命令行参数来支持高级用法：</p><ul><li>当 4000 端口已被其他应用占用时，可以添加 <code>-p</code> / <code>--port</code> 参数来设置 Web 服务监听的端口号，如<code>hexo s -p 8000</code></li><li>默认情况下，hexo 监听项目目录的文件变化，用户对于项目文件的任何改动都会触发实时解析编译并更新内存中的网页资源，也就是说，用户在本地修改后刷新浏览器就可以看到改动效果。如果不希望 hexo 监听项目目录的文件变化，可以添加 <code>-s</code> / <code>--static</code> 参数，这样本地改动就不会触发 hexo 实时解析更新。</li></ul><p>值得一提的是，如若未修改站点配置文件，无需重启web服务器，直接刷新便可看到修改。</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Next 作为一款符合广大程序员审美的主题，还是有着较高的出场率的。Hexo 中切换主题的方式非常简单，只需要将主题文件拷贝至根目录下的 <code>themes</code> 文件夹中， 然后修改 <code>_config.yml</code> 文件中的 <code>theme</code> 字段即可。</p><p>在根目录下执行以下命令下载主题文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/theme-next/</span>hexo-theme-<span class="hljs-keyword">next</span>.git themes/<span class="hljs-keyword">next</span><br></code></pre></td></tr></table></figure><p>也可以在 <a href="https://github.com/theme-next/hexo-theme-next/releases">NexT 版本发布页面</a> 手动下载然后解压到根目录下的 <code>theme</code> 文件夹下，并将文件夹命名为 <code>next</code> 。这里可以看到 <code>theme</code> 文件夹下已经有一个名为 <code>landscape</code> 的文件夹了，这就是默认主题了。</p><p>打开站点配置文件，将 <code>theme</code> 字段的值修改为 <code>next</code>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_config</span>.</span></span>ymltheme: next<br></code></pre></td></tr></table></figure><p>这个时候刷新浏览器页面并不会发生变化，需要重启服务器并刷新才能使主题生效。</p><p>Next 默认主题风格为 Muse，用户可以在主题配置文件中修改 <code>scheme</code> 字段以选择自己喜欢的主题风格：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit">themes\<span class="hljs-keyword">next</span>\_config.yml<br><span class="hljs-meta"># Schemes</span><br>scheme: Muse<br><span class="hljs-meta">#scheme: Mist</span><br><span class="hljs-meta">#scheme: Pisces</span><br><span class="hljs-meta">#scheme: Gemini</span><br></code></pre></td></tr></table></figure><h2 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h2><p>根目录下的 _config.yml 文件负责站点的相关配置，用户可以通过修改该文件来自定义站点内容或功能，修改后需要重启服务器才能看到效果。</p><p>本节通过修改站点配置文件完善了网站标题、网站描述、社交链接、站点版权信息、友情链接等，</p><h2 id="完善站点基础信息"><a href="#完善站点基础信息" class="headerlink" title="完善站点基础信息"></a>完善站点基础信息</h2><p>在站点配置文件中完善网站基本信息：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">_config.yml<br><span class="hljs-symbol">title:</span>  <span class="hljs-meta"># 站点名称</span><br><span class="hljs-symbol">description:</span>   <span class="hljs-meta"># 站点描述</span><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN <span class="hljs-meta"># 设置网站语言为简体中文</span><br><span class="hljs-symbol">author:</span> yearito  <span class="hljs-meta"># 作者名称</span><br></code></pre></td></tr></table></figure><p>每个字段的冒号与值之间需要<strong>间隔一个空格</strong>。</p><h3 id="首页显示文章摘要"><a href="#首页显示文章摘要" class="headerlink" title="首页显示文章摘要"></a>首页显示文章摘要</h3><p>根据默认的主题配置，首页将会显示每一篇文章的全文，如果想要只显示文章摘要，可以在主题配置文件中做出如下更改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">themes\next\_config.yml</span><br><span class="hljs-attr">auto_excerpt:</span>  <br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启自动摘要提取  </span><br><span class="hljs-attr">length:</span> <span class="hljs-number">150</span><br></code></pre></td></tr></table></figure><p>此时将会从文章中提取 150 个字符作为摘要。</p><p>用户可以在文章中通过 `` 标记来精确划分摘要信息，标记之前的段落将作为摘要显示在首页。</p><p>如果在文章的 Front-Matter 中有非空的 <code>description</code> 字段，则该字段的内容会被作为摘要显示在首页。</p><h3 id="修改站点页脚"><a href="#修改站点页脚" class="headerlink" title="修改站点页脚"></a>修改站点页脚</h3><p>在主题配置文件中修改网站页脚信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">themes\next\_config.yml</span><br><span class="hljs-attr">footer:</span>  <span class="hljs-comment"># 底部信息区  </span><br><span class="hljs-attr">since:</span> <span class="hljs-number">2018</span>  <span class="hljs-comment"># 建站时间  </span><br><span class="hljs-attr">icon:</span>    <br><span class="hljs-attr">name:</span> <span class="hljs-string">heart</span>   <span class="hljs-comment"># 图标名称    </span><br><span class="hljs-attr">animated:</span> <span class="hljs-literal">true</span>   <span class="hljs-comment"># 开启动画    </span><br><span class="hljs-attr">color:</span> <span class="hljs-string">&quot;#ff0000&quot;</span>   <span class="hljs-comment"># 图标颜色  </span><br><span class="hljs-attr">powered:</span>    <br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 显示由 Hexo 强力驱动    </span><br><span class="hljs-attr">version:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 隐藏 Hexo 版本号  </span><br><span class="hljs-attr">theme:</span>    <br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 显示所用的主题名称    </span><br><span class="hljs-attr">version:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 隐藏主题版本号</span><br></code></pre></td></tr></table></figure><h3 id="修改网站-Favicon"><a href="#修改网站-Favicon" class="headerlink" title="修改网站 Favicon"></a>修改网站 Favicon</h3><p>Favicon 即浏览器标签左侧的图标。下载自己喜欢的图标置于 <code>themes\next\source\images\</code> 目录下，命名方式参考主题配置文件中的 <code>favicon</code> 字段。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">themes\<span class="hljs-keyword">next</span>\_config.yml<br>favicon:  <br>small: <span class="hljs-regexp">/images/</span>favicon-<span class="hljs-number">16</span>x16-<span class="hljs-keyword">next</span>.png  <span class="hljs-comment"># 小图标  </span><br>medium: <span class="hljs-regexp">/images/</span>favicon-<span class="hljs-number">32</span>x32-<span class="hljs-keyword">next</span>.png  <span class="hljs-comment"># 大图标  </span><br>apple_touch_icon: <span class="hljs-regexp">/images/</span>apple-touch-icon-<span class="hljs-keyword">next</span>.png  <span class="hljs-comment"># 苹果图标  </span><br>safari_pinned_tab: <span class="hljs-regexp">/images/</span>logo.svg  <span class="hljs-comment"># safari浏览器标签页图标</span><br></code></pre></td></tr></table></figure><h3 id="添加友情链接"><a href="#添加友情链接" class="headerlink" title="添加友情链接"></a>添加友情链接</h3><p>在主题配置文件中修改相应字段：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">themes\next\_config.yml<br><span class="hljs-symbol">links_icon:</span> link<br><span class="hljs-symbol">links_title:</span> 友情链接<br><span class="hljs-symbol">links_layout:</span> inline<br><span class="hljs-symbol">links:</span>  <br><span class="hljs-symbol">yearito:</span> http:<span class="hljs-comment">//yearito.cn/</span><br></code></pre></td></tr></table></figure><h3 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h3><p>用户可以在主题配置文件中根据样例提示添加个人社交软件链接：themes\next_config.yml</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">social</span>:<br>  <span class="hljs-attribute">GitHub</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/yourname || github</span><br>  <span class="hljs-attribute">E-Mail</span>: <span class="hljs-attribute">mailto</span>:yourname<span class="hljs-variable">@gmail</span>.com || envelope<br>  <span class="hljs-attribute">Weibo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//weibo.com/yourname || weibo</span><br>  <span class="hljs-attribute">Google</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//plus.google.com/yourname || google</span><br>  <span class="hljs-attribute">Twitter</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//twitter.com/yourname || twitter</span><br>  FB <span class="hljs-attribute">Page</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.facebook.com/yourname || facebook</span><br>  VK <span class="hljs-attribute">Group</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//vk.com/yourname || vk</span><br>  <span class="hljs-attribute">StackOverflow</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//stackoverflow.com/yourname || stack-overflow</span><br>  <span class="hljs-attribute">YouTube</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//youtube.com/yourname || youtube</span><br>  <span class="hljs-attribute">Instagram</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//instagram.com/yourname || instagram</span><br>  <span class="hljs-attribute">Skype</span>: <span class="hljs-attribute">skype</span>:yourname?call|chat || skype<br><br><span class="hljs-attribute">social_icons</span>:   <br>  <span class="hljs-attribute">enable</span>: true  # 显示社交软件图标<br>  <span class="hljs-attribute">icons_only</span>: false  # 显示图标的同时显示文字<br></code></pre></td></tr></table></figure><p>如果要取消社交图标前的小圆点，可以在自定义样式文件中添加如下样式规则：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">themes/next/source/css/_custom/custom.styl<br><span class="hljs-comment">//隐藏社交图标前的圆点</span><br><span class="hljs-selector-class">.links-of-author</span> <span class="hljs-selector-tag">a</span>,<br><span class="hljs-selector-class">.links-of-author</span> <span class="hljs-selector-class">.exturl</span> &#123;<br>  &amp;:before &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修改文章目录导航"><a href="#修改文章目录导航" class="headerlink" title="修改文章目录导航"></a>修改文章目录导航</h2><h3 id="取消数字编号"><a href="#取消数字编号" class="headerlink" title="取消数字编号"></a>取消数字编号</h3><p>在主题配置文件中关闭目录中的数字编号：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">themes\next\_config.yml</span><br><span class="hljs-attr">toc:</span><br>  <span class="hljs-attr">number:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 关闭目录中的数字编号</span><br></code></pre></td></tr></table></figure><h3 id="展开全部目录层级"><a href="#展开全部目录层级" class="headerlink" title="展开全部目录层级"></a>展开全部目录层级</h3><p>默认情况下文章的多级目录是折叠的，点击才会触发下级菜单的展开，并且并且同时只能展开一个目录分支，这会造成在点击不同目录标题的时候目录跳来跳去。如果你想实现默认展开全部目录的功能，可以在自定义样式文件中添加以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">themes</span>\<span class="hljs-selector-tag">next</span>\<span class="hljs-selector-tag">source</span>\<span class="hljs-selector-tag">css</span>\_<span class="hljs-selector-tag">custom</span>\<span class="hljs-selector-tag">custom</span><span class="hljs-selector-class">.styl</span><br>//<span class="hljs-selector-tag">TOC</span>目录默认全部展开<br><span class="hljs-selector-class">.post-toc</span> <span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.nav-child</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="默认展开两级目录"><a href="#默认展开两级目录" class="headerlink" title="默认展开两级目录"></a>默认展开两级目录</h3><p>通常文章内会出现多级标题，对应的目录里就会有多级导航出现，这时候一些原本你不希望出现的次要标题也会在目录中出现并且无法折叠。可以通过以下样式实现默认只展开两级目录，这样以来就通过一个折中的方案完美解决了目录折叠的问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">themes</span>\<span class="hljs-selector-tag">next</span>\<span class="hljs-selector-tag">source</span>\<span class="hljs-selector-tag">css</span>\_<span class="hljs-selector-tag">custom</span>\<span class="hljs-selector-tag">custom</span><span class="hljs-selector-class">.styl</span><br>//<span class="hljs-selector-tag">TOC</span>目录默认展开两级<br><span class="hljs-selector-class">.post-toc</span> <span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.nav-level-1</span>&gt;<span class="hljs-selector-class">.nav-child</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只显示两级目录"><a href="#只显示两级目录" class="headerlink" title="只显示两级目录"></a>只显示两级目录</h3><p>如果你根本不想让三级及以上的标题出现 TOC 导航目录中，可以考虑在自定义样式文件中添加以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">themes</span>\<span class="hljs-selector-tag">next</span>\<span class="hljs-selector-tag">source</span>\<span class="hljs-selector-tag">css</span>\_<span class="hljs-selector-tag">custom</span>\<span class="hljs-selector-tag">custom</span><span class="hljs-selector-class">.styl</span><br>//<span class="hljs-selector-tag">TOC</span>目录默认只显示两级目录<br><span class="hljs-selector-class">.nav-level-2</span> &gt; <span class="hljs-selector-class">.nav-child</span> &#123;<br>  <span class="hljs-attribute">display</span>: none <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主动隐藏文章目录"><a href="#主动隐藏文章目录" class="headerlink" title="主动隐藏文章目录"></a>主动隐藏文章目录</h3><p>如果你写了一篇并不算长的文章，没有层层嵌套的多级目录结构，此时侧边的文章目录空荡荡的就有点鸡肋了。修改侧边栏布局模板中的相关逻辑代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">themes\next\layout\_macro\sidebar.swig<br>- &#123;% <span class="hljs-builtin-name">set</span> display_toc = is_post <span class="hljs-keyword">and</span> theme.toc.<span class="hljs-builtin-name">enable</span> %&#125;<br>+ &#123;% <span class="hljs-builtin-name">set</span> display_toc = is_post <span class="hljs-keyword">and</span> theme.toc.<span class="hljs-builtin-name">enable</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> page.hide_toc %&#125;<br></code></pre></td></tr></table></figure><p>然后就可在 Front-Matter 中设定变量 hide_toc 用于控制是否隐藏侧边目录。</p><h3 id="修改文章-meta-信息"><a href="#修改文章-meta-信息" class="headerlink" title="修改文章 meta 信息"></a>修改文章 meta 信息</h3><p>默认主题配置中，标题下方会显示文章的创建时间、文章的修改时间、文章分类信息等元数据，用户可以在主题配置文件中自定义设置需要显示的 meta 元信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">themes\next\_config.yml</span><br><span class="hljs-attr">post_meta:</span><br>  <span class="hljs-attr">item_text:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 显示文字说明</span><br>  <span class="hljs-attr">created_at:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 显示文章创建时间</span><br>  <span class="hljs-attr">updated_at:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 隐藏文章修改时间</span><br>    <span class="hljs-attr">another_day:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 只有当修改时间和创建时间不是同一天的时候才显示</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 隐藏分类信息</span><br></code></pre></td></tr></table></figure><h3 id="中英文之间自动添加空格"><a href="#中英文之间自动添加空格" class="headerlink" title="中英文之间自动添加空格"></a>中英文之间自动添加空格</h3><p>该功能由 <a href="https://github.com/vinta/pangu.js">pangu</a> 提供，在根目录下执行如下命令克隆插件到项目中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/theme-next/</span>theme-<span class="hljs-keyword">next</span>-pangu.git themes<span class="hljs-regexp">/next/</span>source<span class="hljs-regexp">/lib/</span>pangu<br></code></pre></td></tr></table></figure><p>在主题配置文件中设置 <code>pangu: true</code> 即可启用该动能。</p><h3 id="修正文末导航跳转逻辑"><a href="#修正文末导航跳转逻辑" class="headerlink" title="修正文末导航跳转逻辑"></a>修正文末导航跳转逻辑</h3><p>如果不是看到 reuixiy 的文章，可能一辈子都不会注意到这个奇葩的逻辑：文章底部的左侧 / 右侧箭头分别导航到更旧 / 更新的文章链接，就好像你在手机相册里左滑却看到了更久以前的照片，细细想想这个逻辑毫无社会主义可言，至少没有中国特色。</p><p>修改文章布局模板：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">themes\next\layout\_macro\post.swig</span><br><span class="xml">&#123;% if not is_index and (post.prev or post.next) %&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-nav&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-nav-next post-nav-item&quot;</span>&gt;</span></span><br><span class="xml">-      &#123;% if post.next %&#125;</span><br><span class="xml">+      &#123;% if post.prev %&#125;</span><br><span class="xml">-        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">url_for</span>(<span class="hljs-name">post.next.path</span>) &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;next&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">post.next.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">+        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">url_for</span>(<span class="hljs-name">post.prev.path</span>) &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prev&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">post.prev.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">-          <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-chevron-left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">post.next.title</span> &#125;&#125;</span><br><span class="xml">+          <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-chevron-left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">post.prev.title</span> &#125;&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="xml">      &#123;% endif %&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-nav-divider&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-nav-prev post-nav-item&quot;</span>&gt;</span></span><br><span class="xml">-      &#123;% if post.prev %&#125;</span><br><span class="xml">+      &#123;% if post.next %&#125;</span><br><span class="xml">-        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">url_for</span>(<span class="hljs-name">post.prev.path</span>) &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prev&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">post.prev.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">+        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">url_for</span>(<span class="hljs-name">post.next.path</span>) &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;next&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">post.next.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">-          </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">post.prev.title</span> &#125;&#125;</span><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-chevron-right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="xml">+          </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">post.next.title</span> &#125;&#125;</span><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-chevron-right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="xml">      &#123;% endif %&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">&#123;% endif %&#125;</span><br></code></pre></td></tr></table></figure><h2 id="修改博客字体"><a href="#修改博客字体" class="headerlink" title="修改博客字体"></a>修改博客字体</h2><p>在 <a href="https://www.google.com/fonts">Google Fonts</a> 上找到心仪的字体，然后在主题配置文件中为不同的应用场景配置字体：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">themes\next\_config.yml</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span><br>  <span class="hljs-attr">host:</span><br><br>  <span class="hljs-comment"># 全局字体，应用在 body 元素上</span><br>  <span class="hljs-attr">global:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">family:</span> <span class="hljs-string">Monda</span><br><br>  <span class="hljs-comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span><br>  <span class="hljs-attr">headings:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">family:</span> <span class="hljs-string">Roboto</span> <span class="hljs-string">Slab</span><br><br>  <span class="hljs-comment"># 文章字体</span><br>  <span class="hljs-attr">posts:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">family:</span><br><br>  <span class="hljs-comment"># Logo 字体</span><br>  <span class="hljs-attr">logo:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">family:</span><br><br>  <span class="hljs-comment"># 代码字体，应用于 code 以及代码块</span><br>  <span class="hljs-attr">codes:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">family:</span><br></code></pre></td></tr></table></figure><h2 id="侧边栏放左边"><a href="#侧边栏放左边" class="headerlink" title="侧边栏放左边"></a>侧边栏放左边</h2><p>Next 主题各系列中只有 Pisces 和 Gemini 支持通过主题配置文件来将侧边栏置于左侧或右侧，而 Muse 和 Mist 则需要深度修改源码才能实现改变侧边栏位置。</p><p>在自定义样式文件中添加如下规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">themes</span>\<span class="hljs-selector-tag">next</span>\<span class="hljs-selector-tag">source</span>\<span class="hljs-selector-tag">css</span>\_<span class="hljs-selector-tag">custom</span>\<span class="hljs-selector-tag">custom</span><span class="hljs-selector-class">.styl</span><br><span class="hljs-selector-class">.sidebar-toggle</span> &#123;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">themes\next\source\js\src\motion.js<br>$(<span class="hljs-built_in">document</span>)<br>  .on(<span class="hljs-string">&#x27;sidebar.isShowing&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    NexT.utils.isDesktop() &amp;&amp; $(<span class="hljs-string">&#x27;body&#x27;</span>).velocity(<span class="hljs-string">&#x27;stop&#x27;</span>).velocity(<br>-     &#123;<span class="hljs-attr">paddingRight</span>: SIDEBAR_WIDTH&#125;,<br>+     &#123;<span class="hljs-attr">paddingLeft</span>: SIDEBAR_WIDTH&#125;,<br>      SIDEBAR_DISPLAY_DURATION<br>    );<br>  &#125;)<br>  .on(<span class="hljs-string">&#x27;sidebar.isHiding&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &#125;);<br>  ...<br>  hideSidebar: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>-   NexT.utils.isDesktop() &amp;&amp; $(<span class="hljs-string">&#x27;body&#x27;</span>).velocity(<span class="hljs-string">&#x27;stop&#x27;</span>).velocity(&#123;<span class="hljs-attr">paddingRight</span>: <span class="hljs-number">0</span>&#125;);<br>+   NexT.utils.isDesktop() &amp;&amp; $(<span class="hljs-string">&#x27;body&#x27;</span>).velocity(<span class="hljs-string">&#x27;stop&#x27;</span>).velocity(&#123;<span class="hljs-attr">paddingLeft</span>: <span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-built_in">this</span>.sidebarEl.find(<span class="hljs-string">&#x27;.motion-element&#x27;</span>).velocity(<span class="hljs-string">&#x27;stop&#x27;</span>).css(<span class="hljs-string">&#x27;display&#x27;</span>, <span class="hljs-string">&#x27;none&#x27;</span>);<br>    <span class="hljs-built_in">this</span>.sidebarEl.velocity(<span class="hljs-string">&#x27;stop&#x27;</span>).velocity(&#123;<span class="hljs-attr">width</span>: <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-attr">display</span>: <span class="hljs-string">&#x27;none&#x27;</span>&#125;);<br><br>    sidebarToggleLines.init();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="个性化回到顶部"><a href="#个性化回到顶部" class="headerlink" title="个性化回到顶部"></a>个性化回到顶部</h2><p>原理很简单，将 back-to-top 按钮添加图片背景，并添加 CSS3 动效即可。</p><p>首先，找到自己喜欢的图片素材放到 source\images\ 目录下。然后在自定义样式文件中添加如下代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss">themes\next\source\css\_custom\custom<span class="hljs-selector-class">.styl</span><br><span class="hljs-comment">//自定义回到顶部样式</span><br><span class="hljs-selector-class">.back-to-top</span> &#123;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">60px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70px</span>;  <span class="hljs-comment">//图片素材宽度</span><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">900px</span>;  <span class="hljs-comment">//图片素材高度</span><br>  <span class="hljs-attribute">top</span>: -<span class="hljs-number">900px</span>;<br>  <span class="hljs-attribute">bottom</span>: unset;<br>  <span class="hljs-attribute">transition</span>: all .<span class="hljs-number">5s</span> ease-in-out;<br>  <span class="hljs-attribute">background</span>: url(<span class="hljs-string">&quot;/images/scroll.png&quot;</span>);<br><br>  <span class="hljs-comment">//隐藏箭头图标</span><br>  &gt; <span class="hljs-selector-tag">i</span> &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>  &#125;<br><br>  &amp;<span class="hljs-selector-class">.back-to-top-on</span> &#123;<br>    <span class="hljs-attribute">bottom</span>: unset;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">100vh</span> &lt; (<span class="hljs-number">900px</span> + <span class="hljs-number">200px</span>) ? calc( <span class="hljs-number">100vh</span> - <span class="hljs-number">900px</span> - <span class="hljs-number">200px</span> ) : <span class="hljs-number">0px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="站点访问量统计"><a href="#站点访问量统计" class="headerlink" title="站点访问量统计"></a>站点访问量统计</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">在页脚布局模板文件首行添加如下代码：</span><br><span class="hljs-string">themes\next\layout_partial\footer.swig</span><br><span class="hljs-string">&lt;script</span><br>  <span class="hljs-string">async</span><br>  <span class="hljs-string">src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span><br><span class="hljs-string">&gt;&lt;/script&gt;</span><br><br><span class="hljs-string">在主题配置文件中做出如下修改：</span><br><span class="hljs-string">themes\next_config.yml</span><br><span class="hljs-attr">busuanzi_count:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">total_visitors:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 访客数</span><br>  <span class="hljs-attr">total_visitors_icon:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">total_views:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 访问量</span><br>  <span class="hljs-attr">total_views_icon:</span> <span class="hljs-string">eye</span><br>  <span class="hljs-attr">post_views:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">post_views_icon:</span> <span class="hljs-string">eye</span><br></code></pre></td></tr></table></figure><p>刷新浏览器即可生效。</p><p>高阶用法：通过修改代码来自定义统计文案，如果你想使用本站统计文案，需要对不蒜子的代码做出如下修改：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">themes\next\layout_third-party\analytics\busuanzi-counter.swig</span><br><span class="xml"> &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="xml">-   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site-uv&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">__</span>(<span class="hljs-name">&#x27;footer.total_visitors&#x27;</span>) &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">+   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site-uv&quot;</span>&gt;</span></span><br><span class="xml">+     </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">__</span>(<span class="hljs-name">&#x27;footer.total_visitors&#x27;</span>, <span class="hljs-string">&#x27;&lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&#x27;</span>) &#125;&#125;</span><br><span class="xml">-     <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">theme.busuanzi_count.total_visitors_icon</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="xml">-     <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;busuanzi-value&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  &#123;% endif %&#125;</span><br><br><span class="xml">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="xml">-   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site-pv&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">__</span>(<span class="hljs-name">&#x27;footer.total_views&#x27;</span>) &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">+   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;site-pv&quot;</span>&gt;</span></span><br><span class="xml">+     </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">__</span>(<span class="hljs-name">&#x27;footer.total_views&#x27;</span>, <span class="hljs-string">&#x27;&lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;&#x27;</span>) &#125;&#125;</span><br><span class="xml">-     <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-</span></span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">theme.busuanzi_count.total_views_icon</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="xml">-     <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;busuanzi-value&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  &#123;% endif %&#125;</span><br></code></pre></td></tr></table></figure><p>在自定义样式文件中添加如下样式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">themes<span class="hljs-regexp">/next/</span>source<span class="hljs-regexp">/css/</span>_custom/custom.styl<br><span class="hljs-regexp">//</span>修改不蒜子数据颜色<br>.busuanzi-value &#123;<br>  color: <span class="hljs-comment">#1890ff;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改统计表述文案：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">themes\next\languages\zh-CN.yml<br><span class="hljs-symbol">footer:</span><br><span class="hljs-symbol">  total_views:</span> <span class="hljs-string">&quot;历经 %s 次回眸才与你相遇&quot;</span><br><span class="hljs-symbol">  total_visitors:</span> <span class="hljs-string">&quot;我的第 %s 位朋友，&quot;</span><br></code></pre></td></tr></table></figure><h1 id="添加自定义html页并引用"><a href="#添加自定义html页并引用" class="headerlink" title="添加自定义html页并引用"></a>添加自定义html页并引用</h1><ol><li><p>新建一个page，命名为assets文件夹</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> assets<br></code></pre></td></tr></table></figure></li><li><p>在assets文件夹下创建html文件，命名为index.html，并在文件头部添加跳过渲染代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">layout:</span> <span class="hljs-literal">false</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li><li><p>以markdown引用链接形式引用，默认在根目录，用相对路径引用</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;% btn /assets, title %&#125;<br>[title](/assets)<br></code></pre></td></tr></table></figure></li></ol><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://yearito.cn/">yearito的博客</a>:基本上涵盖了大部分美化内容，我搬运过来方便查看以及避免这么好的内容失联。另外有很多好的优化我没有采用，因为太耗时间了。想偷懒的伙伴可以git clone源码，但是不熟悉源码的修改就没办法自定义了，网站有时候会在不经意间挂掉。</p>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我认识的世界是怎样的</title>
    <link href="/2020/01/24/%E6%88%91%E8%AE%A4%E8%AF%86%E7%9A%84%E4%B8%96%E7%95%8C%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/"/>
    <url>/2020/01/24/%E6%88%91%E8%AE%A4%E8%AF%86%E7%9A%84%E4%B8%96%E7%95%8C%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="我认识的世界是怎样的"><a href="#我认识的世界是怎样的" class="headerlink" title="我认识的世界是怎样的"></a>我认识的世界是怎样的</h1><blockquote><p>“One’s real value first lies in to what degree and what sense he set himself<br>lies in to lies.”<br>“一个人的真正价值，首先决定于他在什么程度上和在什么意义上从自我解放出来。”<br>——爱因斯坦</p></blockquote><p>经过数天对哲学史的粗略学习，虽只触及这些划时代人物思想的皮毛，但也受益匪浅。这些东西并没有跳出我的认知，可我有一种前所未有的明白了我周围的事物的感觉。</p><p>我先粗略叙述一下我认为的西方对世界的认识过程：人类最初利用神话解释一切，随着物质条件的逐渐丰厚，开始思考世界本身，试图剥离神来认识世界。为了建立对世界的认知体系，发展了两个分支。一个是亚里士多德利用数学和逻辑学构建世界的关系，一个是柏拉图的理性加感性构造的世界。从罗马帝国逐渐基督化，宗教理性化变成信仰，信仰转化为知识，基督教基于柏拉图主义构建基督哲学，人们接受了这样的客观唯心主义，并发展了基于宗教的经院哲学。历史的车轮滚滚向前，大量思想者区分了神学真理和哲学真理，启蒙运动文艺复兴促成了经院哲学快速衰落。人们开始从认知论研究，发展了理性主义与经验主义。人们基于理性主义和经验主义又发展对世界本质的思考，唯心主义与唯物主义迅猛发展。而到了当代甚至以后，都不会有严格的唯心唯物的区分，人们对形而上学的问题不置一词也没法定论，科学的发扬让我们确立了更好的方法认识世界，改造世界，创造世界。</p><p>基于这些认识，我把认识的世界划分为三个范畴，形而上学，科学，哲学。</p><h1 id="形而上学"><a href="#形而上学" class="headerlink" title="形而上学"></a>形而上学</h1><p>形而上学有很多解释，我这里指研究存在和事物本质的问题。《易经》的解释为：“形而上者谓之道，形而下者谓之器”。比如：</p><ul><li>宇宙最基本的组成是什么？</li><li>意识和物质是怎么样的关系？</li><li>到底有没有上帝，有没有神？</li></ul><p>这样的问题对我而言意义不大，它只存在于信念之中，不能被理性完全可靠的证明。或者说只能随着科学的发展，人们对世界的描述越来越深入，总有一天能企及理想的彼岸，但目前人类的认知水平是绝不能窥探到宇宙的终极奥义。</p><p>在这方面我认为的有几位里程碑式的人物，古希腊的柏拉图，近代的培根和笛卡尔，之后古典哲学时期的康德，现代哲学的罗素，胡塞尔。总的来说我认为我们没必要找到宇宙的规律，我们要建立的只是我们认识世界的规律。我们认识是什么，它就是什么，直到通过经验证明它是错的而建立新的规律。这样的研究思考才有意义，不然形而上学的问题入无源之水。因此，在科学未发展至一定程度时，讨论形而上学问题无异于以卵击石，没有什么意义。</p><p>退而求其次，我作为一个普通人，能认识世界现有的东西都极其困难，甚至穷其一生也没法理解现代文明的方方面面，又怎敢遑论这样的问题呢？唯一能做的就是放弃这种问题。</p><h1 id="科学"><a href="#科学" class="headerlink" title="科学"></a>科学</h1><p>根据维基百科，科学是一种系统性的知识体系，它积累和组织并可检验有关于宇宙的解释和预测。强调预测结果的具体性和可证伪性。可证伪性理解为：科学只谈论可实证的概念，一切不可实证的东西都毫无意义。科学与之前的理论的根本区别是没有先验条件，只要有一例反例即可推翻。通过提出问题——作出假设——实验观测——得出结论来解释观测。也就是说科学本身你也不能证明它是对的，但它符合实验观察，具有普遍性和广泛性。同时它是在不断发展的，以求建立普遍和广泛的理论，科学最伟大的精神便是自我批判。</p><p>科学利用的工具叫科学方法，任何研究方法要被视为科学方法，则必须是客观的（科学家们不能对于科学方法下产生的单一结果有不同的解释且研究时不能故意去改变结果的发生）。另一项基本期待，则是必须有完整的资料文件以供佐证，以及研究方法必须由第三者小心检视，并且确认该方法能重制。而研究这样方法的我认为是数学思想和逻辑学。</p><p>科学分为三大分支:<strong>形式科学</strong>（如逻辑、数学、理论计算机科学），研究抽象概念；<strong>自然科学</strong>（如生物学、化学、物理学、地理学），在最宽泛的意义上研究自然；以及<strong>社会科学</strong>（如经济学、心理学、社会学），研究个体与社会。不过，对于形式科学能否确实算作一类科学存在不同意见，因为其并不依赖经验证据。而运用既有科学知识以达成实用目的的学科，如工程学和医学，则被归为<strong>应用科学</strong>.具体的研究子领域可参见维基百科的<a href="https://zh.wikipedia.org/zh-hans/%E5%AD%A6%E6%9C%AF%E9%A2%86%E5%9F%9F%E5%A4%A7%E7%BA%B2">学术领域大纲</a>。</p><p>科学是我们认识事物的方法，通过对观察到的事物进行归纳验证得到规律。通过规律推导定律进而发现更多规律。在现代文明的建设之中，可以基本确信的是科学这个发展方向是历史主流，大势所趋。在已知认识论中最好的方法就是科学，因此从科学的角度出发，可以无视宗教，泛神论这些不具有可证伪性的东西。 </p><h2 id="科学与宗教"><a href="#科学与宗教" class="headerlink" title="科学与宗教"></a>科学与宗教</h2><p>科学强调的是具体性和可证伪性，而宗教信奉叫”大道至简“。我听过一个这样的对话：佛教早就预言了宇宙包含星系，星系包含星球，星球包含生物，根据佛教中：“一千个小千世界，叫做“中千世界”；一千个中千世界，叫做“大千世界”。一个大千世界，因为它里面有小千、中千、大千，我们称其作“三千大千世界”。”。他对世界的解释不具体，预言的事实和事实有出入时，会以各种各样的方式自圆其说。但宗教的存在是否没有意义呢？显然不是，先不说人类的信仰问题，就这模棱两可的语言兴许可以挖掘出一些灵感。宗教的存在类似于理性与感性，一味掉入以科学解释任何东西而忽略人的主观感受有点冷冰冰的感觉。对于人类这种虚无的精神需求在树立科学的认识观之后可以用宗教建立信仰，不过现当代人我认为最好建立自我信仰，美术，音乐，运动这些艺术类的东西完全能满足精神世界的表达和需求。</p><h1 id="哲学（价值理论）"><a href="#哲学（价值理论）" class="headerlink" title="哲学（价值理论）"></a>哲学（价值理论）</h1><p>对于哲学来说，科学的光芒掩盖了它，甚至由于量子理论的发展，科学已经大大超越了哲学。但科学研究的是可实证的问题，大量的无法实证的命题不但存在，而且有非常重要的意义。如美学，伦理，道德，信仰等，难道我们就放弃这些了吗？在科学之外的领域我认为是价值理论，我理解的哲学就是研究这一范畴的，这和其他地方也许会有很大的出入。哲学对我来说是一种心理活动（activity），这种想法来自爱丁堡大学的<a href="https://www.coursera.org/learn/zhexue-daolun/">《哲学导论》</a>，他是这么叙述哲学的。</p><blockquote><p>philosophy is the activity of working out the right way of thinking about things.<br>哲学是想出正确思考事物的一种活动。</p></blockquote><p>这个定义妙就妙在它把哲学定义为一种活动，这非常适合我所叙述的美学，道德这些领域。这些东西受到个人的家庭背景，受教育程度，喜好等影响，不容易形成普遍广泛的理论，不能单单用科学来解释。而生活中很多问题也出在这里，比如：如何谈恋爱？如何成为一个高情商的人？我和婆婆的关系如何处理?有的人就会有疑问——那社会科学解决的问题不也是存在巨大的个体差异吗？个体差异固然存在，但个体之间整合成集体会有一个整体趋势，也就是”大势“，因此社会科学研究的基本单位不是个体，而是一个整体。不然无法证伪也称不上科学。</p><p>个人的价值理论这样的问题我提倡多实践或者多进行哲学这样的活动，这类似于游泳，驾驶等技能，需要经验学习。有的人天赋异禀很快上手自然很少提这些问题，而有的人可能资质平平便需要花很多时间学习。你大可学习有经验的人提供经验，但每个人的资质不同具有很多不确定因素。我的建议是不要花大量时间在寻找经验上，而是主动获取经验。不会谈恋爱就疯狂谈恋爱，从中吸取经验不断总结改进。这些问题大可不用求教他人，这实在没办法形成知识体系，不然早就有体系了。</p><p>我当初最爱问的问题还有:我如何找到人生的意义，这也是价值理论。存在主义列举了数十种人生意义：</p><ol><li><p>利他主义：你上有八十岁老母，下有嗷嗷待哺的孩子</p></li><li><p>给予和付出：对别人有益，让世界更美好。</p></li><li><p>为理想奉献：顾名思义</p></li><li><p>创造：发明创造，享受创造的乐趣</p></li><li><p>享乐主义：生来就是为了享乐，看遍大千世界</p></li><li><p>自我实现：儿时梦想是当科学家</p></li><li><p>自我超越：当了科学家之后</p></li></ol><p>你说他错了吧，也没有，但是当时读完就认为人生也就那样吧。对于这个问题其根本就是满足感，没有理论告诉你这样在某种程度上是一定正确的，价值理论这种因人而异的问题除了自己实践，自己体验，别无他法。这也造就了每个人都有独立的人格，也是世界多样性与不可测性的具体体现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我把我对世界的认识记录了下来，他没有打破我原先的认知体系，但我更加明了了。每当我看到一个问题，或者要不要与人争论，我要思索的是归类，对于科学问题可以争论，但对于价值判断问题永远不会有结果，顶多能互相交流，吸取经验，至于其它问题就更没意义了。我接下来的目标也比较明确了，要认识世界，一个是继承科学，在深度方面，科学最重要的工具是逻辑学和数学思想，我会继续学习。在广度方面，有百科全书《牛津通识读本》，这是人类的财富结晶，也许是目前我知道的最好的学习渠道。另一个是学习自我的“价值理论”，这需要我努力大胆的尝试各种东西，体会我认为是正确的，最美的，最满足的活动，从而形成自己的价值体系。</p><p>最后，要说我信什么体系，那我当然信的是有中国特色的社会主义理论体系啊！</p>]]></content>
    
    
    <categories>
      
      <category>世界观</category>
      
    </categories>
    
    
    <tags>
      
      <tag>世界观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>香港乱局的起源,演变及趋势</title>
    <link href="/2019/12/30/%E9%A6%99%E6%B8%AF%E4%B9%B1%E5%B1%80%E7%9A%84%E8%B5%B7%E6%BA%90,%E6%BC%94%E5%8F%98%E5%8F%8A%E8%B6%8B%E5%8A%BF/"/>
    <url>/2019/12/30/%E9%A6%99%E6%B8%AF%E4%B9%B1%E5%B1%80%E7%9A%84%E8%B5%B7%E6%BA%90,%E6%BC%94%E5%8F%98%E5%8F%8A%E8%B6%8B%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="香港乱局的起源-演变及趋势"><a href="#香港乱局的起源-演变及趋势" class="headerlink" title="香港乱局的起源,演变及趋势"></a>香港乱局的起源,演变及趋势</h1><p>对于这种问题，我比较倾向于结合完整的事件发展看待问题。割裂的读一些新闻自媒体既容易被“洗脑”，又缺乏对事物的合理认识，很难形成大局观看待事物发展趋势。借助此次机会，收集整理香港乱局的起源，历史大背景，社会背景，以期加深对此次事件的认识，结合网上对此事的评价，说法，总结自己的收获。</p><p>网上对此问题众说纷纭，大致有这几种比较合理的说法：</p><ul><li>香港问题由来已久，从历年的七一游行（香港七一游行是香港自主权移交以来最为持续的大型活动之一）自03年起游行人数上万，以及游行口号可以看出，这是中国大陆与香港的矛盾，为了所谓的民主，自由，而实际上是对西方普世价值的盲目崇拜。</li><li>政治因素：香港政府自97年回归后，主要权力领导集团依然直接或间接受到外国势力的影响。尤其是美国CIA势力的侵入，意图通过扰乱香港，争取美国利益，挽救CIA在美国本土的颓势。</li><li>文化因素：由于历史原因，中国和香港历史严重割裂，从政治制度到语言文字都有巨大差异。自97年回归以来，在通识教育以及高等教育存在重大问题。</li><li>经济因素：香港房地产泡沫，产业结构单一，错失发展先进制造业的机遇，民生问题不好调解。</li></ul><p>参考：</p><ul><li>维基词条：<a href="https://zh.wikipedia.org/wiki/%E4%B8%83%E4%B8%80%E9%81%8A%E8%A1%8C#2019%E5%B9%B4">https://zh.wikipedia.org/wiki/七一遊行#2019年</a>，<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%8B%E5%A4%A7%E9%99%B8%E8%88%87%E9%A6%99%E6%B8%AF%E7%9F%9B%E7%9B%BE">https://zh.wikipedia.org/wiki/中國大陸與香港矛盾</a></li><li>陈平，中国经济学家、理论物理学家，自称研究经济问题的物理学家。北京大学国家发展研究院（前身中国经济研究中心）教授、博士生导师（2013年退休）<a href="https://www.bilibili.com/video/av74031654">https://www.bilibili.com/video/av74031654</a></li><li>宁南山：从产业和教科书看个人与香港的前途命运<a href="https://www.zhihu.com/people/ningnanshan/posts">https://www.zhihu.com/people/ningnanshan/posts</a></li></ul><h1 id="运动过程"><a href="#运动过程" class="headerlink" title="运动过程"></a>运动过程</h1><p><em>发起初期</em></p><ul><li>3月15日，香港众志多名成员在政府总部抗议修订《逃犯条例》，其间有示威者进入政府总部内东翼大堂静坐，最终有9人被警方以“强行进入罪”拘捕，这是反修例运动首次有人被捕。</li><li>3月31日，民间人权阵线发起反对《逃犯条例》修订草案的首场游行。大会统计共有1.2万人参与，警方称高峰期有5,200人。</li><li>4月28日，民间人权阵线第二次发起反对修订草案的游行。民间人权阵线称有13万人参加，警方指最高峰有2.28万人，皆创下2014年雨伞革命以来的民主派游行纪录，亦创下林郑月娥上任以来的纪录。</li><li>6月9日，民间人权阵线再度发起示威游行，抗议修订草案。大批身穿白衣的市民参与，民间人权阵线表示有103万人，警方指高峰有24万人。</li><li>6月12日，立法会预定恢复修订草案的二读审议，大量示威者围堵、占领金钟立法会综合大楼周边道路抗议，高峰时逾4万人参与，其后引发暴力冲突。</li><li>6月15日，反对《逃犯条例》修订草案的梁凌杰坠楼自杀身亡.</li><li>6月18日，林郑月娥就修订草案公开道歉，拒用“撤回”字眼，并暗示不会辞职。</li><li>6月30日，立法会议员何君尧发起“630撑警察，保法治，护安宁”集会。大会称有16.5万人出席，警方称最高峰有5.3万人。</li></ul><p><em>冲突升级</em></p><ul><li>7月1日，立法会冲突。</li><li>7月3日,特首邀大专学生会闭门会议。</li><li>7月14日，沙田区游行，无线电视商场活动被狙击.</li><li>7月20日，警捣破“爆炸品仓库”，“藤条教仔”论。</li><li>7月21日，港岛区游行，元朗袭击事件。</li><li>7月28日，大批示威者在集会后前往中央人民政府驻香港特别行政区联络办公室，投掷砖块与竹枝，以及在多处纵火。</li></ul><p><em>陷入僵持</em></p><ul><li>8月2日，公务员参与“公仆仝人，与民同行”集会。</li><li>8月3日，市民发起“旺角再游行”，一队按原定路线游行，数百名示威者则“快闪”堵塞海底隧道、向尖沙咀警署丢掷砖块，黄大仙区街坊则包围警车，警方在三区施放催泪弹。</li><li>8月4日，示威者在将军澳、西区集会，“快闪”方式与警方对峙，一度瘫痪海底隧道。示威者放火焚烧杂物，警方在铜锣湾发射催泪弹</li><li>8月11日，示威者在深水埗及铜锣湾集会游行，其后冲突扩散至尖沙咀、葵涌等。对峙双方升级武力，警署遭投掷汽油弹，警方在港铁葵芳站施放催泪弹、又在港铁太古站内近距离约2米向示威者发射胡椒弹，并有乔装人士参与拘捕，亦有示威者怀疑遭射中而眼球破裂。</li><li>8月12日，逾1万名抗议人士至机场举行“警察还眼”大规模集会活动，大批人群堵塞离境大堂，导致机场停摆瘫痪。</li><li>8月20日，林郑月娥承诺马上构建民间对话平台化解分歧矛盾，并扩大独立监察警方处理投诉委员会审视。8月21日，示威者在元朗站静坐，晚间演变成警民对峙。</li><li>8月23日，林郑月娥与前官员会谈，呼吁抗议者“解开死结”。</li><li>8月31日，游行后的示威者最少在6区纵火，警方出动人群管理特别用途车，并在维多利亚公园开枪示警。</li></ul><p><em>政府退让</em></p><ul><li>9月1日，示威者阻塞机场道路、机场快线交通，影响大批旅客。之后示威者在东涌站毁损设施与射水，再徒步撤退至青马大桥。</li><li>9月4日，林郑月娥提出四项行动回应五大诉求，将正式动议撤回修订《逃犯条例》草案，并将到基层与市民对话。</li><li>9月6日，数百名市民要求港铁公开闭路电视片段，之后在太子站和旺角站爆发冲突。</li><li>9月16日，政策创新与统筹办事处成立“对话办公室”，由创新及科技局前常任秘书长卓永兴担任总监，以协调特首早前提出成立的对话平台。</li><li>9月28日，阿里巴巴集团旗下的《南华早报》引述消息指，行政长官林郑月娥宣布正式撤回条例草案前，曾经请示中共总书记习近平，并得到其批准，引起外界对中共当局直接插手香港事务的质疑。</li></ul><p><em>暴力升级</em></p><ul><li>10月1日，是中华人民共和国建国70周年，香港多区爆发大规模冲突和暴力破坏，多个商场及店铺都要关门，多个港铁站亦先后宣布关站，多区造成了严重破坏。警方在下午四时许在荃湾海坝街一带清场期间，有一名18岁示威者曾志健被警方近距离以实弹枪击，左胸口中枪倒地，随后送往玛嘉烈医院进行治疗，警方稍后承认有示威者中弹受伤。这是反对逃犯条例修订草案运动大规模爆发后三个月来警方首度以实弹枪击击伤示威者。</li><li>10月3日，多区继续发生冲突，大批穿黑衣人包括在荃湾、铜锣湾、将军澳、屯门、黄大仙等地，先以杂物堵路，进而展开破坏行动，所到之处交通灯、栏杆被毁，中资或被指爱国人士所持的店铺逐一被毁。</li><li>10月4日，香港特区政府行政会议召开特别会议，处理“禁蒙面法”问题。</li><li>10月4日至10月9日期间，美国多个界别就示威活动表态。先是NBA休斯顿火箭队总经理达雷尔·莫雷表态支持香港示威，遭到内地官媒及网民批评。及后香港电竞选手“聪哥”因高呼“光复香港，时代革命”的口号而被暴雪娱乐取消资格、没收奖金以及停赛。继而苹果公司在中国《人民日报》的施压下，宣布将提供显示警队位置的“HKmap.live”应用程序下架。</li><li>10月中旬起，外界认为示威运动开始缓和，人数开始减少，运动的冲突亦由街道转至立法会等处。不过警民双方的武力程度并没有减低，尤其警方在10月13日发现土制炸弹，乃运动以来首次。</li><li>10月10日，香港市民自发庆祝中华民国国庆日，多处可见青天白日满地红。同日晚上，中文大学举行对话会，女学生吴傲雪发言时除口罩，声称警方性暴力和希望校长谴责警方暴行。校长段崇智最终在同月18日发声明谴责警暴，随即引起前行政长官梁振英和中国的《人民日报》抨击。</li><li>10月20日，九龙游行中警方水炮车向尖沙咀清真寺正门喷射蓝色水剂，事后警方于社交平台Facebook表示误中清真寺的正门及大闸，正联络清真寺首席教长及穆斯林社区领袖解释事件及表达关注。</li><li>10月18日，触发是次运动的台湾杀人案疑犯陈同佳决定自首，希望特区政府安排手续，但台湾拒绝陈同佳入境，令港台关系紧张。</li><li>10月23日上午九时正，陈同佳结束服刑，离开壁屋监狱，逾百名记者在场通宵守候。陈同佳先后鞠躬向死者潘晓颖的家属和香港人道歉，并表示将会到台湾自首。但因为港台关系持续紧张，因此陈同佳或会在2020年总统选举后才会前往台湾。陈同佳出狱当日，保安局局长李家超在立法会上，正式宣布撤回《2019年逃犯及刑事事宜相互法律协助法例（修订）条例草案》，此时距离法案的公布已经将近10个月。</li></ul><p><em>示威激化</em></p><ul><li>11月3日，太古城中心内有市民自发举行人链活动，超过100人响应，分批站在商场不同楼层，亮起手机灯光，高叫口号和唱歌，并在六时许拉起人链，在商场内围绕一圈，有部分商户关门。晚上7时35分左右，一名操普通话的灰衣男子因政见问题，由太古城中心地下冲出，并在马路撞击一名女子，女子被撞倒地，赵家贤在场尝试调停，但男子不但没有理会，更再举脚踢女士的头部。灰衣男子其后在太古城中心商场地面出口与人争吵，曾叫喊“光复台湾”，继而持刀袭击抗议人士。其中两人分别背部和脚部受伤，大量流血。当区的太古城西区议员赵家贤更被灰衣男咬掉耳壳，同告受伤。在将军澳，约晚上11时有人于尚德广场附近天桥聚集，有警察到场并射胡椒喷剂，之后在唐明街及唐俊街的十字路口有防暴警察组成防线，与尚德邨对面的示威者对峙，并发射44枚催泪弹驱散在场人士。当中一名于香港科技大学就读的青年被发现倒卧在停车场2楼，怀疑从3楼堕下，昏迷送院抢救，留医伊利沙伯医院深切治疗部，情况危殆，后不治身亡。</li><li>11月11日，网民发动“黎明行动”和“大三罢”，号召示威者晨7时起瘫痪交通，务求导致不参与的市民无法上班上学，“被罢工”、“被罢课”，多处地方有人堵路、阻碍港铁运作，令全港交通大混乱。早上时分，西湾河有交通警察向手无寸铁示威者开三枪实弹，导致两人重伤。其中一名21岁男子的右肾及部分肝脏受创需要切除，翌日才由危殆转为严重。同日葵芳有交通警察三度撞向示威者，至少两人受伤，当日被暂停职务、即时休假并接受调查。另外马鞍山有示威者与支持政府的男子爆发肢体冲突，及后被淋泼怀疑易燃液体并点火，该男全身即时陷入火海，男子最终危殆。双十一冲突最终导致至少99人受伤送院，其中2人危殆、4人严重。</li></ul><p>参考：<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%8D%E9%80%83%E7%8A%AF%E6%A2%9D%E4%BE%8B%E4%BF%AE%E8%A8%82%E8%8D%89%E6%A1%88%E9%81%8B%E5%8B%95">https://zh.wikipedia.org/wiki/反對逃犯條例修訂草案運動</a></p><h1 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h1><h2 id="主权"><a href="#主权" class="headerlink" title="主权"></a>主权</h2><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/%E9%A6%99%E6%B8%AF%E4%B9%B1%E5%B1%80%E7%9A%84%E8%B5%B7%E6%BA%90,%E6%BC%94%E5%8F%98%E5%8F%8A%E8%B6%8B%E5%8A%BF_2.png" alt="/香港乱局的起源,演变及趋势/Untitled1.png"></p><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><h3 id="第三方势力及反中势力的肆意妄为"><a href="#第三方势力及反中势力的肆意妄为" class="headerlink" title="第三方势力及反中势力的肆意妄为"></a>第三方势力及反中势力的肆意妄为</h3><p>他们利用金钱引诱香港年轻人实现自己的可耻目的！</p><p>这个“地下钱庄”就是美西方反华势力、香港本土反对派势力祸港乱港的金库，其股权关系复杂，具体讲，主要有“一大四小”五个“股东”。</p><p>“一大股东”即为美国的一些非政府组织（简称NGO）及金融资本集团。“大股东”在香港又物色具体的组织及合适的人选充当其“经理人”，构成了其庞大繁杂的“股权体系”。之所以雄踞“大股东”位置，那是因为“修例风波”暴力活动中一半以上的活动资金均来源于此。</p><p>“四小股东”分别为专门成立的612人道支持基金会、香港的大学学生会、香港教会、小团体募捐。</p><p><img src="https://gitee.com/windilycloud/PicGoPictureBed/raw/master/images/%E9%A6%99%E6%B8%AF%E4%B9%B1%E5%B1%80%E7%9A%84%E8%B5%B7%E6%BA%90,%E6%BC%94%E5%8F%98%E5%8F%8A%E8%B6%8B%E5%8A%BF_1.png" alt="Untitled%20862dfe17b5714a83b32e79ee58112bc3/Untitled%201.png"></p><p>参考：共青团中央：<a href="https://mp.weixin.qq.com/s/TGVfCQh9WnZ5NYQXqp49JQ">https://mp.weixin.qq.com/s/TGVfCQh9WnZ5NYQXqp49JQ</a></p><h3 id="法律制度"><a href="#法律制度" class="headerlink" title="法律制度"></a>法律制度</h3><p>1997年以后，中国政府官方人士或机构发表过各种对《基本法》、《中英联合声明》所规定的“一国两制”制度的涵义的看法，在2010年以后，由于这种解释或理解将重心放到“一国”而非“两制”，例如《一国两制白皮书》、中联办主任张晓明的“特首超然论”、中共政治局常委张德江声称中央对特首有“实质任命权”等，这些言论被指引起中国政府对一国两制的实施逐渐偏移香港民众及国际社会对其的理解的疑虑，因此引发部分香港民众的怀疑。港府官员亦发表迎合这些论调的言论，更加加深部分港人对一国两制前景的担忧。《一国两制白皮书》中依照大陆体制，声称香港的法官是行政官员、并要求法官“维护国家主权及安全”、保护中华人民共和国政府利益，被部分人士认为是大陆政府无视受一国两制保护的香港司法独立，并试图改变香港司法、法律界的表态，也引起香港法律界的公开示威游行。中国内地与香港不同的法律体制也引起部分香港人以及法律界人士对一国两制的担忧。根据《基本法》规定，经终审法院提请，中国人大可以对基本法作出司法解释。而此机制在实际实施中，曾被香港政府用作使用行政手段推翻法庭终审判决的方法，因此引起部分人士对一国两制下香港司法权独立是否得到保障的担忧。其中，2016年的第五次人大释法是在香港法庭及政府没有要求的情况下，由全国人大主动进行的，其结果是直接影响了当时正在进行的具有政治色彩的香港法律案件的结果，因此在香港及国际上普遍认为代表了中国中央政府对香港的自治地位及司法独立的进一步干涉，加剧了部分香港人以及法律界人士对中央政府维持一国两制的意愿的担忧，并引起香港法律界罕见的公开示威游行。</p><h3 id="选举制度"><a href="#选举制度" class="headerlink" title="选举制度"></a>选举制度</h3><p>根据《香港特别行政区基本法》第45条规定：香港特别行政区行政长官在当地通过选举或协商产生，由中央人民政府任命。行政长官的产生办法根据香港特别行政区的实际情况和循序渐进的原则而规定，最终达至由一个有广泛代表性的提名委员会按民主程序提名后普选产生的目标。由此，香港特区政府曾相继提出过2007年及2008年香港政治制度改革以及2012年香港政治制度改革提议，其中后者落实了一部分改革措施，但尚未达到普选的目标。在普选问题上具体的改革方案上出现了以香港泛民主派为代表的一方、与建制派及中国共产党和香港政府为代表的另一方之间的分歧。分歧主要围绕提名权设置及提名委员会的构成及权限的问题。泛民主派主张在香港实行的普遍选举，是由香港人公民提名、政党提名、提名委员会共同组成，缺一不可。然后直接选举行政长官及香港立法会议席，以落实民主选举制度之两大理念：参政权之“开放参与”和有“真正选择”，以正当程序保障“实质竞争”。而由香港政府所提议、获中国共产党支持的“普选”方案则主张依照基本法规定只有提名委员会有权提名，并且提名委员会的人数、构成和委员产生办法须按照选举委员会的人数、构成和委员产生办法而规定。但特区政府部分人士指出可由公民签名推举候选人交由提名委员会考虑。此举被指在概念和程序上尽量保留中华人民共和国中央政府对选举人、候选人资格、选举程序及当选人任命等方面的控制。民主派所提倡的普选诉求为了与后者之普选方案有所区别，而称作“真普选”。</p><h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><h3 id="香港产业结构及经济地位"><a href="#香港产业结构及经济地位" class="headerlink" title="香港产业结构及经济地位"></a>香港产业结构及经济地位</h3><p>2019年的今天发生的香港暴乱事件，主力军就是香港的学生和年轻人，而这背后是香港的经济发展两极化，年轻人没有出路。</p><p>从薪资分析</p><p>我们从2018年5月-6月香港居民的工资中位数统计就可以看出来，</p><p>男性月工资中位数为19900港币，女性为15300港币，</p><p>每月工资中位数水平为17500港币，大约为15500人民币。</p><p>从行业分析</p><p>一个是香港精英的出路是非常狭窄的，要想拿高薪，只能到金融，地产，医生，老师等行业，而这些行业的雇佣人数是有限的。</p><p>IT业也是高薪行业，但是香港的IT业没有发展起来，无法容纳大量就业，可惜了董建华的数码港规划。</p><p><strong>从香港的中薪行业看，主要是制造业，运输和物流业和美容三个部分。</strong></p><p>这本来应该是支撑香港就业的中流砥柱，而香港恰恰是面临制造业已经坍缩和外流，直接造成了香港经济丧失了大量中薪岗位。另外制造业实际上也是能够创造不少高薪岗位的，这也导致香港的精英在制造业方面基本没有出路。</p><p>香港的运输和物流行业也是中薪行业，目前是依靠做转口贸易，依附于中国大陆和其他地方的制造业生存，但是香港作为转口贸易港口，其地位相对内地城市是在衰落的。</p><p>参考：宁南山：从产业和教科书看个人与香港的前途命运<a href="https://www.zhihu.com/people/ningnanshan/posts">https://www.zhihu.com/people/ningnanshan/posts</a></p><p>对于经济问题，经济学家已经分析的比较透彻了，都有明显的共识，即香港以金融等服务业为主，错失了发展先进制造业的机遇，并且房地产行业泡沫严重等，这里不再赘述。值得一提的是，依我看经济问题对比政治文化问题来说不值一提。 </p><h3 id="移民问题"><a href="#移民问题" class="headerlink" title="移民问题"></a>移民问题</h3><ul><li>双非问题：2001年，香港终审法院根据《基本法》第24条宣判的庄丰源案确立，父母双方皆无香港居留权的中国大陆居民在香港所生子女可享有香港永久性居民身份。终审法院分析入境事务处处长提交的数据，从1997年7月1日至2001年1月31日，只有1,991名在香港出生的中国公民（母亲是非法入境、持双程证或短暂逾期居留香港，父亲也仅是在香港临时居留或不是香港居民）会因为判入境事务处处长败诉而成为香港永久性居民。这类儿童每月约46人，每年约555人。入境事务处处长根据此数据，承认没有迹象显示他被判败诉会导致大批人士立即从内地涌入香港。终审法院分析这些数据，亦不认为判入境事务处处长败诉会令香港承担任何重大风险。在庄丰源案终审判决前，香港特区政府曾经请求终审法院根据《基本法》第158条提请全国人民代表大会常务委员会解释《基本法》，不过终审法院没有采纳。终审法院在2001年7月20日判决政府败诉后，特区政府表示对判决失望，但是会尊重判决及采取适当措施执行判决。当时的香港大律师公会主席梁家杰对港府不绕过终审法院寻求人大释法表示欢迎。随着2003年自由行实施，大量中国大陆孕妇来香港产子。双非人士有从合法途径预约来港产子，亦有在无预约情况下闯急症室产子。2010年，配偶不是香港永久性居民的中国大陆孕妇在香港诞下32,653名婴儿，比起2001年的620名上升逾50倍。从2001年至2011年间，已获居港权的“双非婴儿”超过17万人，造成资源分配问题，例如产妇床位不足，引起香港社会不满，香港市民多次游行抗议，甚至引发了“蝗虫论”的争议。《信报》指，在民怨沸腾下，政府仍在寻求解决措施。至2012年梁振英接任行政长官后，他透过行政措施减少双非问题，但还有人以假结婚破坏此措施</li><li>综援问题： 自2011年起，一篇主题为“四人新移民综援家庭月入2.2万元”的网络文章在香港流传，并附有电视新闻节目的截图，显示锺女士正在接受访问，然而最终被证明是谣言。有评论指出，不少香港人认为新移民抢占了公共资源，相关网络假文会挑动民众情绪，加剧中港矛盾。2013年，社区组织协会的何喜华协助单程证妇人孔允明就申请综援资格案上诉至终审法院，终审法院最后裁定，未居住满“7年”的香港人不能申领综援是违反香港基本法，并命令香港特别行政区政府回复至2004年之前的“1年”申领居港期。此裁决公开后，随即引发大批香港新移民到社会福利署查询及申请。大批香港市民批评，此政策一开，对香港综援制度有巨大的冲击，并且会增加香港的财政负担。据社会福利署提供的数字，2015年四人综援家庭的每月平均综援金额为1.3万元左右。</li></ul><h3 id="民生问题"><a href="#民生问题" class="headerlink" title="民生问题"></a>民生问题</h3><ul><li>基本生活需求及贸易问题：中国官员指：没有中国大陆支持，香港就会变成一座死城[53]，香港人应饮水思源，每日饮水就要感恩。可是事实上，香港购买东江水之实用水价每立方米7.14港元（2016年，未计后续处理成本），被批评比一些国家的海水化淡高昂。</li><li>旅游购物问题：香港发生过多宗导游与大陆旅客因购物而产生冲突的事件，包括：移民导游李巧珍在2010年接待安徽零团费旅行团游客时，不满他们购物少，以普通话大骂陆客；以及香港导游与安徽旅客争执事件等。由于大陆的食品及产品安全问题，以及香港和大陆之间由于税收造成的差价，许多大陆访客在香港大量购买食品和其他物品。其中2008年中国毒奶粉事件后开始，大陆对国产奶粉发生大规模的恐惧，大陆人和香港人大量从香港的零售渠道购买婴幼儿奶粉以满足大陆对进口奶粉的突生需求，香港发生婴幼儿奶粉供不应求的情况、香港人生活受到直接影响。由于香港政府缺乏应对政策，香港民众开始反对大陆访客及香港“水货客”将奶粉运往大陆，催生了“水货客问题”冲突。而另一方面，由于大陆游客的人数以及部分游客的强大购买力，香港一些商家开始视大陆游客而不是香港人为主要服务对象，或者对香港本地顾客实行额外限制，因此引起香港民众不满。包括D&amp;G禁止香港人摄影风波和agnès b.纯用简体字餐牌等事件。</li><li>水货客问题：包括本港居民的水货客从香港利用各种途径运送货物到中国大陆（尤其指向通往深圳边境），引致对香港各区市民的日常生活造成的各种滋扰及社会问题。</li><li>自由行问题：2003年7月28日起，中国中央政府与香港政府按照协议开始开放一些大陆城市居民以个人的方式（即无须参加旅行团或受邀请）赴香港旅行。结果是中国大陆旅游到访香港人次由2002年的638万大幅增加至2013年的4,075万，占当年访港旅客总数的比例由41.2%急升至75%。在2014年初，泛民一些激进党派发起保护“本土价值”运动，其后掀起“反中”情绪，一些激进成员经常在旅游区发起反对陆客的示威。由于一系列反陆客行为和言语在中国大陆网络广泛传播，同年底起，访港大陆客人次持续下跌。旅游业及零售业界认为，反“陆客”言行是成因之一，政府及建制派更直指反“陆客”是访港大陆客人下跌及零售业不景的主因。依据香港旅游发展局和香港政府统计处公布的数字显示，访港旅客人次大跌8.4%；其统计资料里中国大陆旅客人次更下跌9.8%，为384万5273人次；7月的零售业总额为港币376亿元，下跌2.8%。</li></ul><h2 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h2><h3 id="通识教育"><a href="#通识教育" class="headerlink" title="通识教育"></a>通识教育</h3><blockquote><p>通识教育科2009年正式在香港高中推行，之后列入必考。现在香港学生上大学需要考四门：语文、英语、数学和通识，科目重要性可想而知。通识科包括六个单元，即个人成长与人际关系、今日香港、现代中国、全球化、公共卫生以及能源科技与环境。<br>根据环球网的报道，作为四大科目之一的通识课目，居然无须送审，没有统一课本，也没有标准答案，结果成为了宣传政治思想的绝佳工具。<br>具体有哪些问题呢？<br>在脸书上面，有一个香港爱国人士开的“声讨教协”的专栏，里面刊登了香港家长发来的香港中学通识教育的课本图片，请注意，香港不同学校会采用不同的通识课本，这是其中的一本。<br>具备两大特点，一个是对中国大陆的介绍以负面为主；<br>一个是出现大量的错误。<br>我们可以大概的看下，一个是人口一章说，中国人口素质偏低，<br>理由是15岁以上人口平均教育水平仅达初中三年级，只与美国一百年前的水平相若。但这是过时的数据，实际上我国2018年劳动年龄人口（从参加工作到退休）平均受教育年限已经达到10.5年，更为重要的是，我国的中老年人普遍是在上世纪70-90年代受的教育，彼时教育水平时长自然受限制。<br>而中国大陆年轻人的受教育水平大大高于老年人，<br>2018年中国大陆大学毛入学率已经达到48.1%，也就是同龄人中48.1%可以受到大学教育，这在全球范围内已经是极高水准。我们再看第二个例子，大量使用错误和老数据。<br>2019年的今天，居然还说中国大陆农村在收农业税，里面画了一张插图，是一个愁眉苦脸的中国大陆农民，一个人对农民说“本村明年要兴建新政府大楼，故此要多收税费”实际上农业税在2006年1月1日已经取消了，而香港现在居然还在教授此内容，更有趣的是，用的是上世纪90年代和2001-2003年的数据。<br>这显然根本无法体现中国大陆2019年的现状。<br>类似的里面还有大量描述农村三农问题，城乡差距扩大的内容，缺乏正面描述。<br>对于香港学生而言，很容易产生中国大陆农村居民水深火热毫无希望的的感觉。</p></blockquote><p>类似于上面的表述数不胜数，只收录对中国大陆的负面影响，对现在经济腾飞的大陆绝口不提，认为西方国家对中国的报道和信息是完全客观的，不带有立场和偏见的，因此全盘引用。这样毫无根据的一味反华，只是祸害了香港的前途，并且是从“根”上带坏了学生！教科书不经过审核还不够，香港大学，香港城市大学，香港科技大学等知名大学居然存在暗地资助学生的组织！由此可见，香港问题用普通的方法是治标不治本的！</p><h3 id="政治概念"><a href="#政治概念" class="headerlink" title="政治概念"></a>政治概念</h3><p>论者梁亦华指出，一些民主、自由等香港学生认为无可争辩的普世价值，在内地却与失败者（Loser）的贬义联结在一起。情况犹如清末人们认为，主张洋务改革者都是市井无赖和科举失败者一样，从而形成政治概念上的认知鸿沟。</p><h3 id="文物及建筑"><a href="#文物及建筑" class="headerlink" title="文物及建筑"></a>文物及建筑</h3><p>香港政府在1997年后后采取了一些明显的“去殖民”政策，特别是受到来自与中国政府有关联的人士压力后，在2015-2016年“加大力度”“去殖民”，例如拆除邮筒上的历史性英王纹章等。这一类“去殖民”政策没有得到香港民意的一致支持，持反对意见的民众认为这一类政策不尊重香港的历史文化记忆，其目的是迎合北京当局的政治喜好，佐证了一部分民众对当届香港政府将中央政府的政治使命置于香港民意之上的担忧。于此相关，香港政府在1997年后的发展政策中，时有拆除或改造历史建筑的事例，例如拆除历史性的皇后码头，这些发展计划也引起了部分民众较大的反对。虽然文化“去殖民”并非大陆民众造成，但与中国政府政治要求的联系使得“去殖民”政策加剧了一些香港民众对大陆政府及文化的反感及对一国两制前景的担忧。</p><h3 id="传播媒体"><a href="#传播媒体" class="headerlink" title="传播媒体"></a>传播媒体</h3><p>苹果日报</p><p>我们可以看看维基百科对苹果日报的介绍：</p><blockquote><p>《苹果日报》（英语：Apple Daily，1995年6月20日－）为香港上市公司壹传媒旗下繁体中文报纸，由大股东黎智英所创立，香港畅销中文报章之一[4]。<br>政治立场方面，自1997年香港主权移交后，大部分香港传媒基于自身利益而自我审查[5]，淡化涉及中国共产党的负面消息，而《苹果日报》是少数仍然会大力批评中国政府、香港政府及建制派的报章，被普遍认为是香港目前唯一未被“染红”的媒体[6]，因而一直受到中国大陆封禁[7]。2003年5月2日，壹传媒进入台湾市场，发行了《苹果日报》台湾版。2012年11月，壹传媒大股东黎智英计划将在台湾的所有业务出售予辜仲谅，然该计划在2013年3月取消，改为深耕台湾。</p></blockquote><p>我怀着好奇心点进了苹果日报的官网，简直身心都受到了严重污染！这明明就是港独的聚居地，身为在传播媒体，缺乏客观中立，从头的到脚充斥着反中色彩，恶言恶语张口就来，很难想象 这是一种怎么样的存在。而2016年一项来自香港中文大学的调查结果显示，大学生认为最受市民喜爱的新闻机构中，苹果日报的喜爱程度属中等偏高，立场偏本土，真的怀疑香港年轻人到底受了何种蛊惑？这里我就不放相关证据了，有碍观瞻，看过的人都应该视CNN，苹果日报这样的传播媒体为耻辱！</p><p>CNN</p><ul><li>在2008年西藏骚乱中，中华人民共和国政府、中国官方宣传机构CCTV与部分网民指责CNN“采用裁剪照片”，虚构新闻的造假手法编辑其网站内容，部分中国民众对CNN进行了抵制和反击，其中包括中国网民建立的网站Anti-CNN。其后，因部分中国网民抵触心理强烈，在中国网络逐渐开始流行“做人别太CNN”的流行语，及其同名反CNN歌曲《做人别太CNN》，尽管早已有说法“做人不能太CCTV”。CNN记者则表示，裁剪照片是因为技术上无法同时将左右两边包括进去。</li><li>2008年4月9日，CNN在转播北京奥运火炬在旧金山传递时，主持人卡弗蒂曾发表涉中国争议言论，据中国大陆媒体的翻译理解，指“中国产品是垃圾”（原文为junk，废物、垃圾、劣质次品），及指过去五十年里他们（原文为They）基本上一直是一帮暴民和匪徒（原文为goons and thugs）。2008年4月15日，中华人民共和国外交部发言人姜瑜就CNN主持人涉华争议言论，表示“震惊和强烈谴责”，要求CNN和其节目主持卡弗蒂本人收回其言论，并向华人道歉。CNN表示，卡弗蒂所说的“一群无赖和暴徒”指的是中华人民共和国政府，而非中国人民，不过此消息发布后，中华人民共和国政府表示不承认此道歉，再次要求卡弗蒂收回相关言论并向全体中国人民道歉。</li><li>2008年4月19日，数千民众在洛杉矶的CNN大楼门前集会抗议卡弗蒂以及CNN对中国争议言论报导及评论。同日，在亚特兰大的CNN总部门前也有较小规模的抗议。</li><li>2013年10月28日，中国北京天安门广场发生吉普车冲撞金水桥事件，该事件之后被中国警方称为“重大事件”，并称其为北京地区发生的首宗“恐怖袭击事件”。CNN等媒体质疑中方对事件定性，批评中国的民族宗教政策，对涉案者表示同情。随后，中国外交部发言人洪磊称，CNN的有关言论是“对恐怖分子的纵容”，并称美国反对在反恐问题上实行“双重标准”。部分中国网民亦对CNN的有关言论表示不满。</li><li>2019年10月23日，英国警方在埃塞克斯郡某工业园一辆货车货柜内发现39具尸体，生命损失之惨重震惊国际社会。在英国警方未确认死者国籍信息前，北京时间10月25日下午的中国外交部例行记者会上，CNN驻华记者大卫·卡尔弗（David Culver）向外交部发言人华春莹提问时称“本月初中方举行了国庆相关活动。但中国公民却通过这种极端危险的方式离开中国，他们是出于何种动机？”华春莹在表达对死者同情的同时，严厉批评CNN记者先入为主的认定死难者为中国人，质疑其提问出发点有问题，并指这反映出其思想深处或者美国一些媒体的问题，反呛该记者此举究竟是希望得到什么答案。值得关注的是，在卡尔弗提出该问题前，CNN声称中国掐断了其关于“39名中国人死于英国货车”的直播报道，疑似暗示中国当局封锁信息。但实际上该事故在中国互联网上已然获得大量关注，多个关键词《南方日报》29日的一篇评论称，CNN“就是在吃人血馒头”。2019年11月7日，英国警方正式发文表示确认所有死者均为越南人，且已经完成了身份识别。中国网民对CNN立场先行，无视新闻道德的行为表示强烈的谴责，频频在社交网络上要求CNN向中国道歉。登上社交媒体微博的热搜榜。因此环球网批评CNN通过谎言塑造一个政府消极形象的行径。</li></ul><p>另外还有纽约时报，华尔街日报，英国BBC等外国媒体都若有若无的抹黑中国，甚至在主流媒体FaceBook,Twitter上更是不遗余力的恶意捏造，发酵反中言论。这种颠倒是非着实让人感到恶心，我都怀疑自己生活在水生火热之中，急需外星人拯救！</p><h1 id="其他国家的借鉴意义"><a href="#其他国家的借鉴意义" class="headerlink" title="其他国家的借鉴意义"></a>其他国家的借鉴意义</h1><h3 id="乌克兰颜色革命"><a href="#乌克兰颜色革命" class="headerlink" title="乌克兰颜色革命"></a>乌克兰颜色革命</h3><p>是指2004年至2005年围绕2004年乌克兰总统大选过程中由于严重贪污、影响选民和直接进行选举舞弊所导致的在乌克兰全国所发生的一系列抗议和政治事件。在2004年10月31日的乌克兰总统大选中由于没有任何候选人达到法律规定的50%的多数，因此在同年11月21日在得票最多的两名候选人维克托·尤先科和维克托·亚努科维奇之间举行重选。但是众多乌克兰国内外观察员报道说官方宣布的亚努科维奇获胜的结果是舞弊导致的，同时这也是公众普遍感觉到的。这个选举舞弊导致了这场抗议。尤先科的选举活动中使用橙色作为其代表色，因此这场运动使用橙色作为抗议的颜色。这个运动的标志是橙丝带和一面书有Так! Ющенко!（“对！尤先科！”）的旗。选举结果被公布后上百万抗议者聚集在乌克兰首都基辅的市中心独立广场及河腊沙机大街，尤先科的支持者建立了一个24小时不断被占据的帐篷城，同时在乌克兰全国爆发了一系列由反对派组织的抗议、静坐、大罢工等事件。</p><p>颜色革命（Colour revolution），又称花朵革命，是指20世纪80、90年代开始的一系列发生在中亚、东欧独联体国家的以颜色命名，以“和平和非暴力”方式进行的政权变更运动，而且这些运动有向包括中东的一些地区在内的地方蔓延的趋势。参与者们以拥护自由民主与普世价值为目标，通常是现有政权的反对者，立场亲西方和亲美。他们通常采用一种特别的颜色或者花朵来作为他们的标志。</p><p>目前史上多个颜色革命在格鲁吉亚、乌克兰和吉尔吉斯等国家取得成功，推翻了原来的亲俄政权，在西方国家的支持下建立了自由民主政府，并成为亲西方和亲美政权。部分伊斯兰国家新政府建立之后，因世俗派与伊斯兰主义派的争斗，未能建立有效的民主政权，导致政治争端不断（如埃及）。</p><p>我们可以了解到</p><ul><li>乌克兰颜色革命成功了，但人均GDP从2012年的3872.53美元到2015年2124.62美元再到2018年2963.57美元。比印尼，菲律宾，委内瑞拉还低，甚至不到泰国的一半。值得一提的是，自此以后，乌克兰被称为“欧洲的泰国”，色情业成了其重要经济来源。</li><li>从近期的英国脱欧，英国伦敦、伯明翰等30多座城市同时爆发大规模抗议示威活动，智利爆发大规模抗议，伴随大量暴力冲突等政治活动。我们可以看出，资本主义国家存在明显的问题，普世价值观存在明显问题。刚学完马列主义的我知道，只有坚持马克思主义，毛泽东思想，邓小平理论，三个代表重要思想，科学发展观，以及有中国特色的社会主义道路才能发展的更好！毕竟从目前看来，我们的价值观明显更先进啊！</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过以上问题的收集整理和分析，我更倾向于香港乱局的起源主要有两个：</p><ul><li>新闻传播媒体的恶意报道，通识教育高等教育的严重过失，致使对普世价值理解严重偏差</li><li>香港被有心人利用，打造的一场闹剧</li></ul><p>我作为一个普通人，接受着正常教育，从小到大对自由民主并没有产生多大兴趣，我关心的是考试考的怎么样，课后应该怎样玩，我在游戏里应该如何操作等等鸡毛蒜皮的事。我对自由的理解无非就是“若为自由故，爱情皆可抛”，不被殖民主义压迫，自由生长；民主就是集思广益，将社会最优化。当然，这些虽然都很重要，但我生在这样的社会，一点也不在乎。经过几天的查阅，上推特和人“唠嗑”，我发现这就是文化的差异，说不好听点就是他们被“洗脑”了。每个人生来就处于一种特定的环境中，受到文化熏陶，认为周围的一切都很自然。我不能说谁的价值取向更好，毕竟由特定历史背景造成的社会正是文化所维系的。正如封建王朝崇尚儒家，中东的伊斯兰教，基督教，西方的维京人。但问题是事物总是在动态变化中的，现在你和人提到你崇尚三从四德是显得那么无知。从洋务运动，戊戌变法，辛亥革命，新文化运动教会我们的不是铭记历史，而是鉴往知来！我们不求接受他人的文化，但我们需要以开放宽容的态度吸纳不同文化，取其精华去其糟粕，这才是进步之本。话说回来，香港废青迷信西方普世价值，甚至希望美国英国给他们自由民主，令人感到可悲！美国深陷信任危机，背负巨额外债，贫富差异严重等；英国脱欧，智利地铁涨价三毛钱就大规模暴力抗议？资本主义严重的弊端尤其突兀，正常接受教育的人都应该理解，况且根本没绝对的自由和民主。一群人缺乏自我思考的能力，凭借着年轻气盛，将承担未来的苦果！</p><p>另一方面，资本主义国家打压我国由来已久，社会主义国家的崛起将打破被垄断的世界蛋糕。日本，韩国，越南等国家均有美军军事基地，虽为主权国家，却被各种原因掣肘，独立国家名存实亡。从三星垄断韩国，致政商不分家，而IT产业明显受制于美国，近日甚至取消了芯片研发，全部与高通，麒麟，ARM合作可以看出，韩国是一个发育“畸形”的国家，这些问题没法解决将是大隐患，毕竟韩国总统非死即伤。而日本资源高度依赖进口，和中方又在文化方面冲突，理所当然是美国的把柄。总之，在中国崛起之前，世界尽在美国掌控。如今一超多强的时代将会过去，美国急眼了。据一些小道消息，即官方未承认或说明但有根据的消息。自香港回归美国中央情报局CIA下了一盘大棋，利用资本对香港教育动手脚，利用一国两制的漏洞对政治动手脚，形成了在这种环境下被人为塑造了的反中文化。这也是香港人没有国家的概念，一味的反中，坚持凡是中央政府，香港政府，建制派的决议都认为是错误的。这想想就可怕！而我在推特上接触的人几乎都是先入为主的反中！这样导致的结果就是香港成了反中的基地！</p><h2 id="趋势"><a href="#趋势" class="headerlink" title="趋势"></a>趋势</h2><p>对于香港乱局，很多人纳闷中央政府的决策。按理说香港这样的弹丸之地不是随便收拾的吗？再退一步说，香港这些隐患应该早就看出来了吧。我这里给出一种解释：中央政府高估了港府的能力。从董建华数码港计划，建屋计划到林郑月娥的建屋计划，每一任行政长官都在不遗余力的改善民生问题，消灭隐患。奈何总是有保守派阻挠，08年又金融危机，这就像赶鸭子上架一样，有心无力啊。其根本原因就是港府施政能力低，这是由社会性质决定的，改起来触碰多方利益！百足之虫，死而不僵。而事态已发展到这个地步，最好的方法就是破而后立！毛主席说过，越大的动乱就是越大的机会，大乱能大治！这样复杂的社会，类比于新文化运动之前的中国，只有彻底革除“封建思想”，才能接受“新文化”。香港的闭关锁区，只有原地爆炸，才能自我救赎。而中央政府只需要“灾后重建”即可。之前供水供电供水果的渠道已经建立，深圳自贸区发展良好，甚至放开落户政策，这都证明着重建都不是事儿。而我们只需祈祷他们早一点觉醒，找到发展之路！只要他们回心转意，那就是中国的好儿子！</p>]]></content>
    
    
    <categories>
      
      <category>大事件分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大事件分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几何光学基本定律与成像概念</title>
    <link href="/2019/05/09/%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5/"/>
    <url>/2019/05/09/%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="几何光学基本定律与成像概念"><a href="#几何光学基本定律与成像概念" class="headerlink" title="几何光学基本定律与成像概念"></a>几何光学基本定律与成像概念</h1><p>几何光学是以<strong>光线</strong>作为基础概念，用<strong>几何</strong>的方法研究光在介质中的<strong>传播规律</strong>和光学系统的<strong>成像特性</strong>的一门学科。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>光波: 本质是电磁波，其中波长为380nm-780nm称为可见光</li><li>光源与发光点：能辐射光能量的物体（自发光物体或者被照亮的物体）叫光源，辐射光能量的几何点叫发光点</li><li>光线: 波面的法线即几何光学中所指的光线；由发光点发出的光抽象为携带能量并带有方向的几何线，光线的方向代表光的传播方向。（不存在的抽象概念）</li><li>波面：发光点在某一时刻发出的光形成波面<br>如果周围是各向同性均匀介质，将形成以发光点为中心的球面波或平面波</li><li>波面与光束: 某一时刻振动位相相同的点所构成的等相位面叫波面,与波面对应的法线束，可看成是光线的集合叫光束</li></ol><h2 id="几何光学的基本定律"><a href="#几何光学的基本定律" class="headerlink" title="几何光学的基本定律"></a>几何光学的基本定律</h2><ol><li>光的直线传播定律</li><li>光的独立传播定律</li><li>光的反射定律与折射定律</li><li>光的全反射现象</li><li>费马原理</li><li>马吕斯定律</li></ol><h1 id="成像的基本概念与完善成像条件"><a href="#成像的基本概念与完善成像条件" class="headerlink" title="成像的基本概念与完善成像条件"></a>成像的基本概念与完善成像条件</h1><h2 id="光学系统与成像概念"><a href="#光学系统与成像概念" class="headerlink" title="光学系统与成像概念"></a>光学系统与成像概念</h2><ol><li>光学系统的作用</li><li>完善像点与完善像</li><li>物空间，像空间</li><li>共轴光学系统</li><li>光轴</li></ol><h2 id="完善成像条件"><a href="#完善成像条件" class="headerlink" title="完善成像条件"></a>完善成像条件</h2><p>表述一：入射波面是球面波时，出射光线也是球面波</p><p>表述二：入射光是同心光束时，出射光也是同心光束</p><p>表述三：物点及其像点任意两条光路的光程相等</p><h2 id="物，像的虚实"><a href="#物，像的虚实" class="headerlink" title="物，像的虚实"></a>物，像的虚实</h2><ul><li>实像</li><li>虚像</li></ul><h1 id="光路计算及近轴光学系统"><a href="#光路计算及近轴光学系统" class="headerlink" title="光路计算及近轴光学系统"></a>光路计算及近轴光学系统</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>光轴:是光学系统一条假想的线，定义光学系统如何传导光线，光线若与光轴重合，在光学系统中，光将沿光轴传递。对于一个球面，光轴是通过球心的直线,对于一个透镜，光轴为两个球心的连线</p></li><li><p>顶点O：光轴与球面的交点</p></li><li><p>共轴光学系统 : 所有的球心都在一条直线上</p></li><li><p>子午面：轴外物点的主光线与光学系统的主轴所构成的平面</p></li><li><p>物方截距-L: 物方光线与光轴的交点到顶点的距离</p></li><li><p>物方孔径角-U: 物方光线与光轴的夹角</p></li><li><p>像方截距L‘:像方光线与光轴的交点到顶点的距离</p></li><li><p>像方孔径角U’: 像方光线与光轴的夹角</p></li><li><p>入射高度h</p><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E7%89%A9%E6%96%B9%E6%88%AA%E8%B7%9D.png" alt="1558949918684"></p></li></ul><h2 id="符号规则"><a href="#符号规则" class="headerlink" title="符号规则"></a>符号规则</h2><ul><li><p>沿轴线段(L,L’,r)：规定光线的方向自左向右，以折射面顶点0为原点，由顶点到光线与光轴交点或球心的方向和光线传播的方向相同为正，反之为负。</p></li><li><p>垂轴线段(h)：以光轴为基准，在其之上为正，反之为负。</p></li><li><p>光线与光轴的夹角(-u)：用由光轴转向光线所形成的锐角来度量，顺时针为正，反之为负。</p></li><li><p>光线与法线的夹角(I)：由光线以锐角转向法线，顺时针为正，反之为负。</p></li><li><p>光轴与法线的夹角（$\varphi$）：由光轴以锐角转向法线，顺时针为正，反之为负。</p></li><li><p>折射面间隔(d)：由前一面的顶点到后一面的顶点，顺光线方向为正，反之为负。（折射系统中，d恒为正）</p><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E7%AC%A6%E5%8F%B7%E8%A7%84%E5%88%99.png" alt="1558950867599"></p></li></ul><h2 id="实际光线的光路计算"><a href="#实际光线的光路计算" class="headerlink" title="实际光线的光路计算"></a>实际光线的光路计算</h2><p>已知：折射球面曲率半径r，介质折射率n，n’，及物方坐标L和U</p><p>求：像方坐标：L‘和U’</p><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E5%AE%9E%E9%99%85%E5%85%89%E7%BA%BF%E5%85%89%E8%B7%AF%E8%AE%A1%E7%AE%97.png" alt="1558951960827"></p><p>注：由上面推导可知：L’=f（L，U），U’=g（L，U），当L不变，只U变化时，L也变。<br>说明“球差”的存在。</p><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E7%90%83%E5%B7%AE.png" alt="1558952583918"></p><h2 id="近轴光线光路计算"><a href="#近轴光线光路计算" class="headerlink" title="近轴光线光路计算"></a>近轴光线光路计算</h2><p>当孔径角U很小时，I，I‘都很小，用弧度值代替对应的角度值正弦值。</p><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E8%BF%91%E8%BD%B4%E5%85%89%E8%B7%AF%E7%9A%84%E8%AE%A1%E7%AE%97.png" alt="1558953233936"></p><p>表明：在近轴区，l’仅是l的函数，即不随孔径U的变化而变化，成完善像，这个像点称为高斯像点</p><p>在近轴区有：h = lu = l’u’</p><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E8%BF%91%E8%BD%B4%E5%8C%BA%E5%85%B3%E7%B3%BB.png" alt="1558953488497"></p><h1 id="球面光学成像系统"><a href="#球面光学成像系统" class="headerlink" title="球面光学成像系统"></a>球面光学成像系统</h1><h2 id="单个折射面的成像"><a href="#单个折射面的成像" class="headerlink" title="单个折射面的成像"></a>单个折射面的成像</h2><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E5%9E%82%E8%BD%B4%E6%94%BE%E5%A4%A7%E7%8E%87.png" alt="1558953681714"></p><ul><li>垂轴放大率：像与物的大小之比</li><li>轴向放大率：物点沿光轴做微小的移动时，像点移动量和物点移动量之比</li><li>角放大率：一对共轭光线与光轴夹角之比。只与共轭点的位置有关，与孔径角无关，，表示折射面有将光线变宽或变窄的能力</li><li>$\alpha,\gamma,\beta$的关系：$\alpha \times \gamma=\beta$</li><li>拉赫不变量：$J=n u y=n^{\prime} u^{\prime} y^{\prime}$，它是表征光学系统的重要指标</li></ul><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E5%9E%82%E8%BD%B4%E6%94%BE%E5%A4%A7%E7%8E%87%E5%85%AC%E5%BC%8F.png" alt="1558953858593"></p><h2 id="球面反射镜成像"><a href="#球面反射镜成像" class="headerlink" title="球面反射镜成像"></a>球面反射镜成像</h2><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E7%90%83%E9%9D%A2%E9%95%9C%E6%88%90%E5%83%8F.png" alt="1558954823433"></p><ul><li><p>由$\frac{\mathrm{n}^{\prime}}{l^{\prime}}-\frac{n}{l}=\frac{n^{\prime}-n}{r}$，将n’ = -n 带入，有：</p></li><li><p>$\frac{1}{l^{\prime}}+\frac{1}{l}=\frac{2}{r}$</p></li><li><p>同时有：</p><p>$\beta=-\frac{l^{\prime}}{l}$<br>$\alpha=-\beta^{2}$  ， 物沿光轴移动时，像总是朝相反的方向移动<br>$\gamma=-\frac{1}{\beta}$</p></li></ul><h2 id="共轴球面系统"><a href="#共轴球面系统" class="headerlink" title="共轴球面系统"></a>共轴球面系统</h2><p><img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E5%85%B1%E8%BD%B4%E7%90%83%E9%9D%A2%E7%B3%BB%E7%BB%9F.png" alt="1558955218276"></p><ul><li>系统放大率是各个球面放大率的乘积</li><li>由此可推导出$\begin{aligned} \beta=\frac{n_{1}}{n_{k}} \cdot \frac{l_{1}^{\prime}}{l_{1}} \cdot &amp; \frac{l_{2}^{\prime}}{l_{2}} \cdots \cdots \frac{l_{k}^{\prime}}{l_{k}}=\frac{n_{1} u_{1}}{n_{k} u_{k}} \ \alpha &amp;=\frac{n_{k}^{\prime}}{n_{1}} \beta^{2} \ \gamma &amp;=\frac{n_{1}}{n_{k}^{\prime}} \frac{1}{\beta} \end{aligned}$$\alpha \cdot \gamma=\beta$，这和单个球面的公式完全相同</li><li>过渡公式<img src="%E5%87%A0%E4%BD%95%E5%85%89%E5%AD%A6%E5%9F%BA%E6%9C%AC%E5%AE%9A%E5%BE%8B%E4%B8%8E%E6%88%90%E5%83%8F%E6%A6%82%E5%BF%B5%5C%E8%BF%87%E5%BA%A6%E5%85%AC%E5%BC%8F.png" alt="1558955745271"></li></ul>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程光学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平面与平面系统</title>
    <link href="/2019/05/09/%E5%B9%B3%E9%9D%A2%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/05/09/%E5%B9%B3%E9%9D%A2%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="平面镜成像"><a href="#平面镜成像" class="headerlink" title="平面镜成像"></a>平面镜成像</h1><h2 id="成像"><a href="#成像" class="headerlink" title="成像"></a>成像</h2><p>平面反射镜，简称平面镜，其成像规律也可以借助球面反射镜的公式进行分析，认为$r \rightarrow \infty$ ，即可得到 l’=-l ， $\beta=1$ .</p><p>这说明物像分布在镜的两侧，大小相等，虚实相反，如下图所示.</p><p><img src="D:\Hexo\blog\source_posts\平面与平面系统\1559559125716.png" alt="1559559125716">  </p><p>物和像关于镜面是对称的，具体说是<strong>上下同方向，左右颠倒</strong>（或者说左右同方向，上下颠倒，本质在于如何选取左右或上下方向），这种对称的像称为<strong>镜像 (mirror image)</strong>. 上图中表示的是，一个右手坐标系经镜面反射后，其像是一个左手坐标系.</p><p>上述是一次反射成像，进一步可发现，对于奇数次反射成像都是镜像，而偶数次反射成像就会是与物一致的像.</p><h2 id="平面镜旋转"><a href="#平面镜旋转" class="headerlink" title="平面镜旋转"></a>平面镜旋转</h2><p>保持入射角不变，转动平面镜$\alpha$角，则会导致反射光转过$2\alpha$角.</p><p>应用：测量微小角度和位移  </p><p><img src="D:\Hexo\blog\source_posts\平面与平面系统\1559559467079.png" alt="1559559467079">  </p><p><img src="D:\Hexo\blog\source_posts\平面与平面系统\1559559492631.png" alt="1559559492631"></p><h2 id="双平面镜成像"><a href="#双平面镜成像" class="headerlink" title="双平面镜成像"></a>双平面镜成像</h2><p>性质：出射光线和入射光线的夹角与入射角无关，仅取决于双面镜的夹角</p><p>应用：折转光路  </p><p><img src="D:\Hexo\blog\source_posts\平面与平面系统\1559559755643.png" alt="1559559755643">  </p><p>两个平面镜反射面相对，夹角为$\theta$  ,分别考察$\triangle O_{1} O_{2} M$，$\triangle O_{1} O_{2} N$，有几何关系 有  </p><p>$\left{\begin{array}{l}{I_{1}=I_{1}^{\prime}} \ {I_{2}=I_{2}^{\prime}} \ {\beta+I_{2}+I_{2}^{\prime}=I_{1}+I_{1}^{\prime}} \ {\theta+I_{2}=I_{1}^{\prime}}\end{array}\right.$</p><p>推出：$\beta = 2\theta$  </p><p>连续一次成像：  </p><p><img src="D:\Hexo\blog\source_posts\平面与平面系统\1559560072611.png" alt="1559560072611">  </p><p>RP,QP为平面镜，xyz为物，其余为先经QP成像，后经RP成像。</p><p>说明这个连续一次像相当于物体绕棱边 P旋转$2\alpha$形成的，旋转方向是第一反射镜转向第二反射镜，在这里就是顺时针.（如果先PR后PQ则是逆时针）,特别地，当$\alpha=\frac{\pi}{2}$时，两个连续一次像重合，他们都和物相对于棱P对称.</p><p>这里同样可以得到一个结论，保持物不动的情况下，当双面镜夹角不变时，双面镜转动，像固定不动.</p><p>如果说更一般的理论，对于实际情况不是一连反射就停止的，会连续不断地反射，从而产生一系列像,这些像都是在以棱  P为圆心，  为PR半径的圆周上.(应指出，所有这些都是虚像），如下图所示.</p><p><img src="D:\Hexo\blog\source_posts\平面与平面系统\1559566856075.png" alt="1559566856075">  </p><h1 id="平行平板"><a href="#平行平板" class="headerlink" title="平行平板"></a>平行平板</h1><p>由两个相平行的折射平面构成的光学元件叫做平行平板.</p><h2 id="成像特性"><a href="#成像特性" class="headerlink" title="成像特性"></a>成像特性</h2><h2 id="等效光学系统"><a href="#等效光学系统" class="headerlink" title="等效光学系统"></a>等效光学系统</h2><h1 id="反射棱镜"><a href="#反射棱镜" class="headerlink" title="反射棱镜"></a>反射棱镜</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h2 id="成像方向判断"><a href="#成像方向判断" class="headerlink" title="成像方向判断"></a>成像方向判断</h2><h2 id="等效作用与展开"><a href="#等效作用与展开" class="headerlink" title="等效作用与展开"></a>等效作用与展开</h2><h1 id="折射棱镜"><a href="#折射棱镜" class="headerlink" title="折射棱镜"></a>折射棱镜</h1><h2 id="偏折"><a href="#偏折" class="headerlink" title="偏折"></a>偏折</h2><h2 id="光楔及其应用"><a href="#光楔及其应用" class="headerlink" title="光楔及其应用"></a>光楔及其应用</h2><h2 id="棱镜色散"><a href="#棱镜色散" class="headerlink" title="棱镜色散"></a>棱镜色散</h2><h1 id="光学材料"><a href="#光学材料" class="headerlink" title="光学材料"></a>光学材料</h1>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程光学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理想光学系统</title>
    <link href="/2019/05/09/%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/05/09/%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="理想光学系统及共线成像理论"><a href="#理想光学系统及共线成像理论" class="headerlink" title="理想光学系统及共线成像理论"></a>理想光学系统及共线成像理论</h1><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559117490606.png" alt="1559117490606"></p><p>将光学系统在近轴区成完善像的理论推广到任意大的空间，以任意宽的光束都能成完善像的光学系统称为理想光学系统。一个光学系统必须由若干元件组成，经反复精密计算，使其成像接近<a href="http://opt.zju.edu.cn/appopt/redir.php?catalog_id=124451#%E5%AE%8C%E5%96%84%E6%88%90%E5%83%8F%E6%9D%A1%E4%BB%B6">完善</a>。开始时，首先将系统看成是理想的。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>共轭： 物像的对应关系</li><li>共线成像： 点对应点，线对应线，面对应面的关系称为共线成像</li><li>基点和基面： 已知的共轭点和共轭面。光学系统的一对主点和一对焦点称为光学系统的<strong>基点</strong>；一对主平面和一对焦平面称为光学系统的<strong>基面</strong>.一组基点和基面就确定了光学一个系统，因此在以后作图表示光学系统的时候，只需要标记出其基点和基面就可以了，如下图所示.<img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559549672581.png" alt="1559549672581"></li></ul><ul><li><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559117871015.png" alt="1559117871015"></p></li><li><p>理想光学系统的成像性质：</p><ol><li>光轴上的物点对应的共轭像点必然位于光轴上；过光轴的某一截面内的物点对应的共轭像点必位于该平面的共辄像面内；过光轴的任意截面成像性质都相同。</li><li>垂直于光轴的物平面，它的共辄像平面也必然垂直于光轴，且平面物与其共轭平面像的几何形状完全相似，即：在垂直于光轴的同一平面内，物体的各部分具有相同的放大率β。</li><li>一个共轴理想光学系统，如果已知两对共轭面的位置和放大率，或者一对共轭面的位置和放大率，以及轴上两对共轭点的位置，则理想光学系统一切物点的共扼像点都可以根据这些已知的共轭面和共轭点来表示。</li></ol></li></ul><h1 id="理想光学系统的基点与基面"><a href="#理想光学系统的基点与基面" class="headerlink" title="理想光学系统的基点与基面"></a>理想光学系统的基点与基面</h1><h2 id="无限远的轴上物点和它对应的像点F’"><a href="#无限远的轴上物点和它对应的像点F’" class="headerlink" title="无限远的轴上物点和它对应的像点F’"></a>无限远的轴上物点和它对应的像点F’</h2><ul><li><p>无限远的轴上物点发出的光线：发出的光线与光轴平行</p><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559548993629.png" alt="1559548993629"></p></li><li><p>像方焦点:无穷远处轴上物点发出光线视为平行光，据理想光学性质知平行光交光轴于F’，即无穷远处轴上物点的像点，F’称为像方焦点</p></li><li><p>焦平面：过像方焦点作光轴的垂面即为焦平面</p></li><li><p>像方主点：从作图的角度来说，分别延长 AB和F’E’他们必相交与一点，记作点 Q’，过 Q‘做光轴的垂面，即得到像方</p><p>主平面 (principal plane)，像方主平面与光轴的焦点记作 H’，它就是像方主点 (Principal point). </p></li><li><p>主平面：</p></li><li><p>像方焦距：像方主点H’到像方焦点F‘的距离记作f’,称为像方焦距</p></li><li><p>无限远的轴外点发出的光线：与光轴成一定角度的平行光会聚于像方焦平面上</p></li></ul><h2 id="无限远的轴上像点和他对应的物点F"><a href="#无限远的轴上像点和他对应的物点F" class="headerlink" title="无限远的轴上像点和他对应的物点F"></a>无限远的轴上像点和他对应的物点F</h2><ul><li>另一方面，来自之前所谓的像方的平行于光轴的光也会在所谓物方光轴的某点出会聚，这点称为<strong>物方焦点 (object focus)**（或前焦点）. 进而可以定义</strong>物方焦平面<strong>、</strong>物方主平面<strong>、</strong>物方主点<strong>以及</strong>物方焦距**.</li></ul><h2 id="物方主平面与像方主平面的关系"><a href="#物方主平面与像方主平面的关系" class="headerlink" title="物方主平面与像方主平面的关系"></a>物方主平面与像方主平面的关系</h2><p>物方主平面与像方主平面是一对共轭面。通常用一对主平面和两个焦点来表示一个光学系统</p><h2 id="实际光学系统的基点位置和焦距的计算"><a href="#实际光学系统的基点位置和焦距的计算" class="headerlink" title="实际光学系统的基点位置和焦距的计算"></a>实际光学系统的基点位置和焦距的计算</h2><p>方法：在实际系统的近轴区追迹平行于光轴的光线，就可以计算出实际系统的近轴区的基点位置和焦距。</p><h1 id="理想光学系统的物像关系"><a href="#理想光学系统的物像关系" class="headerlink" title="理想光学系统的物像关系"></a>理想光学系统的物像关系</h1><p>对于确定的光学系统，给定物体的位置，大小，方向，求像的位置，大小，虚实</p><ul><li><p>图解法：</p><p>①平行于光轴入射的光线，经过系统后过像方焦点；<br>②过物方焦点的光线，经过系统后平行于光轴；<br>③倾斜于光轴入射的平行光束，经过系统后会交于像方焦平面上的一点；<br>④自物方焦平面上一点发出的光束，经过系统后成倾斜于光轴的平行光束；</p><p>⑤共轭光线在主面上的投射高度相等。</p></li><li><p>解析法：</p><ul><li><p>牛顿公式：物像位置相对于光学系统的<strong>焦点</strong>来确定：$x x^{\prime}=f f^{\prime}$，相似三角形推出</p><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559549759238.png" alt="1559549759238"></p></li><li><p>高斯公式：物像位置相对于光学系统的<strong>主点</strong>来确定：$\frac{f^{\prime}}{l^{\prime}}+\frac{f}{l}=1$，由牛顿公式推出</p></li><li><p>主面间隔：前一光组的像方主点与后一光组的物方主点的距离，记作d</p></li><li><p>光学间隔：前一光组的像方焦点和后一光组的物方焦点的距离，记作$\Delta$</p><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559551853250.png" alt="1559551853250"></p></li><li><p>由多个光组组成的理想光学系统的成像：<img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559130786500.png" alt="1559130786500"></p></li><li><p>理想光学系统两焦距之间的关系：$\frac{f^{\prime}}{f}=-\frac{n^{\prime}}{n}$,若光学系统中包括反射面，则两焦距之间的关系由反射面个数决定，设反射面的数目为k，则可写成如下更一般的形式$\frac{f^{\prime}}{f}=(-1)^{k+1} \frac{n^{\prime}}{n}$</p></li><li><p>理想光学系统的拉赫公式：$n y \operatorname{tg} U=n^{\prime} y^{\prime} \operatorname{tg} U^{\prime}$</p></li></ul></li></ul><h1 id="理想光学系统的放大率"><a href="#理想光学系统的放大率" class="headerlink" title="理想光学系统的放大率"></a>理想光学系统的放大率</h1><h2 id="垂轴放大率"><a href="#垂轴放大率" class="headerlink" title="垂轴放大率"></a>垂轴放大率</h2><ul><li>定义式：$\beta = \frac{y’}{y}$</li><li>牛顿公式推导过程直接推出（相似三角形）：$\beta=\frac{y^{\prime}}{y}=-\frac{f}{f^{\prime}} \frac{l^{\prime}}{l}$</li><li>高斯公式下：$\beta=\frac{y^{\prime}}{y}=-\frac{f}{x}=-\frac{x^{\prime}}{f^{\prime}}$</li></ul><h2 id="轴向放大率"><a href="#轴向放大率" class="headerlink" title="轴向放大率"></a>轴向放大率</h2><ul><li><p>定义式$\alpha=\frac{d x^{\prime}}{d x}=\frac{d l^{\prime}}{d l}$</p></li><li><p>推导式：$\alpha=-\frac{x^{\prime}}{x}$，</p><p>$\alpha=-\beta^{2} \frac{f^{\prime}}{f}=\frac{n^{\prime}}{n} \beta^{2}$</p></li></ul><h2 id="角放大率"><a href="#角放大率" class="headerlink" title="角放大率"></a>角放大率</h2><ul><li>定义式：$\gamma=\frac{\operatorname{tg} U^{\prime}}{\operatorname{tg} U}$</li><li>计算式：$\gamma=\frac{n}{n^{\prime}} \frac{1}{\beta}$</li></ul><h2 id="光学系统的节点"><a href="#光学系统的节点" class="headerlink" title="光学系统的节点"></a>光学系统的节点</h2><ul><li><p>定义：角放大率等于+1的一对共轭点J.J’</p><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559550853030.png" alt="1559550853030"></p><p>注：</p><ul><li>若光学系统位于空气中，n’ = n，则$\gamma=\frac{1}{\beta}$,此时当$\gamma$=1时，$\beta=1$，主点即为节点，过主点的入射光线初射方向不变</li><li>若光学系统n’ ！= n，节点则不与主点重合，求得这一对共轭点是$x_{\mathrm{J}}=f^{\prime} \quad x_{\mathrm{J}}^{\prime}=f$</li><li>光学系统的基点：一对节点，一对主点，一对焦点，及其共轭点</li></ul></li></ul><h1 id="理想光学系统的组合"><a href="#理想光学系统的组合" class="headerlink" title="理想光学系统的组合"></a>理想光学系统的组合</h1><h2 id="两个光组组合分析"><a href="#两个光组组合分析" class="headerlink" title="两个光组组合分析"></a>两个光组组合分析</h2><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559552514998.png" alt="1559552514998"></p><p>两光组的<strong>基点</strong>、<strong>焦距</strong>、<strong>主面间隔</strong>、<strong>光学间隔</strong>已经标注清楚. 考虑的将两光组视为一个整体，称之为等效光学系统，现考察其整体的基点和基面.</p><p>对于整体的等效光学系统，设其物方像方焦点分别为F,F’  ，物方像方焦距分别为f,f’  ，主点分别为H,H’  .<br>一束光A平行于光轴入射到第一光组，与第一光组的物方主面交与Q1  ，射出后又入射到第二光组，与第二光组物方主面交于 R2 ，然后从 R2’ 射出.<br>另一束光S’也平行于光轴入射，但是反向入射，与第二光组的像方主面交于Q2’，射出后与第一光组的像方主面交于R1’，并从R1射出.</p><ul><li><p>先求F’的位置：<br>对于作图法，以平行光入射，经过第一光组后必过F1’，然后进入第二光组，自然可以找到其出射光线，它与光轴的交点就是F’</p><p>对于解析法，假设F2’与F’的距离为$x_{F}^{\prime}$，以F2’为起始点计算，显然F1’与F’相对于第二光组而言是一对共轭点，那么根据牛顿公式有$\Delta x_{F}^{\prime}=-f_{2} f_{2}^{\prime}$（注意符号），那么 $x_{F}^{\prime}=-\frac{f_{2} f_{2}^{\prime}}{\Delta}$以此便找到了F’的具体位置.</p></li><li><p>然后找 F 的位置：<br>对于作图法，显然，经过F的光线，再经过整个光学系统后必与光轴平行，具体而言，它也应该经过F2点，那么F和  F2相对于第一光组就是一对共轭点.</p><p>对于解析法，同理可得$x_{F}=\frac{f_{1} f_{1}^{\prime}}{\Delta}$，这个量是以F1为起点计算的.</p></li><li><p>最后找H,H’的位置：<br>对于作图法，和单光组的情况一样，作图找主面位置：延长光线A，与出射光交于Q’点，过Q’做光轴的垂线，垂足即是像方主点H’. 另一方面延长光线S，与出射光交于Q，过Q做光轴的垂线，垂足即是物方主点H.</p><p>对于解析法，其实有了焦点的位置，只要再求出焦距，即可得到主点的位置</p><blockquote><ul><li><p>焦点位置和焦距（牛顿公式）：</p><p>$\begin{array}{ll}{x_{F}^{\prime}=-\frac{f_{2} f_{2}^{\prime}}{\Delta}} &amp; {x_{F}=\frac{f_{1} f_{1}^{\prime}}{\Delta}} \ {f^{\prime}=-\frac{f_{1}^{\prime} f_{2}^{\prime}}{\Delta}} &amp; {f=\frac{f_{1} f_{2}}{\Delta}}\end{array}$</p></li><li><p>光焦度：</p><p>$\varphi=\frac{1}{f^{\prime}}$</p><p>通用公式：$\varphi=\varphi_{1}+\varphi_{2}-d \varphi_{1} \varphi_{2}$</p><p>密接薄镜组光焦度公式：$\varphi=\varphi_{1}+\varphi_{2}$</p></li><li><p>焦点位置和主点位置（高斯公式）</p><p>$\begin{array}{ll}{l_{F}^{\prime}=f^{\prime}\left(1-\frac{d}{f_{1}^{\prime}}\right)} &amp; {l_{F}=-f^{\prime}\left(1+\frac{d}{f_{2}}\right)} \ {l_{H}^{\prime}=-f^{\prime} \frac{d}{f_{1}^{\prime}}} &amp; {l_{H}=f \frac{d}{f_{2}}}\end{array}$</p></li></ul></blockquote></li><li><p>以上的讨论，对于两光组之间的位置关系，都是从两光组焦点的角度出发以$\Delta$计的，还有一种方案就是从两光组主点的角度出发以 d计，这里不具体推导，给出总结性的结论。</p><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559553943217.png" alt="1559553943217"></p></li></ul><h2 id="多光组组合计算"><a href="#多光组组合计算" class="headerlink" title="多光组组合计算"></a>多光组组合计算</h2><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559554358796.png" alt="1559554358796"></p><p>为方便计算，考虑平行光入射的情况. 对于符号表示有如下约定：</p><p>光线在第 i个光组主面的投射高度为hi；<br>第i个光组的物像方孔径角分别为Ui；<br>第i个光组像方主面和第i+1个光组物方主面的距离为di；<br>第i个光组的像方焦距为fi’.<br>关于在已知fi,di的情况下求$l_{F}^{\prime}$和f’的问题，下面给出两种计算方法，分别称为正切计算法和截距计算法.</p><ul><li><p>正切计算法</p><p>根据图中几何关系：$l_{F}^{\prime}=\frac{h_{n}}{\tan U_{n}^{\prime}}$，$f^{\prime}=\frac{h_{1}}{\tan U_{n}^{\prime}}$</p><p>一共就涉及到三个量，h1，hn，Un’，而实际上，h1是可以随意设定的，而且它决定了Un’，因此只要计算出hn和Un’就可以计算出$l_{F}^{\prime}$和f’</p><p>而hn和Un’需要逐个光组进行计算，考虑  </p><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559555776624.png" alt="1559555776624">  </p><p>每个主面投射高度：$h_{i+1}=h_{i}-d_{i} \tan U_{i}^{\prime}$，  </p><p>孔径角：考虑第i个光组的高斯公式，并在等号两端同乘以hi得到$\frac{h_{i}}{l_{i}^{\prime}}-\frac{h_{i}}{l_{i}}=\frac{h_{i}}{f_{i}^{\prime}}$并注意$\frac{h_{i}}{l_{i}^{\prime}}=\tan U^{\prime}$和$\frac{h_{i}}{l_{i}}=\tan U$，代入得到 $\tan U_{i}^{\prime}=\tan U_{i}+\frac{h_{i}}{f_{i}^{\prime}}$  </p><p>注意到$U_{i}^{\prime}=U_{i+1}$，那么在上面这个公式里，只需要再知道  hi即可计算（绿色表示已知量，红色表示利用该公式求得的量，紫色表示最终需要的量）.  </p><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559556053311.png" alt="1559556053311"></p></li><li><p>截距计算法</p><p>这种方法不计算每一个孔径角，而是计算每一个物距、像距，即根据高斯公式和过渡公式进行计算，即 </p><p>$\frac{1}{l_{i}^{\prime}}-\frac{1}{l_{i}}=\frac{1}{f_{i}^{\prime}}, \quad l_{i+1}=l_{i}-d_{i}$  </p><p><img src="%E7%90%86%E6%83%B3%E5%85%89%E5%AD%A6%E7%B3%BB%E7%BB%9F%5C1559556109280.png" alt="1559556109280"></p></li></ul><h1 id="透镜"><a href="#透镜" class="headerlink" title="透镜"></a>透镜</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>定义：两个折射面包围的一种透明介质所形成的零件</li><li>分类：<ul><li>按光线作用分：正透镜，负透镜</li><li>按形状：凸凹</li></ul></li></ul><h2 id="透镜计算公式"><a href="#透镜计算公式" class="headerlink" title="透镜计算公式"></a>透镜计算公式</h2><p>首先站在<strong>理想光学系统</strong>的角度回顾<strong>单个折射球面</strong>：显然其两个主点都与球面顶点重合，其物方像方焦距分别为$f=-\frac{n r}{n^{\prime}-n}$和$f^{\prime}=\frac{n^{\prime} r}{n^{\prime}-n}$</p><ul><li>焦距公式：$f^{\prime}=-f=-\frac{f_{1}^{\prime} f_{2}^{\prime}}{\Delta}=\frac{n r_{1} r_{2}}{(n-1)\left[n\left(r_{2}-r_{1}\right)+(n-1) d\right]}$</li><li>光焦度：$\Phi=\frac{1}{f^{\prime}}=(n-1)\left(\rho_{1}-\rho_{2}\right)+\frac{(n-1)^{2}}{n} d \rho_{1} \rho_{2} \quad \rho_{1}=1 / r_{1}$</li></ul>]]></content>
    
    
    <categories>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程光学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双极型晶体管</title>
    <link href="/2019/04/23/%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1/"/>
    <url>/2019/04/23/%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="电压信号如何放大"><a href="#电压信号如何放大" class="headerlink" title="电压信号如何放大"></a>电压信号如何放大</h1><p>在电路的学习中，知道四种受控源：</p><ul><li><p>电压控制电压源：对应于变压器，但变压器只能放大高频信号。</p></li><li><p>电流控制电压源： 不存在这种器件</p></li><li><p>电压控制电流源：对应于结型场效应管JFET，金属氧化物半导体场效应管MOSFET（暂不讨论）</p></li><li><p>电流控制电流源：电流和电压通过电阻进行转换，对应于双极型晶体管BJT</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5CCCCS%E5%AE%9E%E7%8E%B0%E7%94%B5%E6%B5%81%E6%94%BE%E5%A4%A7.png" alt="1555393411916"></p><p>$u_{O U T}=-i_{O U T} R_{L O A D}=-k i_{I N} \times R_{L O A D}=-k \frac{U_{I N}}{R_{I N}} \times R_{L O A D} |$，其中k是电流源控制系数</p></li></ul><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8C%96%E6%A8%A1%E5%9E%8B.png" alt="1555393075771"></p><p>由此可实现电压信号的放大。</p><h1 id="认识双极型晶体管"><a href="#认识双极型晶体管" class="headerlink" title="认识双极型晶体管"></a>认识双极型晶体管</h1><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E6%99%B6%E4%BD%93%E7%AE%A1%E7%AC%A6%E5%8F%B7.png" alt="1555393748672"></p><p>由半导体工艺制成，其中P，N代表P型半导体，N型半导体。从中引出管脚，即电极，如上图所示。be，ce之间类似于一个PN结，单向导通。其方向由箭头方向指明。</p><h2 id="基本电流关系"><a href="#基本电流关系" class="headerlink" title="基本电流关系"></a>基本电流关系</h2><p>定义流经b极的电流 为$i_b$,同理有$i_c,i_e$,满足基尔霍夫电流定律：$i_{\mathrm{B}}+i_{\mathrm{C}}=i_{\mathrm{E}}$</p><p>放大状态时，集电极电流唯一受控于基极电流，与ce两端电压无关：$i_{\mathrm{C}}=\beta i_{\mathrm{B}}$</p><h2 id="NPN型晶体管的伏安特性"><a href="#NPN型晶体管的伏安特性" class="headerlink" title="NPN型晶体管的伏安特性"></a>NPN型晶体管的伏安特性</h2><h3 id="输入伏安特性"><a href="#输入伏安特性" class="headerlink" title="输入伏安特性"></a>输入伏安特性</h3><p>指基极电流$i_b$与发射结电压$U_{\mathrm{BE}}$之间的关系，这种关系也受到 $U_{\mathrm{CE}}$的影响。</p><p>在multisim中仿真，搭建如图所示电路，直流扫描发射结电压，从0-1V，增量为50mv；直流扫描$U_{\mathrm{CE}}$，从0-5V，增量为1v.</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5CBJT%E4%BB%BF%E7%9C%9F%E7%94%B5%E8%B7%AF.png" alt="1555398423135"></p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5CBJT%E8%BE%93%E5%85%A5%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF.png" alt="1555398496481"></p><p>上述结果表明：</p><ul><li>$U_{\mathrm{CE}}$大于0后对输入特性曲线几乎毫无影响，当其等于0，曲线向左移动。</li><li>发射结电压$U_{\mathrm{BE}}$对$i_b$影响显著。因为$i_B$与$U_{\mathrm{BE}}满足i_{\mathrm{B}}=I_{\mathrm{S}}\left(e^{\frac{u_{\mathrm{BE}}}{U_{T}}}-1\right)$，其中$I_s$是反向饱和电流，每个晶体管都不一样，很小。$U_T$是热电压，与绝对温度成正比，27摄氏度时大概为26mv。显然，当U_{\mathrm{BE}}远大于$U_T$,成指数上升趋势。</li></ul><h3 id="输出伏安特性曲线"><a href="#输出伏安特性曲线" class="headerlink" title="输出伏安特性曲线"></a>输出伏安特性曲线</h3><p>指在确定的基极电流$i_b$的情况下，$U_{\mathrm{CE}}$与$i_c$之间的关系</p><p>同样的仿真电路，直流扫描两个电压：</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5CBJT%E8%BE%93%E5%87%BA%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF.png" alt="1555400173339"></p><p>按上述电流关系$i_c$与$i_b$应该成正比，但当$U_{\mathrm{CE}}$变化在一定区域内并不满足关系。在两个小电压激励下$i_b$甚至还会反向。由此引出了输出伏安特性曲线中的区域划分。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E8%BE%93%E5%87%BA%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" alt="1555400721631"></p><ul><li>在饱和区$i_c$随$U_{\mathrm{CE}}$增大而增大</li><li>在放大区，近似满足电流关系$i_c$与$i_b$成正比，与$U_{\mathrm{CE}}$无关</li><li>在截止区，$i_c$有着极小的漏电流</li></ul><h1 id="搭建一个放大电路"><a href="#搭建一个放大电路" class="headerlink" title="搭建一个放大电路"></a>搭建一个放大电路</h1><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF.png" alt="1555407417191"></p><p>用晶体管搭建一个电路，实现对一个微小的正弦信号放大。首先给基极一个固定电压，在此基础上叠加一个微小的正弦信号，这个电压作用在输入特性曲线上，产生一个变化电流的波形，$i_c$是$\beta$倍的$i_b$，然后作用于电阻$R_c$上，最终实现放大。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%B0%8F%E4%BF%A1%E5%8F%B7%E5%AE%9E%E7%8E%B0%E6%94%BE%E5%A4%A7%E8%BF%87%E7%A8%8B.png" alt="1555407810039"></p><p>图八中存在上高下矮的问题，在用仿真软件搭建实验电路的过程中，主要问题是怎样才能使图像不变形，因为我不知道怎么让三极管工作在放大区。</p><p>下图是随意设置的一些参数，可以看到，十分的不和谐。这与理想状况出入有点大。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%B0%8F%E4%BF%A1%E5%8F%B7%E6%94%BE%E5%A4%A7%E4%BB%BF%E7%9C%9F%E7%94%B5%E8%B7%AF.png" alt="1555408084581"></p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%B0%8F%E4%BF%A1%E5%8F%B7%E6%94%BE%E5%A4%A7%E4%BB%BF%E7%9C%9F%E7%BB%93%E6%9E%9C1.png" alt="1555408113408"></p><h2 id="静态和信号耦合"><a href="#静态和信号耦合" class="headerlink" title="静态和信号耦合"></a>静态和信号耦合</h2><h3 id="静态和动态"><a href="#静态和动态" class="headerlink" title="静态和动态"></a>静态和动态</h3><p>根据欧姆定律，在知道器件电压和电流的情况下我们可以算出电阻。电压和电流动态改变，我们可以等效为一个动态电阻，大小为电压改变量与电流改变量的比值。对应到输出特性曲线上，静态电阻等于该点处与原点连线的直线斜率的倒数，动态电阻是切线斜率的倒数。</p><p>对于一个晶体管来说，放大系数也有动态静态之分，幸运的是差距不大，一般应用下是假设不变的。</p><h3 id="静态工作点"><a href="#静态工作点" class="headerlink" title="静态工作点"></a>静态工作点</h3><p>指的是放大电路的电源供电正常，在没有输入信号的状态，在输入输出伏安特性曲线上表现为一个静态的点。该点处的电压电流加下标Q来表示。有两个重要原因需要确定静态工作点：</p><ul><li><p>从输入端看，发射结电压可正可负，如果是零或者负的电压，三极管不导通$i_b$=0,此时输出也为0，所以下图肯定不行。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AFv0.1.png" alt="1555410605549"></p></li><li><p>从输出端看，三极管工作区域不能在截止区和饱和区，因此，取一个折中的静态工作点，即$E_c$的一半。可以用下图实现</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C1555412100245.png" alt="1555412100245"></p></li></ul><h3 id="阻容耦合"><a href="#阻容耦合" class="headerlink" title="阻容耦合"></a>阻容耦合</h3><p>在上面的仿真电路中，我就试图将直流电压源串联到交流信号源中，但实际情况是无法实现的，这是理想化的——除非它是一个变压器的副边。因为我们日常使用电源都是单端输出，负端是默认接地的，二者不能串联。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C1555412354551.png" alt="1555412354551"></p><p>因此，给出了以上电路图解决了上述问题，我们来捋一下：</p><ul><li>在不影响静态工作点的情况下，将信号耦合到了输入当中：电容通交流隔直流。</li><li>调整$R_c,R_b$可以控制静态工作点输出电压大小在$E_c$的一半附近。</li><li>输出加一个电容，隔绝了直流对负载的影响</li></ul><p>总的来说，直流电源和电阻的作用就是营造一个信号放大的环境，阻容耦合的缺点是不能放大直流信号。除此之外，还有变压器耦合，直接耦合，光电耦合等。</p><p>然后我搭了下面的电路：</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%88%90%E5%8A%9F%E7%9A%84%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF.png" alt="1555570141720"></p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%9C.png" alt="1555570194630"></p><p>可以看到：</p><ul><li>输入输出信号的相位不一致</li><li>的确被放大了</li><li>放大信号的确有点上矮下高</li></ul><p>实现的过程比较繁琐，注意以下之处：</p><ul><li><p>应先确定静态工作点，multisim里有计算的仿真按钮，自己也可以手动计算。首先要保证处于放大状态，这个$U_{\mathrm{CEQ}}$就决定了信号放大的阈值$U_{\mathrm{CE}}$应大于0.3，即此处电压幅值应小于$U_{\mathrm{CE}}-0.3$。<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E9%9D%99%E6%80%81%E5%B7%A5%E4%BD%9C%E7%82%B9%E7%9A%84%E8%AE%A1%E7%AE%97.png" alt="1555570526941"></p><p>再根据这个最大电压幅值估算输入信号的幅值，应该是很小的，因为放大倍数一般很大。</p><ul><li>输入信号如果很大，在三极管基极信号就变形了<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7%E5%A4%A7.png" alt="1555572664111">，其后输出信号变形更严重<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7%E5%A4%A7%E7%9A%84%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7.png" alt="1555572772738"></li></ul></li><li><p>三极管的参数可以手动修改，在edit model里。</p></li><li><p>相位变化在加了电容后就改变了，加了一个电容变了90度，后面输出不知道变了多少</p></li><li><p>放大过程并不是上面那张图一致的变化，这只是个原理罢了。实际上根据仿真，加载发射极的电压比信号源还小。</p></li></ul><h1 id="三极管的工作状态"><a href="#三极管的工作状态" class="headerlink" title="三极管的工作状态"></a>三极管的工作状态</h1><ul><li>截止状态：基极几乎没有电流，一般认为发射结，集电结均反偏时处于此状态。此时都不导通，图就不贴了。</li><li>放大状态：发射结正偏，集电结反偏。满足电流基本关系。</li><li>饱和状态：此时$I_{\mathrm{CQ}}&lt;\beta I_{\mathrm{BQ}}$，且随$U_{\mathrm{CEQ}}$变化，任何状态下，只要$U_{\mathrm{CEQ}}&lt;U_{\mathrm{CES}}$就处于饱和状态，此时两电流几乎不增加。一般情况下，集电结，发射结均正偏为饱和状态。我们在原电路中将一个电阻改为5K，算静态工作点$U_{\mathrm{CEQ}}$是负数，显然不处于放大状态，所以$U_{\mathrm{CEQ}}=0.3V$，处于饱和状态，算出$I_{\mathrm{CQ}}=2.34$,仿真后等于2.374.<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E9%A5%B1%E5%92%8C%E7%8A%B6%E6%80%81%E7%9A%84%E7%94%B5%E8%B7%AF.png" alt="1555574205609"><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C1555574726110.png" alt="1555574726110"></li></ul><p>由图得并没有怎么放大。</p><ul><li>倒置状态：指三极管接反了，发射结反偏，集电结正偏，这样不会烧了晶体管，但$\beta$ 下降严重。</li></ul><h2 id="如何判断三极管工作状态"><a href="#如何判断三极管工作状态" class="headerlink" title="如何判断三极管工作状态"></a>如何判断三极管工作状态</h2><p>放大结构：如果三极管实际电流方向和我们期望电流方向一致，即为放大结构。<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E6%94%BE%E5%A4%A7%E7%BB%93%E6%9E%84.png" alt="1555574990022"></p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%88%A4%E6%96%AD%E4%B8%89%E6%9E%81%E7%AE%A1%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.png" alt="1555575023922"></p><h1 id="图解法解静态工作点"><a href="#图解法解静态工作点" class="headerlink" title="图解法解静态工作点"></a>图解法解静态工作点</h1><p>静态工作点有三种解法：</p><ul><li>解析法：前提是知道输入输出特性曲线的函数，联立方程求解</li><li>估算法：核心是假设$U_{\mathrm{BEQ}}=0.7V$,但这个估算是有误差的，结果不太准确。</li><li>图解法：在特性曲线上画图，凭观察读出静态工作点的大致读数。</li></ul><p>对于一个这样的电路：<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%9B%BE%E8%A7%A3%E6%B3%95%E7%94%B5%E8%B7%AF.png" alt="1555649423470"></p><p>静态工作点$i_{BQ}$首先满足电路拓扑结构，即电路方程$E_{C}=i_{BQ} R_{B}+u_{B E}$，其次满足三极管的输入特性曲线。二者交点即是静态工作点。同理可得输出的静态工作点。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E8%BE%93%E5%85%A5%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF%E5%9B%BE%E8%A7%A3%E6%B3%95.png" alt="1555649665043"></p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E8%BE%93%E5%87%BA%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF%E5%9B%BE%E8%A7%A3%E6%B3%95.png" alt="1555649696484"></p><p>由图可以看出：激励电压和两个电阻决定了静态工作点工作状态，设计时先获取输入输出特性曲线，便可设计出适合的放大电路。</p><h1 id="两部件串联的图解方法"><a href="#两部件串联的图解方法" class="headerlink" title="两部件串联的图解方法"></a>两部件串联的图解方法</h1><h2 id="电阻串联二极管"><a href="#电阻串联二极管" class="headerlink" title="电阻串联二极管"></a>电阻串联二极管</h2><p>作为图解法的延申，看看这个电路如何用图解法解决<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E4%B8%A4%E9%83%A8%E4%BB%B6%E5%9B%BE%E8%A7%A3%E6%B3%95%E7%94%B5%E8%B7%AF.png" alt="1555650655893"></p><p>首先要满足电阻的伏安特性曲线$I = \frac{1}{R}U$,其次要满足二极管的伏安特性曲线，更重要的是还要满足二者电压之和等于总电压，画在图上就是电阻的伏安特性曲线镜像旋转，并落在x轴等于总电压这个点上，这样就能保证二者电压之和一定。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E4%B8%A4%E9%83%A8%E4%BB%B6%E4%B8%B2%E8%81%94%E5%9B%BE%E8%A7%A3%E6%B3%95.png" alt="1555651188192"></p><h2 id="两晶体管串联"><a href="#两晶体管串联" class="headerlink" title="两晶体管串联"></a>两晶体管串联</h2><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E4%B8%A4%E6%99%B6%E4%BD%93%E7%AE%A1%E4%B8%B2%E8%81%94%E5%9B%BE%E8%A7%A3%E7%94%B5%E8%B7%AF.png" alt="1555651280400"></p><p>如果你对两个二极管分别进行计算，你将会得出两晶体管集电极电流并不相等的结论。这显然是错误的。<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E6%99%B6%E4%BD%93%E7%AE%A1%E4%B8%B2%E8%81%94%E5%9B%BE%E8%A7%A3.png" alt="1555651574627"></p><p>按相同的方法画出输出特性曲线，两个电阻控制基极电流，从而控制图像的形状。总可以找到适合的电阻值，使得Vout在0-10V之间，也即控制交点的位置。显然，找到这个点比较困难，一次一次试总可以找到。</p><h1 id="动态求解方法"><a href="#动态求解方法" class="headerlink" title="动态求解方法"></a>动态求解方法</h1><p>以上学习了三个知识点：</p><ul><li>晶体管的伏安特性</li><li>晶体管的工作原理和静态的重要性，学会了计算静态工作点</li><li>输入信号如何耦合到放大电路中</li></ul><p>下面我们学习，对于一个输入信号耦合到放大电路中，究竟放大了多少——动态求解方法。这是一种由输入变化量求取输出变化量的方法，区别于直接用公式带，相较来说更简单。其核心是：</p><ul><li>输入输出都取变化量</li><li>电路中电压不变点接地，电流不变点断路：由叠加原理，不变的电压，电流不会产生变化量</li><li>电路中某一元件的某一段伏安特性可以用直线代替，相当于动态电阻</li></ul><p>例：当$U_I$的变化量为$U_i$时，求输出$U_o$的表达式<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%8A%A8%E6%80%81%E6%B1%82%E8%A7%A3%E7%A4%BA%E4%BE%8B%E7%94%B5%E8%B7%AF.png" alt="1555927700385"></p><p>当然可以用笨办法写出$U_I$作用的表达式和$U_I+U_i$的表达式，两个输出相减。但用但用动态电路求解方法就简单许多。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%8A%A8%E6%80%81%E7%94%B5%E8%B7%AF%E7%A4%BA%E4%BE%8B%E7%AE%80%E5%8C%96%E7%94%B5%E8%B7%AF.png" alt="1555927874977"></p><p>由此可得：$u_{\mathrm{o}}=u_{\mathrm{i}} \times \frac{R_{1} / / R_{2}}{R_{1} / / R_{2}+R_{3}}$</p><h1 id="双极型晶体管的动态模型——微变等效模型"><a href="#双极型晶体管的动态模型——微变等效模型" class="headerlink" title="双极型晶体管的动态模型——微变等效模型"></a>双极型晶体管的动态模型——微变等效模型</h1><p>理论上说，晶体管的高频等效模型包含低频模型，但低频模型更简单，所以拿来介绍。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%BE%AE%E5%8F%98%E7%AD%89%E6%95%88%E6%A8%A1%E5%9E%8B%E7%94%B5%E8%B7%AF.png" alt="1555929081145"></p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%BE%AE%E5%8F%98%E7%AD%89%E6%95%88%E6%A8%A1%E5%9E%8B%E8%A7%A3%E9%87%8A.png" alt="1555929116026"></p><p>对于上图电路，建立等效模型即弄清原理用基本元件进行描述，使得输出与原输出等价。</p><ul><li><p>首先，在静态工作点$Q_1$处$U_{BE}$存在静态值，由于输入信号的作用，有峰峰值$\Delta U_{BE}$的变化量，然后有$\Delta i_B$的变化量,这个变化可用$r_{be1}$来近似表示，由图中可以看出$Q_1$点的动态电阻，即为此处斜率的倒数，当然前提建立在输入信号幅值很小的基础上。由此，对伏安特性曲线上的任何一个静态点有：<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C1556107036849.png" alt="1556107036849"></p><p> 经研究，在放大状态下的动态电阻可以近似表示为:$r_{\mathrm{be}}=r_{\mathrm{bb}}+\frac{U_{\mathrm{T}}}{I_{\mathrm{BQ} 1}}$,其中$r_{bb}$称之为体电阻，几欧到几百欧不等，一般取40欧；$U_T$常温下为26mv。此时相当于一个关系$\Delta i_{\mathrm{B}} \approx \frac{\Delta u_{\mathrm{BE}}}{r_{\mathrm{be}}}$</p></li><li><p>从$i_b$到$i_c$，可以用电流控制电流源来表示<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E6%99%B6%E4%BD%93%E7%AE%A1%E7%AE%80%E5%8C%96%E7%AD%89%E6%95%88%E6%A8%A1%E5%9E%8B.png" alt="1555930055047"></p></li></ul><h1 id="双极型晶体管放大电路的动态分析"><a href="#双极型晶体管放大电路的动态分析" class="headerlink" title="双极型晶体管放大电路的动态分析"></a>双极型晶体管放大电路的动态分析</h1><h2 id="动态分析的三个重要指标"><a href="#动态分析的三个重要指标" class="headerlink" title="动态分析的三个重要指标"></a>动态分析的三个重要指标</h2><ul><li>电压放大倍数：$A_{\mathrm{u}}=\frac{u_{\mathrm{o}}}{u_{\mathrm{i}}}$，$A_{\mathrm{u}}=20 \times \log \left(\frac{u_{\mathrm{o}}}{u_{\mathrm{i}}}\right)(\mathrm{dB})$<img src="%E7%94%B5%E8%B7%AF%E4%B8%8E%E7%94%B5%E5%AD%90%E5%AD%A6%5C%E7%94%B5%E5%8E%8B%E5%A2%9E%E7%9B%8A%E4%B8%8Edb%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="1555931710706"></li><li>输入电阻：输入电压变化量除以输入电流变化量，等效于从输入端看进去的输入电阻$r_{\mathrm{i}}=\frac{u_{\mathrm{i}}}{i_{\mathrm{i}}}$，我们希望输入电阻越大越好，因为可以让更多的电压到达下一级。</li><li>输出电阻：同上，我们希望越小越好，因为可以让更多电压到负载上。</li></ul><h2 id="动态分析的步骤"><a href="#动态分析的步骤" class="headerlink" title="动态分析的步骤"></a>动态分析的步骤</h2><ul><li><p>画出微变等效模型：</p><ul><li>电压不变点进行接地</li><li>大电容短接，小电容开路</li><li>晶体管用动态等效模型代替</li><li>画成顺眼的电路图</li></ul><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%8A%A8%E6%80%81%E7%AD%89%E6%95%88%E6%A8%A1%E5%9E%8B.png" alt="1555932260744"></p></li><li><p>求解放大倍数，输入电阻，输出电阻</p><ul><li>在求解放大倍数时，把输入输出都表示成含$i_b$的表达式，消去即可。</li><li>输入电阻靠眼睛看就行，过于复杂的可以假设$U_i$已知，计算电路中的电流即可</li><li>电流控制电流源可以改为电压控制电压源<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E7%94%B5%E5%8E%8B%E6%8E%A7%E5%88%B6%E7%94%B5%E5%8E%8B%E6%BA%90.png" alt="1555932681557"></li></ul></li></ul><h1 id="动态指标的实验测量法"><a href="#动态指标的实验测量法" class="headerlink" title="动态指标的实验测量法"></a>动态指标的实验测量法</h1><p>获得三大动态指标：</p><ul><li>理论分析法——准确度不高</li><li>实验测量法——可靠但操作困难</li><li>仿真测量法——可信度高，操作简单：multisim，PSPICE,TINA-TI</li></ul><h2 id="放大倍数的实验测量法"><a href="#放大倍数的实验测量法" class="headerlink" title="放大倍数的实验测量法"></a>放大倍数的实验测量法</h2><ul><li>放大电路供电，输入端接正弦信号，考虑到隔直电容的大小，一般选10kHz的信号频率（此频率下，10$\mu F$的电容容抗为1.59欧，可近似认为短路）。当放大倍数较大时，为了避免失真，一般选用正弦波幅度1-10mV的输入信号。</li><li>示波器观察输出，以不失真为目标，输出信号频率应和输入信号频率一致。</li><li>用晶体管毫伏表测量输入信号有效值,测量输出信号的有效值，二者就可得出放大倍数。粗略估计时，在示波器上直接读取也可。</li></ul><h2 id="输入电阻的实验测量法"><a href="#输入电阻的实验测量法" class="headerlink" title="输入电阻的实验测量法"></a>输入电阻的实验测量法</h2><p>一个电路的输入电阻是可能和负载有关的，因此，必要时应注明是否带负载，负载大小是多少。</p><p>测量电路如下：</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E8%BE%93%E5%85%A5%E7%94%B5%E9%98%BB%E5%AE%9E%E9%AA%8C%E6%B5%8B%E9%87%8F%E5%8F%91%E5%8F%91.png" alt="1555933957656"></p><ul><li><p>放大器供电，选择R与输入电阻相差不大，以保证测量的准确性。信号源选择与放大倍数测量一致。</p></li><li><p>示波器观察，保证其正常</p></li><li><p>用晶体管毫伏表测量$T_1$,$T_2$出电压的有效值，则有：$r_{i}=\frac{U_{\mathrm{T} 2-\mathrm{rms}}}{U_{\mathrm{T} 1_{-} \mathrm{rms}}-U_{\mathrm{T} 2_{-} \mathrm{rms}}} R$，这可以用输入电流在R，$r_1$上相等来列表达式。</p></li></ul><h2 id="输出电阻的实验测量法"><a href="#输出电阻的实验测量法" class="headerlink" title="输出电阻的实验测量法"></a>输出电阻的实验测量法</h2><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E8%BE%93%E5%87%BA%E7%94%B5%E9%98%BB%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%B5%8B%E9%87%8F%E6%B3%95.png" alt="1555934390728"></p><ul><li>放大器供电，接上信号源。</li><li>开关S断开的情况下示波器观察，保证其正常。</li><li>有：$r_{\mathrm{o}}=\frac{u_{\mathrm{o} \infty}-u_{\mathrm{oL}}}{u_{\mathrm{oL}}} \times R_{\mathrm{L}}$，为了获得更加准确地测量，$R_L$过大过小都不行，应先预估其值，这是准确的关键。一种改进的方法，用一个电位器代替负载电阻，不断调节，使$u_{\mathrm{oL}}=0.5 u_{0 \infty}$，拿下电位器，测电位器的阻值即可。</li></ul><h1 id="共基极，共集电极放大电路及PNP管电路"><a href="#共基极，共集电极放大电路及PNP管电路" class="headerlink" title="共基极，共集电极放大电路及PNP管电路"></a>共基极，共集电极放大电路及PNP管电路</h1><h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><p>从放大机理上来看，能够让$U_{BE}$变的就是输入端，所以输入一定是b，e两极，输出一定在c，e两级。这样b不输出，c不输入，就有三种电路</p><ul><li>共射极放大电路：b输入，c输出</li><li>共集电极放大电路——射极跟随器：b输入，e输出</li><li>共基极放大电路：e输入，c输出</li></ul><h2 id="共基极放大电路"><a href="#共基极放大电路" class="headerlink" title="共基极放大电路"></a>共基极放大电路</h2><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%85%B1%E5%9F%BA%E6%9E%81%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF.png" alt="1555935566271"></p><p>为保证有足够的电压增益，一般在基极增加大电容$C_B$。</p><p>动态等效电路和戴维南等效电路如下：</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%85%B1%E5%9F%BA%E6%9E%81%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF.png" alt="1555935665028"></p><p>若信号源内阻为0，列写节点电压方程有：$A_{\mathrm{ui}}=\frac{u_{o}}{u_{i}}=\frac{\beta R_{L}^{\prime}}{r_{\mathrm{be}}}$，用戴维南等效电路有相同的结论。</p><p>这说明，共基极放大电路在不考虑信号源内阻的情况下，具有与共射极放大电路大小相同的电压增益R是极性力同相放大而共射极电路是反相放大 。 </p><p>输入电阻：$r_{i}=R_{E} / / \eta_{\mathrm{be}} / / \frac{r_{\mathrm{be}}}{\beta}=R_{E} / / \frac{r_{\mathrm{be}}}{1+\beta}$，说明共基极放大电路输入电阻很小</p><p>输出电阻和共射极放大电路相同</p><h2 id="共集电极放大电路"><a href="#共集电极放大电路" class="headerlink" title="共集电极放大电路"></a>共集电极放大电路</h2><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%85%B1%E9%9B%86%E7%94%B5%E6%9E%81%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF.png" alt="1555936128422"></p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%85%B1%E9%9B%86%E7%94%B5%E6%9E%81%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF.png" alt="1555936202306"></p><ul><li>$A_{\mathrm{ui}}=\frac{u_{\mathrm{o}}}{u_{\mathrm{i}}}=\frac{i_{b}(1+\beta) R_{L}^{\prime}}{i_{b}\left(r_{\mathrm{be}}+(1+\beta) R_{L}^{\prime}\right)}=\frac{(1+\beta) R_{L}^{\prime}}{r_{\mathrm{be}}+(1+\beta) R_{L}^{\prime}}$，其中，$R_{\mathrm{L}}^{\prime}=R_{\mathrm{E}} / / R_{\mathrm{L}}$，多数情况下：$(1+\beta) R_{L}^{\prime}&gt;&gt;r_{\mathrm{be}}$，则放大倍数接近为1，因此叫做射极跟随器。</li><li>$r_{\mathrm{i}}=R_{B} / /\left(r_{\mathrm{be}}+(1+\beta) R_{L}^{\prime}\right)$，输入电阻远大于另外两个电路。</li><li>$r_{o}=R_{E} / / \frac{r_{\mathrm{be}}+R_{S} / / R_{B}}{1+\beta}$，输出电阻很小，一般为几欧到几十欧。</li><li>不具备放大能力，但具备电流放大能力和大的输入电阻，在扩流和阻抗匹配中有广泛应用</li></ul><p>需要<strong>特别指出</strong>的是，共射级共基极电路都有如下特点：输入电阻与负载无关，输出电阻与信号源内阻无关。但共集电极电路却不是如此。它的输入电阻与负载大小有关，而输出电阻与信号源内阻有关，在多级电路级联时，需要特别注意 。 </p><h2 id="PNP管放大电路"><a href="#PNP管放大电路" class="headerlink" title="PNP管放大电路"></a>PNP管放大电路</h2><p>方法一：<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5CPNP%E7%AE%A1.png" alt="1555936838171"></p><p>方法二：所有求解值都是反的，所有图都从第一象限到第三象限。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5CPNP%E7%AE%A12.png" alt="1555936873848"></p><h1 id="大信号情况下的失真分析"><a href="#大信号情况下的失真分析" class="headerlink" title="大信号情况下的失真分析"></a>大信号情况下的失真分析</h1><p>当输入信号幅值过大，产生失真，称为大信号失真。其明显的原因是输入信号峰值使晶体管处于饱和区或截止区。第二个原因是由于晶体管输入特性曲线是指数级增长，大信号导致不能用一段直线来描述特性曲线，从而产生变形。</p><h2 id="失真电压裕度"><a href="#失真电压裕度" class="headerlink" title="失真电压裕度"></a>失真电压裕度</h2><p>在一个晶体管放大电路中，输入为正弦波电压信号，输出所能达到的最大不失真正弦信号的幅度，陈伟失真电压裕度。</p><p>当确定了静态工作点Q（$U_{CEQ}$,$I_{CQ}$）,则</p><ul><li>饱和失真电压裕度$U_{ops}$为：$U_{o p s}=U_{C E Q}-U_{C B S}$，其中$U_{CES}$是饱和管压降，小信号时一般取0.3V左右</li><li>截止失真电压裕度$U_{O P C}$：$U_{O P C}=U_{C E_{-} \max }-U_{C B Q}$,$U_{C E_{-} \max }$是指输入信号加载的情况下，$u_{CE}$所能达到的最大电压。</li></ul><h2 id="静态负载线和动态负载线"><a href="#静态负载线和动态负载线" class="headerlink" title="静态负载线和动态负载线"></a>静态负载线和动态负载线</h2><p>对于这样一个电路：<img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E8%B4%9F%E8%BD%BD%E7%BA%BF%E7%94%B5%E8%B7%AF.png" alt="1555998628836"></p><p>给定$E_c$和$R_c$，改变$R_B$可以确定一个静态工作点Q（$U_{CEQ}$,$I_{CQ}$），全部静态工作点的集合形成一条直线称之为静态负载线，有：$E_{C}=U_{C E Q}+I_{C Q} \times R_{C}$。</p><p>当确定静态工作点后，一旦加载输入信号，任一时刻晶体管摆脱Q点，形成新的（$U_{CE}$,$I_{C}$）组合，叫做动态工作点，用q表示。所有的q点形成一条直线，称之为动态负载线，有：$E_{C}=u_{C E}+i_{C} \times R_{C}$。</p><p>在下图用绿色线标出，可知上述电路图的两条负载线时重合的。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%8A%A8%E6%80%81%E8%B4%9F%E8%BD%BD%E7%BA%BF%E5%9B%BE.png" alt="1555999031389"></p><h2 id="不重合的静动态负载线"><a href="#不重合的静动态负载线" class="headerlink" title="不重合的静动态负载线"></a>不重合的静动态负载线</h2><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E4%B8%8D%E9%87%8D%E5%90%88%E7%9A%84%E9%9D%99%E5%8A%A8%E6%80%81%E8%B4%9F%E8%BD%BD%E7%BA%BF.png" alt="1555999275250"></p><p>对于较高频率的输入信号，$C_2$相当于短路，所以$i_c$会分配给$R_c$和$R_L$，在上一电路中有$\Delta u_{C}=-\Delta i_{C} \times R_{C}$</p><p>，而在此电路中有$\Delta u_{C}=-\Delta i_{C} \times\left(R_{C} / / R_{L}\right)$。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E9%9D%99%E5%8A%A8%E6%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B4%9F%E8%BD%BD%E7%BA%BF.png" alt="1556021727746"></p><p>这样就导致了失真电压裕度变得更小。</p><h1 id="放大电路的综合分析"><a href="#放大电路的综合分析" class="headerlink" title="放大电路的综合分析"></a>放大电路的综合分析</h1><h2 id="四个电阻提供静态工作点的好处"><a href="#四个电阻提供静态工作点的好处" class="headerlink" title="四个电阻提供静态工作点的好处"></a>四个电阻提供静态工作点的好处</h2><p>下图是共射极放大电路，其中$\beta=100, r_{\mathrm{bb‘}}=132 \Omega$</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E5%9B%9B%E4%B8%AA%E7%94%B5%E9%98%BB%E7%9A%84%E5%A5%BD%E5%A4%84.png" alt="1556021928330"></p><p>我们写出静态求解过程：</p><ul><li>$k=\frac{R_{B 2}}{R_{B 1}+R_{B 2}}$</li><li>$R_{B}=\frac{R_{B 1} \times R_{B 2}}{R_{B 1}+R_{B 2}}$</li><li>$I_{\mathrm{BQ}}=\frac{k E_{C}-U_{\mathrm{BEQ}}}{R_{B}+(1+\beta) R_{E}}$</li><li>$U_{\mathrm{CEQ}}=E_{C}-R_{C} \times \beta \frac{k E_{C}-U_{\mathrm{BEQ}}}{R_{B}+(1+\beta) R_{E}}-R_{E} \times(1+\beta) \frac{k E_{C}-U_{\mathrm{BEQ}}}{R_{B}+(1+\beta) R_{E}}$</li><li>当$(1+\beta) R_{E}&gt;&gt;R_{B}$，有$U_{\mathrm{CEQ}} \approx E_{C}-\left(k E_{C}-U_{\mathrm{BEQ}}\right)\left(1+\frac{R_{C}}{R_{E}}\right)$</li></ul><p>看见没有，$I_{CQ}$和$U_{\mathrm{CEQ}}$与$\beta$几乎无关，这样带来几个好处。</p><ul><li><p>不怕温度漂移，因为$\beta$会随着温度变化</p></li><li><p>不怕晶体管的分散性，这是晶体管BC817-16的数据手册中的截图，其中$h_{FE}$就是$\beta$,厂家只能保证该值的一个范围。</p><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E6%99%B6%E4%BD%93%E7%AE%A1%E7%9A%84%E5%88%86%E6%95%A3%E6%80%A7.png" alt="1556022700170"></p></li></ul><p>如果不这样设计电路，而纠结于多了两个电阻的成本，显然得不偿失。</p><h2 id="三电阻静态电路"><a href="#三电阻静态电路" class="headerlink" title="三电阻静态电路"></a>三电阻静态电路</h2><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E4%B8%89%E7%94%B5%E9%98%BB%E9%9D%99%E6%80%81%E7%94%B5%E8%B7%AF.png" alt="1556022963719"></p><p>静态求解：</p><ul><li>$I_{\mathrm{BQ}}=\frac{E_{C}-U_{\mathrm{BEQ}}}{R_{B}+(1+\beta) R_{E}}$</li><li>$U_{\mathrm{CEQ}}=E_{C}-R_{C} \times \beta \frac{E_{C}-U_{\mathrm{BEQ}}}{R_{B}+(1+\beta) R_{E}}-R_{E} \times(1+\beta) \frac{E_{C}-U_{\mathrm{BEQ}}}{R_{B}+(1+\beta) R_{E}}$</li><li>当$(1+\beta) R_{E}&gt;&gt;R_{B}$，有$U_{\mathrm{CEQ}} \approx E_{C}-\left(E_{C}-U_{\mathrm{BEQ}}\right)\left(1+\frac{R_{C}}{R_{E}}\right)$</li></ul><p>这样依然与$ \beta$ 无关,但要满足$(1+\beta) R_{E}&gt;&gt;R_{B}$，则要$U_{\mathrm{EQ}}=R_{E} \times(1+\beta) \frac{E_{C}-U_{\mathrm{BEQ}}}{R_{B}+(1+\beta) R_{E}} \approx E_{C}-U_{\mathrm{BEQ}}$，即发射极静态电位接近电源电压，晶体管的工作区间就很小，所以这也不好。</p><h2 id="单管放大电路的静态工作点选择"><a href="#单管放大电路的静态工作点选择" class="headerlink" title="单管放大电路的静态工作点选择"></a>单管放大电路的静态工作点选择</h2><ul><li>对$U_{CEQ}$来说，应该选择动态负载线的中心位置。两级的晶体管还要考虑驱动问题。</li><li>对于$I_{CQ}$来说，由于要选择低功耗设计，则应该尽量小。但势必要选择大电阻，引入更多噪声，也导致输入电阻的增大。因此，抗干扰和低功耗是矛盾的关系。</li></ul><h2 id="静态动态分离，增益改变"><a href="#静态动态分离，增益改变" class="headerlink" title="静态动态分离，增益改变"></a>静态动态分离，增益改变</h2><p>有表达式可知，静态动态都走同一样的电路，这就导致二者相互影响，采用差动放大电路可以实现动态和静态分离。另一种方法是利用电容器将而这分离，而上图的$R_{CE}$便起到了短路$R_{E1}$的作用。</p><h1 id="多级放大电路"><a href="#多级放大电路" class="headerlink" title="多级放大电路"></a>多级放大电路</h1><p>目的：增大放大倍数，增加输入电阻，减小输出电阻，扩展频率带，增大输出功率等</p><h2 id="耦合方式"><a href="#耦合方式" class="headerlink" title="耦合方式"></a>耦合方式</h2><ul><li>直接耦合：用导线m电阻，二极管（不用，电容，变压器，光敏管）连接两级电路。优点是：可以放大直流和低频信号。缺点是：静态动态工作点都不稳定且相互影响，计算比较麻烦。</li><li>阻容耦合：优点：两级电路相互独立，并且静态工作点独立稳定。缺点：不能放大直流信号，对低频具有强大的衰减作用。</li><li>变压器耦合:与阻容耦合类似，多用于高频电路。</li><li>光电耦合:将前级输出加载到光电管上，之后传递给后级电路。多用于数字电路，模拟电路用的较少。</li></ul><h2 id="不同组态放大电路的组合方式"><a href="#不同组态放大电路的组合方式" class="headerlink" title="不同组态放大电路的组合方式"></a>不同组态放大电路的组合方式</h2><p>共集电极电路：多用于输入输出级（输入电阻大，输出电阻小）</p><p>共射极，共基极电路：多用于中间级（有较大的电压增益）</p><h2 id="阻容耦合放大电路求解"><a href="#阻容耦合放大电路求解" class="headerlink" title="阻容耦合放大电路求解"></a>阻容耦合放大电路求解</h2><p><img src="%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1%5C%E9%98%BB%E5%AE%B9%E8%80%A6%E5%90%88%E6%B1%82%E8%A7%A3.png" alt="1556024653620"></p><p>将电路改为上图所示，每一级的静态相互独立，依次计算即可。</p>]]></content>
    
    
    <categories>
      
      <category>电路与电子学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新概念模拟电路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分类及其性能指标</title>
    <link href="/2019/04/09/%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <url>/2019/04/09/%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>大纲：</p><ol><li>了解数据集</li><li>训练一个二分类器</li><li>性能指标分析</li><li>多类分类器</li><li>误差分析</li><li>多输出分类器</li></ol><h1 id="手写数字识别数据集可视化"><a href="#手写数字识别数据集可视化" class="headerlink" title="手写数字识别数据集可视化"></a>手写数字识别数据集可视化</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>%matplotlib inline<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">train_set = pd.read_csv(<span class="hljs-string">&quot;../Dataset/digit-recognizer/train.csv&quot;</span>)<br>test_set = pd.read_csv(<span class="hljs-string">&quot;../Dataset/digit-recognizer/test.csv&quot;</span>)<br>print(train_set.head())<br>print(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">40</span>)<br>print(train_set.info())<br></code></pre></td></tr></table></figure><pre><code>   label  pixel0  pixel1  pixel2  pixel3  pixel4  pixel5  pixel6  pixel7  \0      1       0       0       0       0       0       0       0       0   1      0       0       0       0       0       0       0       0       0   2      1       0       0       0       0       0       0       0       0   3      4       0       0       0       0       0       0       0       0   4      0       0       0       0       0       0       0       0       0      pixel8    ...     pixel774  pixel775  pixel776  pixel777  pixel778  \0       0    ...            0         0         0         0         0   1       0    ...            0         0         0         0         0   2       0    ...            0         0         0         0         0   3       0    ...            0         0         0         0         0   4       0    ...            0         0         0         0         0      pixel779  pixel780  pixel781  pixel782  pixel783  0         0         0         0         0         0  1         0         0         0         0         0  2         0         0         0         0         0  3         0         0         0         0         0  4         0         0         0         0         0  [5 rows x 785 columns]****************************************&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 42000 entries, 0 to 41999Columns: 785 entries, label to pixel783dtypes: int64(785)memory usage: 251.5 MBNone</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_digit</span>(<span class="hljs-params">data</span>):</span><br>    image = data.reshape(<span class="hljs-number">28</span>,<span class="hljs-number">28</span>)<br>    plt.imshow(image, cmap = matplotlib.cm.binary,interpolation=<span class="hljs-string">&quot;nearest&quot;</span>)<br>    plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<br><br>plot_digit(train_set.iloc[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>:].values)<br></code></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%5Coutput_4_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_digits</span>(<span class="hljs-params">instances, images_per_row=<span class="hljs-number">10</span>, **options</span>):</span><br>    size = <span class="hljs-number">28</span><br>    images_per_row = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(instances), images_per_row)<br>    images = [instance.reshape(size,size) <span class="hljs-keyword">for</span> instance <span class="hljs-keyword">in</span> instances]<br>    n_rows = (<span class="hljs-built_in">len</span>(instances) - <span class="hljs-number">1</span>) // images_per_row + <span class="hljs-number">1</span><br>    row_images = []<br>    n_empty = n_rows * images_per_row - <span class="hljs-built_in">len</span>(instances)<br>    images.append(np.zeros((size, size * n_empty)))<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_rows):<br>        rimages = images[row * images_per_row : (row + <span class="hljs-number">1</span>) * images_per_row]<br>        row_images.append(np.concatenate(rimages, axis=<span class="hljs-number">1</span>))<br>    image = np.concatenate(row_images, axis=<span class="hljs-number">0</span>)<br>    plt.imshow(image, cmap = matplotlib.cm.binary, **options)<br>    plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<br><br>plt.figure(figsize=(<span class="hljs-number">9</span>,<span class="hljs-number">9</span>))<br>example_images = train_set.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">21</span>,<span class="hljs-number">1</span>:].values<br>plot_digits(example_images, images_per_row=<span class="hljs-number">10</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%5Coutput_5_0.png" alt="png"></p><h1 id="训练一个二分类器"><a href="#训练一个二分类器" class="headerlink" title="训练一个二分类器"></a>训练一个二分类器</h1><ul><li>首先把原有的训练集拆分成训练集和验证集</li><li>训练模型，随机验证实例效果，反应还不错的样子</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>minist_train , minist_test = train_test_split(train_set, test_size = <span class="hljs-number">0.2</span>, random_state = <span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">minist_train_feature = minist_train.iloc[:,<span class="hljs-number">1</span>:]<br>minist_train_target = minist_train.iloc[:,<span class="hljs-number">0</span>]<br>minist_test_feature = minist_test.iloc[:,<span class="hljs-number">1</span>:]<br>minist_test_target = minist_test.iloc[:,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">minist_train_target_5 = (minist_train_target == <span class="hljs-number">5</span>)<br>minist_test_target_5 = (minist_test_target == <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDClassifier<br>sgd_clf = SGDClassifier()<br>sgd_clf.fit(minist_train_feature,minist_train_target_5)<br></code></pre></td></tr></table></figure><pre><code>D:\Anaconda\Lib\site-packages\sklearn\linear_model\stochastic_gradient.py:144: FutureWarning: max_iter and tol parameters have been added in SGDClassifier in 0.19. If both are left unset, they default to max_iter=5 and tol=None. If tol is not None, max_iter defaults to max_iter=1000. From 0.21, default max_iter will be 1000, and default tol will be 1e-3.  FutureWarning)SGDClassifier(alpha=0.0001, average=False, class_weight=None,       early_stopping=False, epsilon=0.1, eta0=0.0, fit_intercept=True,       l1_ratio=0.15, learning_rate=&#39;optimal&#39;, loss=&#39;hinge&#39;, max_iter=None,       n_iter=None, n_iter_no_change=5, n_jobs=None, penalty=&#39;l2&#39;,       power_t=0.5, random_state=None, shuffle=True, tol=None,       validation_fraction=0.1, verbose=0, warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sgd_clf.predict(np.array(minist_test_feature.iloc[<span class="hljs-number">3</span>,:]).reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><pre><code>array([False], dtype=bool)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">print(minist_test_target.iloc[<span class="hljs-number">3</span>])<br>plot_digit(minist_test_feature.iloc[<span class="hljs-number">3</span>].values)<br></code></pre></td></tr></table></figure><pre><code>9</code></pre><p><img src="%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%5Coutput_12_1.png" alt="png"></p><h1 id="衡量性能"><a href="#衡量性能" class="headerlink" title="衡量性能"></a>衡量性能</h1><ul><li>首先用交叉验证，可以看到用精度指标衡量可以说很高了<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_val_score<br>score = cross_val_score(sgd_clf,minist_train_feature, minist_train_target_5, cv = <span class="hljs-number">3</span>, scoring=<span class="hljs-string">&quot;accuracy&quot;</span>)<br><br>score <span class="hljs-comment">#这里的精度指的是  预测正确的/总的预测量，由于是5的数字足够少，不是五的精度自然就高，所以这样的衡量是不准确的</span><br></code></pre></td></tr></table></figure></li></ul><pre><code>array([ 0.960625  ,  0.95535714,  0.91705357])</code></pre><h2 id="引出混淆矩阵和分类的常见指标"><a href="#引出混淆矩阵和分类的常见指标" class="headerlink" title="引出混淆矩阵和分类的常见指标"></a>引出混淆矩阵和分类的常见指标</h2><ul><li>混淆矩阵：A类被分类成B类的次数，混淆矩阵的每一行代表一个实例，每一列代表预测的实例<br>[[TN , FP]<br>[FN , TP]]</li><li>准确率：$\frac{TP}{TP+FP}$，预测为5中，实际也为5的概率</li><li>召回率：$\frac{TP}{TP+FN}$，实际是5中，被正确预测的概率<ul><li>前面一个字母代表预测的结果是正确的还是错误的，T为正确</li><li>后一个字母代表预测的结果，所以TP：预测为5，实际也为5；FP：预测为5，实际不为5</li></ul></li><li>F1：准确率和召回率的调和平均数 $\frac{2}{\frac{1}{准确率}+\frac{1}{召回率}}$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_val_predict <span class="hljs-comment">#返回的是交叉验证的预测值,它用一份训练的模型预测另外两份的数据</span><br>minist_train_5_predict = cross_val_predict(sgd_clf,minist_train_feature, minist_train_target_5, cv = <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix<br>confusion_matrix(minist_train_target_5, minist_train_5_predict)<br></code></pre></td></tr></table></figure><pre><code>array([[30125,   382],       [  957,  2136]], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> precision_score,recall_score,f1_score<br>print(<span class="hljs-string">&quot;precision_score:&quot;</span>,precision_score(minist_train_target_5, minist_train_5_predict))<br>print(<span class="hljs-string">&quot;recall_score:&quot;</span>,recall_score(minist_train_target_5, minist_train_5_predict))<br>print(<span class="hljs-string">&quot;f1_score:&quot;</span>,f1_score(minist_train_target_5, minist_train_5_predict))<br></code></pre></td></tr></table></figure><pre><code>precision_score: 0.848292295473recall_score: 0.690591658584f1_score: 0.761361611121</code></pre><h2 id="准确率和召回率的指导意义"><a href="#准确率和召回率的指导意义" class="headerlink" title="准确率和召回率的指导意义"></a>准确率和召回率的指导意义</h2><p>如果对影片进行分类，我们倾向于抵制很多好的影片（低召回率）但只对孩子友好的影片（高准确率）。而不是尽可能多的收录好的影片而使对孩子不友好的影片成为偶尔的漏网之鱼。你无法将二者兼顾，因为他们是相互矛盾的。下面给出如何权衡的方法：</p><ul><li>这两货和决策边界有关，可以调整决策边界从而调整准确率与召回率</li><li>这里的决策边界即是decision_function的得分数，靠这个来决定一个实例是正还是负</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">minist_train_5_scores = cross_val_predict(sgd_clf,minist_train, minist_train_target_5, cv = <span class="hljs-number">3</span>,method=<span class="hljs-string">&quot;decision_function&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> precision_recall_curve<br>precisions,recalls,thresholds = precision_recall_curve(minist_train_target_5, minist_train_5_scores)<br>precisions,recalls,thresholds<br></code></pre></td></tr></table></figure><pre><code>(array([ 0.09374432,  0.09371685,  0.09371969, ...,  1.        ,         1.        ,  1.        ]), array([  1.00000000e+00,   9.99676689e-01,   9.99676689e-01, ...,          6.46621403e-04,   3.23310702e-04,   0.00000000e+00]), array([-2236830.96022862, -2236233.25582415, -2235604.48919789, ...,         1842781.66629909,  1875424.58915392,  2179185.94987394]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_precision_recall_vs_threshold</span>(<span class="hljs-params">precisions, recalls, thresholds</span>):</span><br>    plt.plot(thresholds, precisions[:-<span class="hljs-number">1</span>], <span class="hljs-string">&quot;b--&quot;</span>, label=<span class="hljs-string">&quot;Precision&quot;</span>, linewidth=<span class="hljs-number">2</span>)<br>    plt.plot(thresholds, recalls[:-<span class="hljs-number">1</span>], <span class="hljs-string">&quot;g-&quot;</span>, label=<span class="hljs-string">&quot;Recall&quot;</span>, linewidth=<span class="hljs-number">2</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;Threshold&quot;</span>, fontsize=<span class="hljs-number">16</span>)<br>    plt.legend(loc=<span class="hljs-string">&quot;upper left&quot;</span>, fontsize=<span class="hljs-number">16</span>)<br>    plt.ylim([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])<br><br>plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">4</span>))<br>plot_precision_recall_vs_threshold(precisions, recalls, thresholds)<br>plt.xlim([-<span class="hljs-number">700000</span>, <span class="hljs-number">700000</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%5Coutput_23_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">thresholdsh = <span class="hljs-number">600000</span><br>example_digit_score = sgd_clf.decision_function(np.array(minist_test_feature.iloc[<span class="hljs-number">3</span>,:]).reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>))<br>example_digit_score<br></code></pre></td></tr></table></figure><pre><code>array([-815979.04308431])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y_score = (example_digit_score &gt; thresholds)<br>y_score<br></code></pre></td></tr></table></figure><pre><code>array([ True,  True,  True, ..., False, False, False], dtype=bool)</code></pre><h2 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h2><ul><li>TPR：在所有实际为阳性的样本中，被正确地判断为阳性之比率。<br>${\displaystyle TPR=TP/(TP+FN)}$</li><li>FPR：在所有实际为阴性的样本中，被错误地判断为阳性之比率。<br>${\displaystyle FPR=FP/(FP+TN)}$</li><li>ROC曲线即是以FPR为横坐标，TPR为纵坐标绘制的曲线。</li><li>给定一个二元分类模型和它的阈值，就能从所有样本的（阳性／阴性）真实值和预测值计算出一个 (X=FPR, Y=TPR) 座标点。<br>从 (0, 0) 到 (1,1) 的对角线将ROC空间划分为左上／右下两个区域，在这条线的以上的点代表了一个好的分类结果（胜过随机分类），而在这条线以下的点代表了差的分类结果（劣于随机分类）。<br>完美的预测是一个在左上角的点，在ROC空间座标 (0,1)点，X=0 代表着没有伪阳性，Y=1 代表着没有伪阴性（所有的阳性都是真阳性）；也就是说，不管分类器输出结果是阳性或阴性，都是100%正确。一个随机的预测会得到位于从 (0, 0) 到 (1, 1) 对角线（也叫无识别率线）上的一个点；最直观的随机预测的例子就是抛硬币。</li><li>好的分类器曲线应尽可能的向左上角靠，用曲线下的面积AUC衡量，面积越大，分类越好</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve<br>fpr, tpr, thresholds = roc_curve(minist_train_target_5,minist_train_5_scores)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_roc_curve</span>(<span class="hljs-params">fpr, tpr, label=<span class="hljs-literal">None</span></span>):</span><br>    plt.plot(fpr, tpr, linewidth=<span class="hljs-number">2</span>, label=label)<br>    plt.plot([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;k--&#x27;</span>)<br>    plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])<br>    plt.xlabel(<span class="hljs-string">&#x27;False Positive Rate&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;True Positive Rate&#x27;</span>)<br>    <br>plot_roc_curve(fpr, tpr)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%5Coutput_27_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_auc_score<br>roc_auc_score(minist_train_target_5,minist_train_5_scores)<br></code></pre></td></tr></table></figure><pre><code>0.96090535941086852</code></pre><h1 id="多类别分类及算法"><a href="#多类别分类及算法" class="headerlink" title="多类别分类及算法"></a>多类别分类及算法</h1><ul><li>有一些算法直接进行多类别分类（随机森林，朴素贝叶斯），而有些只能二分类（支持向量机，线性分类）</li><li>一对所有分类：训练十个二分类器（0的分类，1的分类…），返回决策分数最高的即是所要的<br>一对一分类：训练对任意两个数字区分的模型，如果有N个类，意味着要训练N(N-1)/2个模型</li><li>直接进行多分类受制于训练集的大小，而一对一分类在多类别且小数量集上显然更快。对于大多数算法，一对多是能接受的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">some_digit = np.array(minist_test_feature.iloc[<span class="hljs-number">3</span>]).reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sgd_clf.fit(minist_train_feature , minist_train_target)<br></code></pre></td></tr></table></figure><pre><code>D:\Anaconda\Lib\site-packages\sklearn\linear_model\stochastic_gradient.py:144: FutureWarning: max_iter and tol parameters have been added in SGDClassifier in 0.19. If both are left unset, they default to max_iter=5 and tol=None. If tol is not None, max_iter defaults to max_iter=1000. From 0.21, default max_iter will be 1000, and default tol will be 1e-3.  FutureWarning)SGDClassifier(alpha=0.0001, average=False, class_weight=None,       early_stopping=False, epsilon=0.1, eta0=0.0, fit_intercept=True,       l1_ratio=0.15, learning_rate=&#39;optimal&#39;, loss=&#39;hinge&#39;, max_iter=None,       n_iter=None, n_iter_no_change=5, n_jobs=None, penalty=&#39;l2&#39;,       power_t=0.5, random_state=None, shuffle=True, tol=None,       validation_fraction=0.1, verbose=0, warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sgd_clf.predict(some_digit)<br></code></pre></td></tr></table></figure><pre><code>array([9], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">some_digit_scores = sgd_clf.decision_function(some_digit)<br>some_digit_scores<br></code></pre></td></tr></table></figure><pre><code>array([[ -920353.27712984, -1279235.87154285, -1366480.72646492,         -595927.50279798,  -482684.25204249,  -683359.55644181,        -1087498.56196379,  -225410.75309   ,  -501095.68715396,          181111.64068788]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.argmax(some_digit_scores)<br></code></pre></td></tr></table></figure><pre><code>9</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sgd_clf.classes_        <span class="hljs-comment">#这里的类别是它按大小排的</span><br></code></pre></td></tr></table></figure><pre><code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int64)</code></pre><h2 id="一对一以及一对多策略"><a href="#一对一以及一对多策略" class="headerlink" title="一对一以及一对多策略"></a>一对一以及一对多策略</h2><ul><li>如果想要sklearn用一对一，一对多，进行下列操作</li><li>当然，这只针对只能训练二分类器的算法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.multiclass <span class="hljs-keyword">import</span> OneVsOneClassifier<br>ovo_clf = OneVsOneClassifier(SGDClassifier(random_state=<span class="hljs-number">42</span>))<br>ovo_clf.fit(minist_train_feature , minist_train_target)<br>ovo_clf.predict(some_digit)    <br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(ovo_clf.estimators_)  <span class="hljs-comment">#很显然，训练了45个二分类器</span><br></code></pre></td></tr></table></figure><pre><code>45</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#我们也可以直接用随机森林多分类</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br>forest_clf = RandomForestClassifier(random_state=<span class="hljs-number">42</span>)<br>forest_clf.fit(minist_train_feature , minist_train_target)<br>forest_clf.predict(some_digit)<br></code></pre></td></tr></table></figure><pre><code>D:\Anaconda\Lib\site-packages\sklearn\ensemble\forest.py:248: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22.  &quot;10 in version 0.20 to 100 in 0.22.&quot;, FutureWarning)array([9], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">forest_clf.predict_proba(some_digit)<br></code></pre></td></tr></table></figure><pre><code>array([[ 0.1,  0. ,  0. ,  0. ,  0.1,  0. ,  0. ,  0.1,  0. ,  0.7]])</code></pre><h1 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h1><ul><li>混淆矩阵及其可视化</li><li>由于正则化能显著提升随机梯度下降算法的性能，这里用一下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br>scaler = StandardScaler()<br>minist_train_feature_scaler = scaler.fit_transform(minist_train_feature)<br>minist_train_feature_scaler<br></code></pre></td></tr></table></figure><pre><code>D:\Anaconda\Lib\site-packages\sklearn\preprocessing\data.py:617: DataConversionWarning: Data with input dtype int64 were all converted to float64 by StandardScaler.  return self.partial_fit(X, y)D:\Anaconda\Lib\site-packages\sklearn\base.py:462: DataConversionWarning: Data with input dtype int64 were all converted to float64 by StandardScaler.  return self.fit(X, **fit_params).transform(X)array([[ 0.,  0.,  0., ...,  0.,  0.,  0.],       [ 0.,  0.,  0., ...,  0.,  0.,  0.],       [ 0.,  0.,  0., ...,  0.,  0.,  0.],       ...,        [ 0.,  0.,  0., ...,  0.,  0.,  0.],       [ 0.,  0.,  0., ...,  0.,  0.,  0.],       [ 0.,  0.,  0., ...,  0.,  0.,  0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">minist_train_pred = cross_val_predict(sgd_clf,minist_train_feature_scaler,minist_train_target,cv=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">conf_mx = confusion_matrix(minist_train_target,minist_train_pred)<br>conf_mx<br></code></pre></td></tr></table></figure><pre><code>array([[3214,    1,   10,   11,    4,   25,   32,    4,   14,    1],       [   0, 3633,   24,   16,    1,   24,    7,    6,   60,    4],       [  29,   18, 2960,   64,   53,   21,   44,   41,   87,   14],       [  24,   26,   76, 2997,    4,  122,   26,   22,   71,   46],       [  12,   23,   28,    5, 2955,    4,   28,   14,   39,  125],       [  49,   30,   16,  109,   40, 2615,   64,   21,   91,   58],       [  27,   11,   28,    0,   20,   50, 3193,    2,   21,    0],       [  18,   14,   45,   14,   17,    7,    4, 3251,    9,  129],       [  32,   87,   30,  110,    7,   95,   27,   17, 2742,   81],       [  29,   19,   18,   51,  106,   16,    0,  120,   48, 2943]], dtype=int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.matshow(conf_mx, cmap=plt.cm.gray)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%5Coutput_45_0.png" alt="png"></p><p>可以看到上图的主对角线很白，说明分类良好，其他地方有比较明显的暗斑，说明存在着比较大的分类错误<br>然而我们不应该着眼于绝对数值，而是衡量误差，与此对应的是将每个方框出现的比例按颜色深浅绘成图形，这样，颜色越白的地方分类产生的误差越大。<br>这样就能针对性的提升模型的性能，比如多收集某些数据，加强某些数字的区分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">row_sums = conf_mx.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>, keepdims=<span class="hljs-literal">True</span>)<br>norm_conf_mx = conf_mx / row_sums<br><br>np.fill_diagonal(norm_conf_mx, <span class="hljs-number">0</span>)<br>plt.matshow(norm_conf_mx, cmap=plt.cm.gray)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E5%8F%8A%E5%85%B6%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%5Coutput_47_0.png" alt="png"></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>训练线性模型</title>
    <link href="/2019/04/09/%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2019/04/09/%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="用正规方程进行线性回归"><a href="#用正规方程进行线性回归" class="headerlink" title="用正规方程进行线性回归"></a>用正规方程进行线性回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>%matplotlib inline<br><span class="hljs-keyword">import</span> matplotlib<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>X = <span class="hljs-number">2</span>*np.random.rand(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">#单纯的生成2*（0——1）的随机数，规模为100*1</span><br>y = <span class="hljs-number">4</span> + <span class="hljs-number">3</span> * X + np.random.randn(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">#randn服从标准正态分布</span><br>plt.plot(X, y, <span class="hljs-string">&quot;b.&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;$x_1$&quot;</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_1_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">X_b = np.c_[np.ones((<span class="hljs-number">100</span>,<span class="hljs-number">1</span>)), X] <span class="hljs-comment">#添加一列全1列在X左边,不添的话回归方程则没有偏置项</span><br>theta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)<br>theta_best<br></code></pre></td></tr></table></figure><pre><code>array([[ 4.0224133],       [ 3.0375984]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">X_new = np.array([[<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>]])<br>X_new_b = np.c_[np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)),X_new]  <span class="hljs-comment">#这才是实例的向量形式</span><br>y_predict = X_new_b.dot(theta_best)<br>y_predict<br></code></pre></td></tr></table></figure><pre><code>array([[  4.0224133 ],       [ 10.09761009]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(X, y, <span class="hljs-string">&quot;b.&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;$x_1$&quot;</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>])<br>plt.plot(X_new, y_predict,<span class="hljs-string">&quot;r-&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_4_1.png" alt="png"></p><h2 id="用模型进行线性回归"><a href="#用模型进行线性回归" class="headerlink" title="用模型进行线性回归"></a>用模型进行线性回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><br>lin_reg = LinearRegression()<br>lin_reg.fit(X,y)<br>lin_reg.intercept_,lin_reg.coef_  <span class="hljs-comment">#intercept截距，coef系数</span><br></code></pre></td></tr></table></figure><pre><code>(array([ 4.0224133]), array([[ 3.0375984]]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lin_reg.predict(X_new) <span class="hljs-comment">#预测得和正规方程一样，不过这是基于SVD矩阵分解的</span><br></code></pre></td></tr></table></figure><pre><code>array([[  4.0224133 ],       [ 10.09761009]])</code></pre><h2 id="用批量梯度下降进行线性回归"><a href="#用批量梯度下降进行线性回归" class="headerlink" title="用批量梯度下降进行线性回归"></a>用批量梯度下降进行线性回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">eta = <span class="hljs-number">0.1</span> <span class="hljs-comment">#study rate</span><br>n_iterations = <span class="hljs-number">10000</span><br>m = <span class="hljs-number">100</span> <span class="hljs-comment">#the number of train example</span><br>theta = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">#随机初始值</span><br><br><span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_iterations):<br>    gradients = <span class="hljs-number">2</span>/m * X_b.T.dot(X_b.dot(theta) -y)  <span class="hljs-comment">#均方误差的偏导数</span><br>    theta = theta - eta * gradients<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">theta <span class="hljs-comment">#最后得到theta的优化值</span><br></code></pre></td></tr></table></figure><pre><code>array([[ 4.0224133],       [ 3.0375984]])</code></pre><h3 id="探索批量梯度下降"><a href="#探索批量梯度下降" class="headerlink" title="探索批量梯度下降"></a>探索批量梯度下降</h3><p><strong>过程</strong></p><ol><li>随机选取一个theta</li><li>用整个训练集求出一个固定的梯度</li><li>递归优化theta</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">theta_path_bgd = []   <span class="hljs-comment">#存储theta的过程值</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_gradient_descent</span>(<span class="hljs-params">theta, eta, theta_path = <span class="hljs-literal">None</span></span>):</span><br>    m = <span class="hljs-built_in">len</span>(X_b)<br>    plt.plot(X, y, <span class="hljs-string">&quot;b.&quot;</span>)<br>    n_iterations = <span class="hljs-number">1000</span><br>    <span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_iterations):<br>        <span class="hljs-keyword">if</span> iteration &lt; <span class="hljs-number">10</span>:<br>            y_predict = X_new_b.dot(theta)<br>            style = <span class="hljs-string">&quot;b-&quot;</span> <span class="hljs-keyword">if</span> iteration &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;r--&quot;</span><br>            plt.plot(X_new, y_predict, style)<br>        gradients = <span class="hljs-number">2</span>/m * X_b.T.dot(X_b.dot(theta) - y)<br>        theta = theta - eta * gradients<br>        <span class="hljs-keyword">if</span> theta_path <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            theta_path.append(theta)<br>    plt.xlabel(<span class="hljs-string">&quot;$X_1$&quot;</span>, fontsize = <span class="hljs-number">18</span>)<br>    plt.axis([<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">15</span>])<br>    plt.title(<span class="hljs-string">r&quot;$\eta$ = &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(eta), fontsize = <span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">42</span>)<br>theta = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br><br>plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">4</span>))<br>plt.subplot(<span class="hljs-number">131</span>); plot_gradient_descent(theta, eta=<span class="hljs-number">0.02</span>)<br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.subplot(<span class="hljs-number">132</span>); plot_gradient_descent(theta, eta=<span class="hljs-number">0.1</span>, theta_path=theta_path_bgd)<br>plt.subplot(<span class="hljs-number">133</span>); plot_gradient_descent(theta, eta=<span class="hljs-number">0.5</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_14_0.png" alt="png"></p><pre><code>[array([[ 1.86730689],       [ 1.50575404]]), array([[ 2.61930247],       [ 2.39396727]]), array([[ 3.03478759],      .......</code></pre><p>表明学习率$\eta$太低，迭代次数过高且速度缓慢，太高会越偏越远，一致无法达到MSE的最小值</p><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p><strong>过程</strong></p><ol><li>随机选个theta</li><li>在训练集中随机选一个点求出其梯度</li><li>随着迭代次数增加降低学习率</li><li>递归优化theta</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">theta_path_sgd = []<br>m = <span class="hljs-built_in">len</span>(X_b)<br>np.random.seed(<span class="hljs-number">42</span>)<br>n_epochs = <span class="hljs-number">50</span><br>t0, t1 = <span class="hljs-number">5</span>, <span class="hljs-number">50</span>  <span class="hljs-comment"># learning schedule hyperparameters</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">learning_schedule</span>(<span class="hljs-params">t</span>):</span><br>    <span class="hljs-keyword">return</span> t0 / (t + t1)<br><br>theta = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)  <span class="hljs-comment"># random initialization</span><br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_epochs):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        <span class="hljs-keyword">if</span> epoch &lt;<span class="hljs-number">50</span> <span class="hljs-keyword">and</span> i &lt; <span class="hljs-number">20</span>:                    <br>            y_predict = X_new_b.dot(theta)          <br>            style = <span class="hljs-string">&quot;b-&quot;</span> <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;r--&quot;</span>        <br>            plt.plot(X_new, y_predict, style)       <br>    random_index = np.random.randint(m)<br>    xi = X_b[random_index:random_index+<span class="hljs-number">1</span>]<br>    yi = y[random_index:random_index+<span class="hljs-number">1</span>]<br>    gradients = <span class="hljs-number">2</span> * xi.T.dot(xi.dot(theta) - yi)    <span class="hljs-comment">#梯度是随机选一个点进行计算</span><br>    eta = learning_schedule(epoch + i)           <span class="hljs-comment">#学习率随着迭代次数增加而增加</span><br>    theta = theta - eta * gradients<br>    theta_path_sgd.append(theta)                 <br><br>plt.plot(X, y, <span class="hljs-string">&quot;b.&quot;</span>)                                 <br>plt.xlabel(<span class="hljs-string">&quot;$x_1$&quot;</span>, fontsize=<span class="hljs-number">18</span>)                    <br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)          <br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>])                                <br>plt.show()           <span class="hljs-comment">#学习率过早减小导致下图</span><br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_18_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">theta<br></code></pre></td></tr></table></figure><pre><code>array([[ 3.84494505],       [ 3.27773445]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDRegressor<br>sgd_reg = SGDRegressor(max_iter=<span class="hljs-number">50</span>, penalty=<span class="hljs-literal">None</span>, eta0=<span class="hljs-number">0.1</span>, random_state=<span class="hljs-number">42</span>)<br>sgd_reg.fit(X, y.ravel())<br></code></pre></td></tr></table></figure><pre><code>SGDRegressor(alpha=0.0001, average=False, early_stopping=False, epsilon=0.1,       eta0=0.1, fit_intercept=True, l1_ratio=0.15,       learning_rate=&#39;invscaling&#39;, loss=&#39;squared_loss&#39;, max_iter=50,       n_iter=None, n_iter_no_change=5, penalty=None, power_t=0.25,       random_state=42, shuffle=True, tol=None, validation_fraction=0.1,       verbose=0, warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sgd_reg.intercept_,sgd_reg.coef_<br></code></pre></td></tr></table></figure><pre><code>(array([ 4.15885372]), array([ 2.78382451]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y.ravel()<br></code></pre></td></tr></table></figure><pre><code>array([  7.92135333,   8.56691098,   5.99502404,   5.41513681,         6.44148562,   4.86811936,   7.10136485,   3.42339943,         3.67839599,   3.33761007,  10.60499941,   9.85896324,         5.24987976,   6.41309292,   8.27404813,  10.2284994 ,         7.36249471,   5.53075467,   5.82242636,   8.73811634,         7.71831938,   5.68942818,   5.53702494,   9.31348781,         6.38312742,   4.65636541,   6.822189  ,   7.57527945,         5.09018294,   8.20892064,   5.26167648,   9.31611915,         8.25069641,   6.20716153,   4.74007077,   4.21154293,         5.47356181,   3.65836925,   4.49619836,  10.47303379,         4.04746793,   7.79850061,   5.65985419,   4.04421099,         4.87118555,   9.47709443,   4.84031852,   3.17888951,         8.07583515,   7.40261652,   5.9161954 ,   8.05550747,         6.00742713,   7.663237  ,   7.18763962,   6.41589604,         3.6484945 ,   7.5615348 ,   6.90866543,   4.66088275,        11.41090766,   8.55184292,   4.54870059,   5.88453553,         6.50245164,   8.94983926,   8.9836167 ,   7.81270696,         4.19772038,   3.87984973,   5.78906629,   8.39476674,         5.68339181,   8.74063201,   8.90028377,   5.26353559,         5.56526364,   6.71891745,   9.75285961,   5.96614923,         4.63267988,   8.25034491,   8.51859076,   4.67946486,         8.49665663,   5.23937975,   4.98571677,   8.24719202,         9.71403888,   8.88804298,   4.58339356,   9.07247433,         6.27455895,   9.07438272,  10.39908052,   5.87060124,         8.06497982,   4.13650819,   8.94576743,   8.60587748])</code></pre><h2 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">theta_path_mgd = []<br><br>n_iterations = <span class="hljs-number">50</span><br>minibatch_size = <span class="hljs-number">20</span><br><br>np.random.seed(<span class="hljs-number">42</span>)<br>theta = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)  <span class="hljs-comment"># random initialization</span><br><br>t0, t1 = <span class="hljs-number">200</span>, <span class="hljs-number">1000</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">learning_schedule</span>(<span class="hljs-params">t</span>):</span><br>    <span class="hljs-keyword">return</span> t0 / (t + t1)<br><br>t = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_iterations):<br>    shuffled_indices = np.random.permutation(m)<br>    X_b_shuffled = X_b[shuffled_indices]<br>    y_shuffled = y[shuffled_indices]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, m, minibatch_size):<br>        t += <span class="hljs-number">1</span><br>        xi = X_b_shuffled[i:i+minibatch_size]<br>        yi = y_shuffled[i:i+minibatch_size]<br>        gradients = <span class="hljs-number">2</span>/minibatch_size * xi.T.dot(xi.dot(theta) - yi)<br>        eta = learning_schedule(t)<br>        theta = theta - eta * gradients<br>        theta_path_mgd.append(theta)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">theta<br></code></pre></td></tr></table></figure><pre><code>array([[ 4.21526857],       [ 2.81576239]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">theta_path_bgd = np.array(theta_path_bgd)<br>theta_path_sgd = np.array(theta_path_sgd)<br>theta_path_mgd = np.array(theta_path_mgd)<br><br>plt.figure(figsize=(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>))<br>plt.plot(theta_path_sgd[:, <span class="hljs-number">0</span>], theta_path_sgd[:, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;r-s&quot;</span>, linewidth=<span class="hljs-number">1</span>, label=<span class="hljs-string">&quot;Stochastic&quot;</span>)<br>plt.plot(theta_path_mgd[:, <span class="hljs-number">0</span>], theta_path_mgd[:, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;g-+&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&quot;Mini-batch&quot;</span>)<br>plt.plot(theta_path_bgd[:, <span class="hljs-number">0</span>], theta_path_bgd[:, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;b-o&quot;</span>, linewidth=<span class="hljs-number">3</span>, label=<span class="hljs-string">&quot;Batch&quot;</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;upper left&quot;</span>, fontsize=<span class="hljs-number">16</span>)<br>plt.xlabel(<span class="hljs-string">r&quot;$\theta_0$&quot;</span>, fontsize=<span class="hljs-number">20</span>)<br>plt.ylabel(<span class="hljs-string">r&quot;$\theta_1$   &quot;</span>, fontsize=<span class="hljs-number">20</span>, rotation=<span class="hljs-number">0</span>)<br>plt.axis([<span class="hljs-number">2.5</span>, <span class="hljs-number">4.5</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">3.9</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_26_0.png" alt="png"></p><h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> numpy.random <span class="hljs-keyword">as</span> rnd<br>np.random.seed(<span class="hljs-number">42</span>)<br><br>m = <span class="hljs-number">100</span><br>X = <span class="hljs-number">6</span> * np.random.rand(m, <span class="hljs-number">1</span>) - <span class="hljs-number">3</span><br>y = <span class="hljs-number">0.5</span> * X**<span class="hljs-number">2</span> + X + <span class="hljs-number">2</span> + np.random.randn(m, <span class="hljs-number">1</span>)<br><br>plt.plot(X, y, <span class="hljs-string">&quot;b.&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;$x_1$&quot;</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.axis([-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_28_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures<br>poly_features = PolynomialFeatures(degree=<span class="hljs-number">2</span>, include_bias=<span class="hljs-literal">False</span>)<br>X_poly = poly_features.fit_transform(X)<br>X[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><pre><code>array([-0.75275929])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">X_poly[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><pre><code>array([-0.75275929,  0.56664654])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lin_reg = LinearRegression()<br>lin_reg.fit(X_poly, y)<br>lin_reg.intercept_, lin_reg.coef_<br></code></pre></td></tr></table></figure><pre><code>(array([ 1.78134581]), array([[ 0.93366893,  0.56456263]]))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">X_new=np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">100</span>).reshape(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)<br>X_new_poly = poly_features.transform(X_new)<br>y_new = lin_reg.predict(X_new_poly)<br>plt.plot(X, y, <span class="hljs-string">&quot;b.&quot;</span>)<br>plt.plot(X_new, y_new, <span class="hljs-string">&quot;r-&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&quot;Predictions&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;$x_1$&quot;</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;upper left&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.axis([-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_32_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline<br><br><span class="hljs-keyword">for</span> style, width, degree <span class="hljs-keyword">in</span> ((<span class="hljs-string">&quot;g-&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">300</span>), (<span class="hljs-string">&quot;b--&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&quot;r-+&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)):<br>    polybig_features = PolynomialFeatures(degree=degree, include_bias=<span class="hljs-literal">False</span>)<br>    std_scaler = StandardScaler()<br>    lin_reg = LinearRegression()<br>    polynomial_regression = Pipeline([<br>            (<span class="hljs-string">&quot;poly_features&quot;</span>, polybig_features),<br>            (<span class="hljs-string">&quot;std_scaler&quot;</span>, std_scaler),<br>            (<span class="hljs-string">&quot;lin_reg&quot;</span>, lin_reg),<br>        ])<br>    polynomial_regression.fit(X, y)<br>    y_newbig = polynomial_regression.predict(X_new)<br>    plt.plot(X_new, y_newbig, style, label=<span class="hljs-built_in">str</span>(degree), linewidth=width)<br><br>plt.plot(X, y, <span class="hljs-string">&quot;b.&quot;</span>, linewidth=<span class="hljs-number">3</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;upper left&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;$x_1$&quot;</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.axis([-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_33_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_learning_curves</span>(<span class="hljs-params">model, X, y</span>):</span><br>    X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">10</span>)<br>    train_errors, val_errors = [], []<br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(X_train)):<br>        model.fit(X_train[:m], y_train[:m])<br>        y_train_predict = model.predict(X_train[:m])<br>        y_val_predict = model.predict(X_val)<br>        train_errors.append(mean_squared_error(y_train[:m], y_train_predict))<br>        val_errors.append(mean_squared_error(y_val, y_val_predict))<br><br>    plt.plot(np.sqrt(train_errors), <span class="hljs-string">&quot;r-+&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&quot;train&quot;</span>)<br>    plt.plot(np.sqrt(val_errors), <span class="hljs-string">&quot;b-&quot;</span>, linewidth=<span class="hljs-number">3</span>, label=<span class="hljs-string">&quot;val&quot;</span>)<br>    plt.legend(loc=<span class="hljs-string">&quot;upper right&quot;</span>, fontsize=<span class="hljs-number">14</span>)   <span class="hljs-comment"># not shown in the book</span><br>    plt.xlabel(<span class="hljs-string">&quot;Training set size&quot;</span>, fontsize=<span class="hljs-number">14</span>) <span class="hljs-comment"># not shown</span><br>    plt.ylabel(<span class="hljs-string">&quot;RMSE&quot;</span>, fontsize=<span class="hljs-number">14</span>)              <span class="hljs-comment"># not shown</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lin_reg = LinearRegression()<br>plot_learning_curves(lin_reg, X, y)<br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>])                         <span class="hljs-comment"># not shown in the book</span><br>plt.show()                                      <span class="hljs-comment"># not shown</span><br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_35_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline<br><br>polynomial_regression = Pipeline([<br>        (<span class="hljs-string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="hljs-number">10</span>, include_bias=<span class="hljs-literal">False</span>)),<br>        (<span class="hljs-string">&quot;lin_reg&quot;</span>, LinearRegression()),<br>    ])<br><br>plot_learning_curves(polynomial_regression, X, y)<br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">80</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>])           <span class="hljs-comment"># not shown</span><br>plt.show()     <br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_36_0.png" alt="png"></p><h2 id="正则化模型"><a href="#正则化模型" class="headerlink" title="正则化模型"></a>正则化模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br><br>np.random.seed(<span class="hljs-number">42</span>)<br>m = <span class="hljs-number">20</span><br>X = <span class="hljs-number">3</span> * np.random.rand(m, <span class="hljs-number">1</span>)<br>y = <span class="hljs-number">1</span> + <span class="hljs-number">0.5</span> * X + np.random.randn(m, <span class="hljs-number">1</span>) / <span class="hljs-number">1.5</span><br>X_new = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">100</span>).reshape(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_model</span>(<span class="hljs-params">model_class, polynomial, alphas, **model_kargs</span>):</span><br>    <span class="hljs-keyword">for</span> alpha, style <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(alphas, (<span class="hljs-string">&quot;b-&quot;</span>, <span class="hljs-string">&quot;g--&quot;</span>, <span class="hljs-string">&quot;r:&quot;</span>)):<br>        model = model_class(alpha, **model_kargs) <span class="hljs-keyword">if</span> alpha &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> LinearRegression()<br>        <span class="hljs-keyword">if</span> polynomial:<br>            model = Pipeline([<br>                    (<span class="hljs-string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="hljs-number">10</span>, include_bias=<span class="hljs-literal">False</span>)),<br>                    (<span class="hljs-string">&quot;std_scaler&quot;</span>, StandardScaler()),<br>                    (<span class="hljs-string">&quot;regul_reg&quot;</span>, model),<br>                ])<br>        model.fit(X, y)<br>        y_new_regul = model.predict(X_new)<br>        lw = <span class="hljs-number">2</span> <span class="hljs-keyword">if</span> alpha &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>        plt.plot(X_new, y_new_regul, style, linewidth=lw, label=<span class="hljs-string">r&quot;$\alpha = &#123;&#125;$&quot;</span>.<span class="hljs-built_in">format</span>(alpha))<br>    plt.plot(X, y, <span class="hljs-string">&quot;b.&quot;</span>, linewidth=<span class="hljs-number">3</span>)<br>    plt.legend(loc=<span class="hljs-string">&quot;upper left&quot;</span>, fontsize=<span class="hljs-number">15</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;$x_1$&quot;</span>, fontsize=<span class="hljs-number">18</span>)<br>    plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>])<br><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plot_model(Ridge, polynomial=<span class="hljs-literal">False</span>, alphas=(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>), random_state=<span class="hljs-number">42</span>)<br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.subplot(<span class="hljs-number">122</span>)<br>plot_model(Ridge, polynomial=<span class="hljs-literal">True</span>, alphas=(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>**-<span class="hljs-number">5</span>, <span class="hljs-number">1</span>), random_state=<span class="hljs-number">42</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_38_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br>ridge_reg = Ridge(alpha=<span class="hljs-number">1</span>, solver=<span class="hljs-string">&quot;cholesky&quot;</span>, random_state=<span class="hljs-number">42</span>)<br>ridge_reg.fit(X, y)<br>ridge_reg.predict([[<span class="hljs-number">1.5</span>]])<br></code></pre></td></tr></table></figure><pre><code>array([[ 1.55071465]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">sgd_reg = SGDRegressor(max_iter=<span class="hljs-number">5</span>, penalty=<span class="hljs-string">&quot;l2&quot;</span>, random_state=<span class="hljs-number">42</span>)<br>sgd_reg.fit(X, y.ravel())<br>sgd_reg.predict([[<span class="hljs-number">1.5</span>]])<br></code></pre></td></tr></table></figure><pre><code>array([ 1.13500145])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ridge_reg = Ridge(alpha=<span class="hljs-number">1</span>, solver=<span class="hljs-string">&quot;sag&quot;</span>, random_state=<span class="hljs-number">42</span>)<br>ridge_reg.fit(X, y)<br>ridge_reg.predict([[<span class="hljs-number">1.5</span>]])<br></code></pre></td></tr></table></figure><pre><code>array([[ 1.5507201]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Lasso<br><br>plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plot_model(Lasso, polynomial=<span class="hljs-literal">False</span>, alphas=(<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1</span>), random_state=<span class="hljs-number">42</span>)<br>plt.ylabel(<span class="hljs-string">&quot;$y$&quot;</span>, rotation=<span class="hljs-number">0</span>, fontsize=<span class="hljs-number">18</span>)<br>plt.subplot(<span class="hljs-number">122</span>)<br>plot_model(Lasso, polynomial=<span class="hljs-literal">True</span>, alphas=(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>**-<span class="hljs-number">7</span>, <span class="hljs-number">1</span>), tol=<span class="hljs-number">1</span>, random_state=<span class="hljs-number">42</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_42_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Lasso<br>lasso_reg = Lasso(alpha=<span class="hljs-number">0.1</span>)<br>lasso_reg.fit(X, y)<br>lasso_reg.predict([[<span class="hljs-number">1.5</span>]])<br></code></pre></td></tr></table></figure><pre><code>array([ 1.53788174])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> ElasticNet<br>elastic_net = ElasticNet(alpha=<span class="hljs-number">0.1</span>, l1_ratio=<span class="hljs-number">0.5</span>, random_state=<span class="hljs-number">42</span>)<br>elastic_net.fit(X, y)<br>elastic_net.predict([[<span class="hljs-number">1.5</span>]])<br></code></pre></td></tr></table></figure><pre><code>array([ 1.54333232])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">42</span>)<br>m = <span class="hljs-number">100</span><br>X = <span class="hljs-number">6</span> * np.random.rand(m, <span class="hljs-number">1</span>) - <span class="hljs-number">3</span><br>y = <span class="hljs-number">2</span> + X + <span class="hljs-number">0.5</span> * X**<span class="hljs-number">2</span> + np.random.randn(m, <span class="hljs-number">1</span>)<br><br>X_train, X_val, y_train, y_val = train_test_split(X[:<span class="hljs-number">50</span>], y[:<span class="hljs-number">50</span>].ravel(), test_size=<span class="hljs-number">0.5</span>, random_state=<span class="hljs-number">10</span>)<br><br>poly_scaler = Pipeline([<br>        (<span class="hljs-string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="hljs-number">90</span>, include_bias=<span class="hljs-literal">False</span>)),<br>        (<span class="hljs-string">&quot;std_scaler&quot;</span>, StandardScaler()),<br>    ])<br><br>X_train_poly_scaled = poly_scaler.fit_transform(X_train)<br>X_val_poly_scaled = poly_scaler.transform(X_val)<br><br>sgd_reg = SGDRegressor(max_iter=<span class="hljs-number">1</span>,<br>                       penalty=<span class="hljs-literal">None</span>,<br>                       eta0=<span class="hljs-number">0.0005</span>,<br>                       warm_start=<span class="hljs-literal">True</span>,<br>                       learning_rate=<span class="hljs-string">&quot;constant&quot;</span>,<br>                       random_state=<span class="hljs-number">42</span>)<br><br>n_epochs = <span class="hljs-number">500</span><br>train_errors, val_errors = [], []<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_epochs):<br>    sgd_reg.fit(X_train_poly_scaled, y_train)<br>    y_train_predict = sgd_reg.predict(X_train_poly_scaled)<br>    y_val_predict = sgd_reg.predict(X_val_poly_scaled)<br>    train_errors.append(mean_squared_error(y_train, y_train_predict))<br>    val_errors.append(mean_squared_error(y_val, y_val_predict))<br><br>best_epoch = np.argmin(val_errors)<br>best_val_rmse = np.sqrt(val_errors[best_epoch])<br><br>plt.annotate(<span class="hljs-string">&#x27;Best model&#x27;</span>,<br>             xy=(best_epoch, best_val_rmse),<br>             xytext=(best_epoch, best_val_rmse + <span class="hljs-number">1</span>),<br>             ha=<span class="hljs-string">&quot;center&quot;</span>,<br>             arrowprops=<span class="hljs-built_in">dict</span>(facecolor=<span class="hljs-string">&#x27;black&#x27;</span>, shrink=<span class="hljs-number">0.05</span>),<br>             fontsize=<span class="hljs-number">16</span>,<br>            )<br><br>best_val_rmse -= <span class="hljs-number">0.03</span>  <span class="hljs-comment"># just to make the graph look better</span><br>plt.plot([<span class="hljs-number">0</span>, n_epochs], [best_val_rmse, best_val_rmse], <span class="hljs-string">&quot;k:&quot;</span>, linewidth=<span class="hljs-number">2</span>)<br>plt.plot(np.sqrt(val_errors), <span class="hljs-string">&quot;b-&quot;</span>, linewidth=<span class="hljs-number">3</span>, label=<span class="hljs-string">&quot;Validation set&quot;</span>)<br>plt.plot(np.sqrt(train_errors), <span class="hljs-string">&quot;r--&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&quot;Training set&quot;</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;upper right&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Epoch&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.ylabel(<span class="hljs-string">&quot;RMSE&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_45_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.base <span class="hljs-keyword">import</span> clone<br>sgd_reg = SGDRegressor(max_iter=<span class="hljs-number">1</span>, warm_start=<span class="hljs-literal">True</span>, penalty=<span class="hljs-literal">None</span>,<br>                       learning_rate=<span class="hljs-string">&quot;constant&quot;</span>, eta0=<span class="hljs-number">0.0005</span>, random_state=<span class="hljs-number">42</span>)<br><br>minimum_val_error = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>best_epoch = <span class="hljs-literal">None</span><br>best_model = <span class="hljs-literal">None</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>    sgd_reg.fit(X_train_poly_scaled, y_train)  <span class="hljs-comment"># continues where it left off</span><br>    y_val_predict = sgd_reg.predict(X_val_poly_scaled)<br>    val_error = mean_squared_error(y_val, y_val_predict)<br>    <span class="hljs-keyword">if</span> val_error &lt; minimum_val_error:<br>        minimum_val_error = val_error<br>        best_epoch = epoch<br>        best_model = clone(sgd_reg)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">best_epoch, best_model<br></code></pre></td></tr></table></figure><pre><code>(239, SGDRegressor(alpha=0.0001, average=False, early_stopping=False, epsilon=0.1,        eta0=0.0005, fit_intercept=True, l1_ratio=0.15,        learning_rate=&#39;constant&#39;, loss=&#39;squared_loss&#39;, max_iter=1,        n_iter=None, n_iter_no_change=5, penalty=None, power_t=0.25,        random_state=42, shuffle=True, tol=None, validation_fraction=0.1,        verbose=0, warm_start=True))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">t1a, t1b, t2a, t2b = -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1.5</span>, <span class="hljs-number">1.5</span><br><br><span class="hljs-comment"># ignoring bias term</span><br>t1s = np.linspace(t1a, t1b, <span class="hljs-number">500</span>)<br>t2s = np.linspace(t2a, t2b, <span class="hljs-number">500</span>)<br>t1, t2 = np.meshgrid(t1s, t2s)<br>T = np.c_[t1.ravel(), t2.ravel()]<br>Xr = np.array([[-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [-<span class="hljs-number">0.3</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>]])<br>yr = <span class="hljs-number">2</span> * Xr[:, :<span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span> * Xr[:, <span class="hljs-number">1</span>:]<br><br>J = (<span class="hljs-number">1</span>/<span class="hljs-built_in">len</span>(Xr) * np.<span class="hljs-built_in">sum</span>((T.dot(Xr.T) - yr.T)**<span class="hljs-number">2</span>, axis=<span class="hljs-number">1</span>)).reshape(t1.shape)<br><br>N1 = np.linalg.norm(T, <span class="hljs-built_in">ord</span>=<span class="hljs-number">1</span>, axis=<span class="hljs-number">1</span>).reshape(t1.shape)<br>N2 = np.linalg.norm(T, <span class="hljs-built_in">ord</span>=<span class="hljs-number">2</span>, axis=<span class="hljs-number">1</span>).reshape(t1.shape)<br><br>t_min_idx = np.unravel_index(np.argmin(J), J.shape)<br>t1_min, t2_min = t1[t_min_idx], t2[t_min_idx]<br><br>t_init = np.array([[<span class="hljs-number">0.25</span>], [-<span class="hljs-number">1</span>]])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bgd_path</span>(<span class="hljs-params">theta, X, y, l1, l2, core = <span class="hljs-number">1</span>, eta = <span class="hljs-number">0.1</span>, n_iterations = <span class="hljs-number">50</span></span>):</span><br>    path = [theta]<br>    <span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_iterations):<br>        gradients = core * <span class="hljs-number">2</span>/<span class="hljs-built_in">len</span>(X) * X.T.dot(X.dot(theta) - y) + l1 * np.sign(theta) + <span class="hljs-number">2</span> * l2 * theta<br><br>        theta = theta - eta * gradients<br>        path.append(theta)<br>    <span class="hljs-keyword">return</span> np.array(path)<br><br>plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">8</span>))<br><span class="hljs-keyword">for</span> i, N, l1, l2, title <span class="hljs-keyword">in</span> ((<span class="hljs-number">0</span>, N1, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Lasso&quot;</span>), (<span class="hljs-number">1</span>, N2, <span class="hljs-number">0</span>,  <span class="hljs-number">0.1</span>, <span class="hljs-string">&quot;Ridge&quot;</span>)):<br>    JR = J + l1 * N1 + l2 * N2**<span class="hljs-number">2</span><br>    <br>    tr_min_idx = np.unravel_index(np.argmin(JR), JR.shape)<br>    t1r_min, t2r_min = t1[tr_min_idx], t2[tr_min_idx]<br><br>    levelsJ=(np.exp(np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>)) - <span class="hljs-number">1</span>) * (np.<span class="hljs-built_in">max</span>(J) - np.<span class="hljs-built_in">min</span>(J)) + np.<span class="hljs-built_in">min</span>(J)<br>    levelsJR=(np.exp(np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>)) - <span class="hljs-number">1</span>) * (np.<span class="hljs-built_in">max</span>(JR) - np.<span class="hljs-built_in">min</span>(JR)) + np.<span class="hljs-built_in">min</span>(JR)<br>    levelsN=np.linspace(<span class="hljs-number">0</span>, np.<span class="hljs-built_in">max</span>(N), <span class="hljs-number">10</span>)<br>    <br>    path_J = bgd_path(t_init, Xr, yr, l1=<span class="hljs-number">0</span>, l2=<span class="hljs-number">0</span>)<br>    path_JR = bgd_path(t_init, Xr, yr, l1, l2)<br>    path_N = bgd_path(t_init, Xr, yr, np.sign(l1)/<span class="hljs-number">3</span>, np.sign(l2), core=<span class="hljs-number">0</span>)<br><br>    plt.subplot(<span class="hljs-number">221</span> + i * <span class="hljs-number">2</span>)<br>    plt.grid(<span class="hljs-literal">True</span>)<br>    plt.axhline(y=<span class="hljs-number">0</span>, color=<span class="hljs-string">&#x27;k&#x27;</span>)<br>    plt.axvline(x=<span class="hljs-number">0</span>, color=<span class="hljs-string">&#x27;k&#x27;</span>)<br>    plt.contourf(t1, t2, J, levels=levelsJ, alpha=<span class="hljs-number">0.9</span>)<br>    plt.contour(t1, t2, N, levels=levelsN)<br>    plt.plot(path_J[:, <span class="hljs-number">0</span>], path_J[:, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;w-o&quot;</span>)<br>    plt.plot(path_N[:, <span class="hljs-number">0</span>], path_N[:, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;y-^&quot;</span>)<br>    plt.plot(t1_min, t2_min, <span class="hljs-string">&quot;rs&quot;</span>)<br>    plt.title(<span class="hljs-string">r&quot;$\ell_&#123;&#125;$ penalty&quot;</span>.<span class="hljs-built_in">format</span>(i + <span class="hljs-number">1</span>), fontsize=<span class="hljs-number">16</span>)<br>    plt.axis([t1a, t1b, t2a, t2b])<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>        plt.xlabel(<span class="hljs-string">r&quot;$\theta_1$&quot;</span>, fontsize=<span class="hljs-number">20</span>)<br>    plt.ylabel(<span class="hljs-string">r&quot;$\theta_2$&quot;</span>, fontsize=<span class="hljs-number">20</span>, rotation=<span class="hljs-number">0</span>)<br><br>    plt.subplot(<span class="hljs-number">222</span> + i * <span class="hljs-number">2</span>)<br>    plt.grid(<span class="hljs-literal">True</span>)<br>    plt.axhline(y=<span class="hljs-number">0</span>, color=<span class="hljs-string">&#x27;k&#x27;</span>)<br>    plt.axvline(x=<span class="hljs-number">0</span>, color=<span class="hljs-string">&#x27;k&#x27;</span>)<br>    plt.contourf(t1, t2, JR, levels=levelsJR, alpha=<span class="hljs-number">0.9</span>)<br>    plt.plot(path_JR[:, <span class="hljs-number">0</span>], path_JR[:, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;w-o&quot;</span>)<br>    plt.plot(t1r_min, t2r_min, <span class="hljs-string">&quot;rs&quot;</span>)<br>    plt.title(title, fontsize=<span class="hljs-number">16</span>)<br>    plt.axis([t1a, t1b, t2a, t2b])<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>        plt.xlabel(<span class="hljs-string">r&quot;$\theta_1$&quot;</span>, fontsize=<span class="hljs-number">20</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_50_0.png" alt="png"></p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">t = np.linspace(-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br>sig = <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-t))<br>plt.figure(figsize=(<span class="hljs-number">9</span>, <span class="hljs-number">3</span>))<br>plt.plot([-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-string">&quot;k-&quot;</span>)<br>plt.plot([-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], <span class="hljs-string">&quot;k:&quot;</span>)<br>plt.plot([-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;k:&quot;</span>)<br>plt.plot([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [-<span class="hljs-number">1.1</span>, <span class="hljs-number">1.1</span>], <span class="hljs-string">&quot;k-&quot;</span>)<br>plt.plot(t, sig, <span class="hljs-string">&quot;b-&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">r&quot;$\sigma(t) = \frac&#123;1&#125;&#123;1 + e^&#123;-t&#125;&#125;$&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;t&quot;</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;upper left&quot;</span>, fontsize=<span class="hljs-number">20</span>)<br>plt.axis([-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, -<span class="hljs-number">0.1</span>, <span class="hljs-number">1.1</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_52_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br>iris = datasets.load_iris()<br><span class="hljs-built_in">list</span>(iris.keys())<br></code></pre></td></tr></table></figure><pre><code>[&#39;data&#39;, &#39;target&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;feature_names&#39;, &#39;filename&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(iris.DESCR)<br></code></pre></td></tr></table></figure><pre><code>.. _iris_dataset:Iris plants dataset--------------------**Data Set Characteristics:**    :Number of Instances: 150 (50 in each of three classes)    :Number of Attributes: 4 numeric, predictive attributes and the class    :Attribute Information:        - sepal length in cm        - sepal width in cm        - petal length in cm        - petal width in cm        - class:                - Iris-Setosa                - Iris-Versicolour                - Iris-Virginica    :Summary Statistics:    ============== ==== ==== ======= ===== ====================                    Min  Max   Mean    SD   Class Correlation    ============== ==== ==== ======= ===== ====================    sepal length:   4.3  7.9   5.84   0.83    0.7826    sepal width:    2.0  4.4   3.05   0.43   -0.4194    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)    petal width:    0.1  2.5   1.20   0.76    0.9565  (high!)    ============== ==== ==== ======= ===== ====================    :Missing Attribute Values: None    :Class Distribution: 33.3% for each of 3 classes.    :Creator: R.A. Fisher    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)    :Date: July, 1988The famous Iris database, first used by Sir R.A. Fisher. The dataset is takenfrom Fisher&#39;s paper. Note that it&#39;s the same as in R, but not as in the UCIMachine Learning Repository, which has two wrong data points.This is perhaps the best known database to be found in thepattern recognition literature.  Fisher&#39;s paper is a classic in the field andis referenced frequently to this day.  (See Duda &amp; Hart, for example.)  Thedata set contains 3 classes of 50 instances each, where each class refers to atype of iris plant.  One class is linearly separable from the other 2; thelatter are NOT linearly separable from each other... topic:: References   - Fisher, R.A. &quot;The use of multiple measurements in taxonomic problems&quot;     Annual Eugenics, 7, Part II, 179-188 (1936); also in &quot;Contributions to     Mathematical Statistics&quot; (John Wiley, NY, 1950).   - Duda, R.O., &amp; Hart, P.E. (1973) Pattern Classification and Scene Analysis.     (Q327.D83) John Wiley &amp; Sons.  ISBN 0-471-22361-1.  See page 218.   - Dasarathy, B.V. (1980) &quot;Nosing Around the Neighborhood: A New System     Structure and Classification Rule for Recognition in Partially Exposed     Environments&quot;.  IEEE Transactions on Pattern Analysis and Machine     Intelligence, Vol. PAMI-2, No. 1, 67-71.   - Gates, G.W. (1972) &quot;The Reduced Nearest Neighbor Rule&quot;.  IEEE Transactions     on Information Theory, May 1972, 431-433.   - See also: 1988 MLC Proceedings, 54-64.  Cheeseman et al&quot;s AUTOCLASS II     conceptual clustering system finds 3 classes in the data.   - Many, many more ...</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X = iris[<span class="hljs-string">&quot;data&quot;</span>][:, <span class="hljs-number">3</span>:]  <span class="hljs-comment"># petal width</span><br>y = (iris[<span class="hljs-string">&quot;target&quot;</span>] == <span class="hljs-number">2</span>).astype(np.<span class="hljs-built_in">int</span>)  <span class="hljs-comment"># 1 if Iris-Virginica, else 0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br>log_reg = LogisticRegression(random_state=<span class="hljs-number">42</span>)<br>log_reg.fit(X, y)<br></code></pre></td></tr></table></figure><pre><code>D:\Anaconda\Lib\site-packages\sklearn\linear_model\logistic.py:432: FutureWarning: Default solver will be changed to &#39;lbfgs&#39; in 0.22. Specify a solver to silence this warning.  FutureWarning)LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,          intercept_scaling=1, max_iter=100, multi_class=&#39;warn&#39;,          n_jobs=None, penalty=&#39;l2&#39;, random_state=42, solver=&#39;warn&#39;,          tol=0.0001, verbose=0, warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X_new = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1000</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>y_proba = log_reg.predict_proba(X_new)<br><br>plt.plot(X_new, y_proba[:, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;g-&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&quot;Iris-Virginica&quot;</span>)<br>plt.plot(X_new, y_proba[:, <span class="hljs-number">0</span>], <span class="hljs-string">&quot;b--&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&quot;Not Iris-Virginica&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code>[&lt;matplotlib.lines.Line2D at 0x24cd5d7d8d0&gt;]</code></pre><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_57_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">X_new = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1000</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>y_proba = log_reg.predict_proba(X_new)<br>decision_boundary = X_new[y_proba[:, <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0.5</span>][<span class="hljs-number">0</span>]<br><br>plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">3</span>))<br>plt.plot(X[y==<span class="hljs-number">0</span>], y[y==<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bs&quot;</span>)<br>plt.plot(X[y==<span class="hljs-number">1</span>], y[y==<span class="hljs-number">1</span>], <span class="hljs-string">&quot;g^&quot;</span>)<br>plt.plot([decision_boundary, decision_boundary], [-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">&quot;k:&quot;</span>, linewidth=<span class="hljs-number">2</span>)<br>plt.plot(X_new, y_proba[:, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;g-&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&quot;Iris-Virginica&quot;</span>)<br>plt.plot(X_new, y_proba[:, <span class="hljs-number">0</span>], <span class="hljs-string">&quot;b--&quot;</span>, linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">&quot;Not Iris-Virginica&quot;</span>)<br>plt.text(decision_boundary+<span class="hljs-number">0.02</span>, <span class="hljs-number">0.15</span>, <span class="hljs-string">&quot;Decision  boundary&quot;</span>, fontsize=<span class="hljs-number">14</span>, color=<span class="hljs-string">&quot;k&quot;</span>, ha=<span class="hljs-string">&quot;center&quot;</span>)<br>plt.arrow(decision_boundary, <span class="hljs-number">0.08</span>, -<span class="hljs-number">0.3</span>, <span class="hljs-number">0</span>, head_width=<span class="hljs-number">0.05</span>, head_length=<span class="hljs-number">0.1</span>, fc=<span class="hljs-string">&#x27;b&#x27;</span>, ec=<span class="hljs-string">&#x27;b&#x27;</span>)<br>plt.arrow(decision_boundary, <span class="hljs-number">0.92</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0</span>, head_width=<span class="hljs-number">0.05</span>, head_length=<span class="hljs-number">0.1</span>, fc=<span class="hljs-string">&#x27;g&#x27;</span>, ec=<span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Petal width (cm)&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Probability&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;center left&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">0.02</span>, <span class="hljs-number">1.02</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_58_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">decision_boundary<br></code></pre></td></tr></table></figure><pre><code>array([ 1.61561562])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">log_reg.predict([[<span class="hljs-number">1.7</span>], [<span class="hljs-number">1.5</span>]])<br></code></pre></td></tr></table></figure><pre><code>array([1, 0])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br>X = iris[<span class="hljs-string">&quot;data&quot;</span>][:, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)]  <span class="hljs-comment"># petal length, petal width</span><br>y = (iris[<span class="hljs-string">&quot;target&quot;</span>] == <span class="hljs-number">2</span>).astype(np.<span class="hljs-built_in">int</span>)<br><br>log_reg = LogisticRegression(C=<span class="hljs-number">10</span>**<span class="hljs-number">10</span>, random_state=<span class="hljs-number">42</span>)<br>log_reg.fit(X, y)<br><br>x0, x1 = np.meshgrid(<br>        np.linspace(<span class="hljs-number">2.9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">500</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>        np.linspace(<span class="hljs-number">0.8</span>, <span class="hljs-number">2.7</span>, <span class="hljs-number">200</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>    )<br>X_new = np.c_[x0.ravel(), x1.ravel()]<br><br>y_proba = log_reg.predict_proba(X_new)<br><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>))<br>plt.plot(X[y==<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], X[y==<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;bs&quot;</span>)<br>plt.plot(X[y==<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], X[y==<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;g^&quot;</span>)<br><br>zz = y_proba[:, <span class="hljs-number">1</span>].reshape(x0.shape)<br>contour = plt.contour(x0, x1, zz, cmap=plt.cm.brg)<br><br><br>left_right = np.array([<span class="hljs-number">2.9</span>, <span class="hljs-number">7</span>])<br>boundary = -(log_reg.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * left_right + log_reg.intercept_[<span class="hljs-number">0</span>]) / log_reg.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><br>plt.clabel(contour, inline=<span class="hljs-number">1</span>, fontsize=<span class="hljs-number">12</span>)<br>plt.plot(left_right, boundary, <span class="hljs-string">&quot;k--&quot;</span>, linewidth=<span class="hljs-number">3</span>)<br>plt.text(<span class="hljs-number">3.5</span>, <span class="hljs-number">1.5</span>, <span class="hljs-string">&quot;Not Iris-Virginica&quot;</span>, fontsize=<span class="hljs-number">14</span>, color=<span class="hljs-string">&quot;b&quot;</span>, ha=<span class="hljs-string">&quot;center&quot;</span>)<br>plt.text(<span class="hljs-number">6.5</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">&quot;Iris-Virginica&quot;</span>, fontsize=<span class="hljs-number">14</span>, color=<span class="hljs-string">&quot;g&quot;</span>, ha=<span class="hljs-string">&quot;center&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Petal length&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Petal width&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.axis([<span class="hljs-number">2.9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">2.7</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><pre><code>D:\Anaconda\Lib\site-packages\sklearn\linear_model\logistic.py:432: FutureWarning: Default solver will be changed to &#39;lbfgs&#39; in 0.22. Specify a solver to silence this warning.  FutureWarning)</code></pre><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_61_1.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = iris[<span class="hljs-string">&quot;data&quot;</span>][:, (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)]  <span class="hljs-comment"># petal length, petal width</span><br>y = iris[<span class="hljs-string">&quot;target&quot;</span>]<br><br>softmax_reg = LogisticRegression(multi_class=<span class="hljs-string">&quot;multinomial&quot;</span>,solver=<span class="hljs-string">&quot;lbfgs&quot;</span>, C=<span class="hljs-number">10</span>, random_state=<span class="hljs-number">42</span>)<br>softmax_reg.fit(X, y)<br></code></pre></td></tr></table></figure><pre><code>LogisticRegression(C=10, class_weight=None, dual=False, fit_intercept=True,          intercept_scaling=1, max_iter=100, multi_class=&#39;multinomial&#39;,          n_jobs=None, penalty=&#39;l2&#39;, random_state=42, solver=&#39;lbfgs&#39;,          tol=0.0001, verbose=0, warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">x0, x1 = np.meshgrid(<br>        np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">500</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>        np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">3.5</span>, <span class="hljs-number">200</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>    )<br>X_new = np.c_[x0.ravel(), x1.ravel()]<br><br><br>y_proba = softmax_reg.predict_proba(X_new)<br>y_predict = softmax_reg.predict(X_new)<br><br>zz1 = y_proba[:, <span class="hljs-number">1</span>].reshape(x0.shape)<br>zz = y_predict.reshape(x0.shape)<br><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>))<br>plt.plot(X[y==<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], X[y==<span class="hljs-number">2</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;g^&quot;</span>, label=<span class="hljs-string">&quot;Iris-Virginica&quot;</span>)<br>plt.plot(X[y==<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], X[y==<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;bs&quot;</span>, label=<span class="hljs-string">&quot;Iris-Versicolor&quot;</span>)<br>plt.plot(X[y==<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], X[y==<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-string">&quot;yo&quot;</span>, label=<span class="hljs-string">&quot;Iris-Setosa&quot;</span>)<br><br><span class="hljs-keyword">from</span> matplotlib.colors <span class="hljs-keyword">import</span> ListedColormap<br>custom_cmap = ListedColormap([<span class="hljs-string">&#x27;#fafab0&#x27;</span>,<span class="hljs-string">&#x27;#9898ff&#x27;</span>,<span class="hljs-string">&#x27;#a0faa0&#x27;</span>])<br><br>plt.contourf(x0, x1, zz, cmap=custom_cmap)<br>contour = plt.contour(x0, x1, zz1, cmap=plt.cm.brg)<br>plt.clabel(contour, inline=<span class="hljs-number">1</span>, fontsize=<span class="hljs-number">12</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Petal length&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Petal width&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.legend(loc=<span class="hljs-string">&quot;center left&quot;</span>, fontsize=<span class="hljs-number">14</span>)<br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3.5</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E8%AE%AD%E7%BB%83%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%5Coutput_63_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">softmax_reg.predict([[<span class="hljs-number">5</span>, <span class="hljs-number">2</span>]])<br></code></pre></td></tr></table></figure><pre><code>array([2])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">softmax_reg.predict_proba([[<span class="hljs-number">5</span>, <span class="hljs-number">2</span>]])<br></code></pre></td></tr></table></figure><pre><code>array([[  6.38014896e-07,   5.74929995e-02,   9.42506362e-01]])</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基本流程</title>
    <link href="/2019/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"/>
    <url>/2019/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>以泰坦尼克号乘客存活率为例</p><p>大纲：</p><ol><li>宏观上定义问题，明确目标，选择性能指标，检查假设的合理性。</li><li>建立工作空间，加载数据集，浏览数据结构和含义，划分测试集。</li><li>探索性数据可视化，发现数据之间的关系，实验数据组合。</li><li>数据清洗，处理非数字类型数据，建立处理管道，为后续算法做准备。</li><li>选择和训练模型，计算性能指标，进行交叉验证，保存模型。</li><li>优化模型，网格搜索，随即搜索，集成方法等，并分析出最好的模型或模型组合，计算出性能指标。</li><li>加载，监控，维持系统的稳定性。</li></ol><h1 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h1><p>问题描述： RMS泰坦尼克号的沉没是历史上最臭名昭着的沉船之一。 1912年4月15日，在她的处女航中，泰坦尼克号在与冰山相撞后沉没，在2224名船员造成1502人死亡。 这场耸人听闻的悲剧震惊了国际社会，并为船舶制定了更好的安全规定。船舶残骸造成这种生命损失的原因之一是乘客和船员没有足够的救生艇。 虽然有一些运气因素涉及到沉没，但有些人比其他人更容易生存，比如妇女，儿童和上流社会。在这次挑战中，我们要求您完成对哪些人可能存活的分析。 特别是，我们要求您运用机器学习工具来预测哪些乘客在悲剧中幸存下来。 </p><ul><li>目标： 通过数据预测一个人是否会在此次灾难中存活。 </li><li>性能指标： 这是一个二分类问题，将一个人分为是生，还是死。性能指标可以用精度，召回率来表征。</li></ul><h1 id="速览数据结构"><a href="#速览数据结构" class="headerlink" title="速览数据结构"></a>速览数据结构</h1><ul><li>工作空间：新建一个文件夹，创建代码文件夹，数据集文件夹，图表文件夹</li><li>加载数据集：可以线上加载，也可以线下，这里已直接下载到本地数据集文件夹中</li><li>代码空间： 加载相应的库，设置路径，图表大小等相应的格式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib<br>%matplotlib inline<br>plt.rcParams[<span class="hljs-string">&#x27;axes.labelsize&#x27;</span>] = <span class="hljs-number">14</span><br>plt.rcParams[<span class="hljs-string">&#x27;xtick.labelsize&#x27;</span>] = <span class="hljs-number">12</span><br>plt.rcParams[<span class="hljs-string">&#x27;ytick.labelsize&#x27;</span>] = <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><h2 id="粗略信息"><a href="#粗略信息" class="headerlink" title="粗略信息"></a>粗略信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#加载数据集，已放在工作目录下</span><br>dataset = pd.read_csv(<span class="hljs-string">&quot;titanic.csv&quot;</span>)<br><span class="hljs-comment">#常用的几个查看数据集的方式</span><br>dataset.head(<span class="hljs-number">20</span>)<br><span class="hljs-comment">#pclass-客舱等级</span><br><span class="hljs-comment">#slibsp-兄弟姐妹数/配偶数</span><br><span class="hljs-comment">#parch-父母数/子女数</span><br><span class="hljs-comment">#ticket-船票编号</span><br><span class="hljs-comment">#fare-船票价格</span><br><span class="hljs-comment">#cabin-客舱号</span><br><span class="hljs-comment">#embarket-登船港口</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dataset.info()<br><span class="hljs-comment">#由此易得，年龄，船票价格，客舱号，登船港口有缺失值，其中年龄和客舱号缺失严重。</span><br></code></pre></td></tr></table></figure><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 1309 entries, 0 to 1308Data columns (total 11 columns):pclass      1309 non-null int64name        1309 non-null objectsex         1309 non-null objectage         1046 non-null float64sibsp       1309 non-null int64parch       1309 non-null int64ticket      1309 non-null objectfare        1308 non-null float64cabin       295 non-null objectembarked    1307 non-null objectsurvived    1309 non-null int64dtypes: float64(2), int64(4), object(5)memory usage: 112.6+ KB</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dataset.describe()<br><span class="hljs-comment">#看出年龄有问题，最小0.1667,怎么还精确到小数点后几位的？费用也需要注意一下，免费上船？</span><br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>pclass</th>      <th>age</th>      <th>sibsp</th>      <th>parch</th>      <th>fare</th>      <th>survived</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>1309.000000</td>      <td>1046.000000</td>      <td>1309.000000</td>      <td>1309.000000</td>      <td>1308.000000</td>      <td>1309.000000</td>    </tr>    <tr>      <th>mean</th>      <td>2.294882</td>      <td>29.881135</td>      <td>0.498854</td>      <td>0.385027</td>      <td>33.295479</td>      <td>0.381971</td>    </tr>    <tr>      <th>std</th>      <td>0.837836</td>      <td>14.413500</td>      <td>1.041658</td>      <td>0.865560</td>      <td>51.758668</td>      <td>0.486055</td>    </tr>    <tr>      <th>min</th>      <td>1.000000</td>      <td>0.166700</td>      <td>0.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>0.000000</td>    </tr>    <tr>      <th>25%</th>      <td>2.000000</td>      <td>21.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>7.895800</td>      <td>0.000000</td>    </tr>    <tr>      <th>50%</th>      <td>3.000000</td>      <td>28.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>14.454200</td>      <td>0.000000</td>    </tr>    <tr>      <th>75%</th>      <td>3.000000</td>      <td>39.000000</td>      <td>1.000000</td>      <td>0.000000</td>      <td>31.275000</td>      <td>1.000000</td>    </tr>    <tr>      <th>max</th>      <td>3.000000</td>      <td>80.000000</td>      <td>8.000000</td>      <td>9.000000</td>      <td>512.329200</td>      <td>1.000000</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dataset.hist(bins = <span class="hljs-number">50</span>, figsize = (<span class="hljs-number">20</span>,<span class="hljs-number">15</span>))<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%5Coutput_8_0.png" alt="png"></p><h2 id="创建测试集"><a href="#创建测试集" class="headerlink" title="创建测试集"></a>创建测试集</h2><p>切记在看更多详细信息之前，应划分测试集，并把它放到一边<br>划分数据集有两个方法，一个手动（用numpy自己分割），一个自动（sklearn写好的api）<br>手动方法适应个性化操作。</p><ul><li>数据集过小，单纯的随机创建会产生样本倾斜，采取分层抽样的方式平衡关键属性（看书）</li></ul><p>手动划分</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-meta"># For illustration only. Sklearn has train_test_split()</span><br><span class="hljs-title">def</span> split_train_test(<span class="hljs-class"><span class="hljs-keyword">data</span>, test_ratio):</span><br>    shuffled_indices = np.random.permutation(len(<span class="hljs-class"><span class="hljs-keyword">data</span>))</span><br>    test_set_size = int(len(<span class="hljs-class"><span class="hljs-keyword">data</span>) * test_ratio)</span><br>    test_indices = shuffled_indices[:test_set_size]<br>    train_indices = shuffled_indices[test_set_size:]<br>    return <span class="hljs-class"><span class="hljs-keyword">data</span>.iloc[train_indices], <span class="hljs-keyword">data</span>.iloc[test_indices]</span><br></code></pre></td></tr></table></figure><p>需要注意的问题：</p><ul><li>在每次运行都会生成不同的测试集，解决方法一种是保存下来，另一种是在使用np.random.permutation()时先生成随机种子np.random.seed()</li><li>即使确定了随机种子，在数据集更新的时候，依然会出现不同的测试集。解决方法是用对每个 实例的标识符哈希化，看书。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#自动划分</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>train_set,test_set = train_test_split(dataset, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">42</span>)<br>print(<span class="hljs-built_in">len</span>(train_set),<span class="hljs-string">&quot;train +&quot;</span>,<span class="hljs-built_in">len</span>(test_set),<span class="hljs-string">&quot;test&quot;</span>)<br></code></pre></td></tr></table></figure><pre><code>916 train + 393 test</code></pre><h2 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h2><ul><li>为了避免发生错误影响数据集，使用训练集的副本。</li><li>相关性：主要是看数据趋势是否是正相关和负相关，用散点图很容易就看出来了。其中相关系数可以且只能看出是否是线性相关，散列矩阵则比较强大。对于过多的离散点是否需要采用标准化降低模型拟合时间也有重要指导作用。</li><li>属性组合：对于多属性反映同一个事物可以考虑合而为一，或者优化属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">titanic = train_set.copy()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看数据之间的相关系数</span><br>corr_matrix = titanic.corr()<br>corr_matrix[<span class="hljs-string">&quot;fare&quot;</span>]<br></code></pre></td></tr></table></figure><pre><code>pclass     -0.555562age         0.137666sibsp       0.158024parch       0.214890fare        1.000000survived    0.261934Name: fare, dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#数据之间的相关性可视化</span><br><span class="hljs-keyword">from</span> pandas.plotting <span class="hljs-keyword">import</span> scatter_matrix<br><br>attributes = [<span class="hljs-string">&quot;pclass&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;sibsp&quot;</span>,<span class="hljs-string">&quot;parch&quot;</span>,<span class="hljs-string">&quot;fare&quot;</span>,<span class="hljs-string">&quot;survived&quot;</span>]<br>scatter_matrix(titanic[attributes], figsize=(<span class="hljs-number">24</span>, <span class="hljs-number">16</span>))<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%5Coutput_15_0.png" alt="png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#单独拿一个出来看看，为什么感觉青壮年活的多，死的也多，可能是因为基数大吧。</span><br>titanic.plot(kind=<span class="hljs-string">&quot;scatter&quot;</span>, x=<span class="hljs-string">&quot;age&quot;</span>, y=<span class="hljs-string">&quot;survived&quot;</span>,<br>             alpha=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x1d1b182dc88&gt;</code></pre><p><img src="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%5Coutput_16_1.png" alt="png"></p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>预处理的目的：</p><ol><li>建立工作流，对于以后更多的数据不必再写代码处理。</li><li>逐渐建立自己处理库，复用代码。</li><li>易于将数据处理后喂给不同的算法。</li></ol><p>在这之前我们需要再一次的将数据与对象（结果）分开</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">titanic_data = titanic.drop(<span class="hljs-string">&#x27;survived&#x27;</span>,axis = <span class="hljs-number">1</span>)<br>titanic_label = titanic[<span class="hljs-string">&#x27;survived&#x27;</span>].copy()<br></code></pre></td></tr></table></figure><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><p>因为大部分机器学习算法对有缺失值的数据特征不能运作，有下列处理方法：</p><ul><li>直接删除整个属性（缺失值过多）.dropna(subset=[‘attribute’])</li><li>删除缺失的部分 .drop(‘attribute’, axis = 1)</li><li>填充一些值  ,fillna(value)</li></ul><p>scikit-learn提供了imputer类进行方便的处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.impute <span class="hljs-keyword">import</span> SimpleImputer <br>imputer = SimpleImputer(strategy = <span class="hljs-string">&#x27;median&#x27;</span>) <br>num_attribs = [<span class="hljs-string">&#x27;pclass&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sibsp&#x27;</span>, <span class="hljs-string">&#x27;parch&#x27;</span>, <span class="hljs-string">&#x27;fare&#x27;</span>] <br>titanic_num = titanic_data[num_attribs] <br>imputer.fit(titanic_num)<br></code></pre></td></tr></table></figure><pre><code>SimpleImputer(copy=True, fill_value=None, missing_values=nan,       strategy=&#39;median&#39;, verbose=0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">print(imputer.statistics_)<br>print(<span class="hljs-string">&#x27;*&#x27;</span>*<span class="hljs-number">30</span>)<br>print(titanic_data.median())<br></code></pre></td></tr></table></figure><pre><code>[  3.   28.    0.    0.   14.5]******************************pclass     3.0age       28.0sibsp      0.0parch      0.0fare      14.5dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X = imputer.transform(titanic_num) <span class="hljs-comment">#返回结果是numpy，转化为dataframe</span><br>titanic_tr = pd.DataFrame(X,columns=titanic_num.columns)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">titanic_tr<br></code></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }        .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>pclass</th>      <th>age</th>      <th>sibsp</th>      <th>parch</th>      <th>fare</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>8.6625</td>    </tr>    <tr>      <th>1</th>      <td>3.0</td>      <td>26.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.8958</td>    </tr>    <tr>      <th>2</th>      <td>2.0</td>      <td>19.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>26.0000</td>    </tr>    <tr>      <th>3</th>      <td>3.0</td>      <td>28.0000</td>      <td>8.0</td>      <td>2.0</td>      <td>69.5500</td>    </tr>    <tr>      <th>4</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.7750</td>    </tr>    <tr>      <th>5</th>      <td>3.0</td>      <td>1.0000</td>      <td>1.0</td>      <td>1.0</td>      <td>11.1333</td>    </tr>    <tr>      <th>6</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.2500</td>    </tr>    <tr>      <th>7</th>      <td>3.0</td>      <td>30.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>6.9500</td>    </tr>    <tr>      <th>8</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>8.4583</td>    </tr>    <tr>      <th>9</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.7333</td>    </tr>    <tr>      <th>10</th>      <td>2.0</td>      <td>52.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>13.0000</td>    </tr>    <tr>      <th>11</th>      <td>3.0</td>      <td>20.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>9.5000</td>    </tr>    <tr>      <th>12</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>8.0500</td>    </tr>    <tr>      <th>13</th>      <td>1.0</td>      <td>62.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>26.5500</td>    </tr>    <tr>      <th>14</th>      <td>3.0</td>      <td>23.5000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.2292</td>    </tr>    <tr>      <th>15</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>8.0500</td>    </tr>    <tr>      <th>16</th>      <td>3.0</td>      <td>20.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.2250</td>    </tr>    <tr>      <th>17</th>      <td>3.0</td>      <td>28.0000</td>      <td>2.0</td>      <td>0.0</td>      <td>23.2500</td>    </tr>    <tr>      <th>18</th>      <td>2.0</td>      <td>30.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>10.5000</td>    </tr>    <tr>      <th>19</th>      <td>1.0</td>      <td>48.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>50.4958</td>    </tr>    <tr>      <th>20</th>      <td>1.0</td>      <td>45.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>35.5000</td>    </tr>    <tr>      <th>21</th>      <td>1.0</td>      <td>33.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>27.7208</td>    </tr>    <tr>      <th>22</th>      <td>3.0</td>      <td>40.5000</td>      <td>0.0</td>      <td>0.0</td>      <td>15.1000</td>    </tr>    <tr>      <th>23</th>      <td>3.0</td>      <td>27.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.8542</td>    </tr>    <tr>      <th>24</th>      <td>1.0</td>      <td>53.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>28.5000</td>    </tr>    <tr>      <th>25</th>      <td>1.0</td>      <td>57.0000</td>      <td>1.0</td>      <td>1.0</td>      <td>164.8667</td>    </tr>    <tr>      <th>26</th>      <td>3.0</td>      <td>20.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>8.6625</td>    </tr>    <tr>      <th>27</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.5500</td>    </tr>    <tr>      <th>28</th>      <td>2.0</td>      <td>24.0000</td>      <td>2.0</td>      <td>0.0</td>      <td>73.5000</td>    </tr>    <tr>      <th>29</th>      <td>3.0</td>      <td>2.0000</td>      <td>1.0</td>      <td>1.0</td>      <td>20.2125</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>886</th>      <td>2.0</td>      <td>16.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>10.5000</td>    </tr>    <tr>      <th>887</th>      <td>3.0</td>      <td>9.0000</td>      <td>0.0</td>      <td>1.0</td>      <td>3.1708</td>    </tr>    <tr>      <th>888</th>      <td>2.0</td>      <td>31.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>10.5000</td>    </tr>    <tr>      <th>889</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.7500</td>    </tr>    <tr>      <th>890</th>      <td>3.0</td>      <td>0.3333</td>      <td>0.0</td>      <td>2.0</td>      <td>14.4000</td>    </tr>    <tr>      <th>891</th>      <td>1.0</td>      <td>61.0000</td>      <td>1.0</td>      <td>3.0</td>      <td>262.3750</td>    </tr>    <tr>      <th>892</th>      <td>1.0</td>      <td>47.0000</td>      <td>1.0</td>      <td>1.0</td>      <td>52.5542</td>    </tr>    <tr>      <th>893</th>      <td>2.0</td>      <td>42.0000</td>      <td>1.0</td>      <td>0.0</td>      <td>27.0000</td>    </tr>    <tr>      <th>894</th>      <td>3.0</td>      <td>28.0000</td>      <td>2.0</td>      <td>0.0</td>      <td>21.6792</td>    </tr>    <tr>      <th>895</th>      <td>1.0</td>      <td>57.0000</td>      <td>1.0</td>      <td>0.0</td>      <td>146.5208</td>    </tr>    <tr>      <th>896</th>      <td>3.0</td>      <td>28.0000</td>      <td>3.0</td>      <td>1.0</td>      <td>25.4667</td>    </tr>    <tr>      <th>897</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.7500</td>    </tr>    <tr>      <th>898</th>      <td>2.0</td>      <td>8.0000</td>      <td>1.0</td>      <td>1.0</td>      <td>36.7500</td>    </tr>    <tr>      <th>899</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>56.4958</td>    </tr>    <tr>      <th>900</th>      <td>2.0</td>      <td>34.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>13.0000</td>    </tr>    <tr>      <th>901</th>      <td>3.0</td>      <td>22.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.2500</td>    </tr>    <tr>      <th>902</th>      <td>1.0</td>      <td>22.0000</td>      <td>0.0</td>      <td>1.0</td>      <td>59.4000</td>    </tr>    <tr>      <th>903</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.7500</td>    </tr>    <tr>      <th>904</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>2.0</td>      <td>22.3583</td>    </tr>    <tr>      <th>905</th>      <td>1.0</td>      <td>27.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>30.5000</td>    </tr>    <tr>      <th>906</th>      <td>2.0</td>      <td>57.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>13.0000</td>    </tr>    <tr>      <th>907</th>      <td>3.0</td>      <td>25.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.7958</td>    </tr>    <tr>      <th>908</th>      <td>2.0</td>      <td>34.0000</td>      <td>1.0</td>      <td>0.0</td>      <td>26.0000</td>    </tr>    <tr>      <th>909</th>      <td>1.0</td>      <td>28.0000</td>      <td>1.0</td>      <td>0.0</td>      <td>133.6500</td>    </tr>    <tr>      <th>910</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>15.5000</td>    </tr>    <tr>      <th>911</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.6292</td>    </tr>    <tr>      <th>912</th>      <td>3.0</td>      <td>18.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.7750</td>    </tr>    <tr>      <th>913</th>      <td>3.0</td>      <td>28.5000</td>      <td>0.0</td>      <td>0.0</td>      <td>16.1000</td>    </tr>    <tr>      <th>914</th>      <td>3.0</td>      <td>26.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.9250</td>    </tr>    <tr>      <th>915</th>      <td>3.0</td>      <td>28.0000</td>      <td>0.0</td>      <td>0.0</td>      <td>7.8958</td>    </tr>  </tbody></table><p>916 rows × 5 columns</p></div><h3 id="文本和分类属性"><a href="#文本和分类属性" class="headerlink" title="文本和分类属性"></a>文本和分类属性</h3><ul><li>LabelEncoder直接将不同的标签转化为不同的数字，但是这有一个问题，数字与数字之间是有联系的，而标签与标签之间的联系和数字不一样，这样就造成了样本偏斜</li><li>OneHot编码能够有效避免上述弊端。因此，一般都采用此方法。文本分类-&gt;标签分类-&gt;onehot分类</li><li>文本分类可以直接到Onehot分类，运用LabelBinarizer</li><li>这里注意类型，原书中不需要转换成str，这里需要，并且还要转化成array用reshape方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<br>cat_attribs = [<span class="hljs-string">&quot;embarked&quot;</span>]<br>titanic_data.embarked.fillna(<span class="hljs-string">&quot;Q&quot;</span>,inplace = <span class="hljs-literal">True</span>)<br>titanic_cat = titanic_data[cat_attribs]<br>encoder = OneHotEncoder()<br>titanic_cat_1hot = encoder.fit_transform(np.array(titanic_cat.astype(<span class="hljs-built_in">str</span>)).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">encoder.categories_<br></code></pre></td></tr></table></figure><pre><code>[array([&#39;C&#39;, &#39;Q&#39;, &#39;S&#39;], dtype=object)]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原来返回的是稀疏矩阵，对于大规模的数据存储很有好处。可以用toarray改成下列形式</span><br>print(titanic_cat_1hot.toarray())<br></code></pre></td></tr></table></figure><pre><code>[[ 0.  0.  1.] [ 0.  0.  1.] [ 0.  0.  1.] ...,  [ 0.  0.  1.] [ 0.  0.  1.] [ 0.  0.  1.]]</code></pre><h3 id="自定义变换添加额外属性"><a href="#自定义变换添加额外属性" class="headerlink" title="自定义变换添加额外属性"></a>自定义变换添加额外属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.base <span class="hljs-keyword">import</span> BaseEstimator, TransformerMixin<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CombinedAttributesAdder</span>(<span class="hljs-params">BaseEstimator, TransformerMixin</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, add_bedrooms_per_room = <span class="hljs-literal">True</span></span>):</span> <span class="hljs-comment"># no *args or **kargs</span><br>        self.add_bedrooms_per_room = add_bedrooms_per_room<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, X, y=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">return</span> self  <span class="hljs-comment"># nothing else to do</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span>(<span class="hljs-params">self, X, y=<span class="hljs-literal">None</span></span>):</span><br>        rooms_per_household = X[:, rooms_ix] / X[:, household_ix]<br>        population_per_household = X[:, population_ix] / X[:, household_ix]<br>        <span class="hljs-keyword">if</span> self.add_bedrooms_per_room:<br>            bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix]<br>            <span class="hljs-keyword">return</span> np.c_[X, rooms_per_household, population_per_household,<br>                         bedrooms_per_room]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> np.c_[X, rooms_per_household, population_per_household]<br><br>attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=<span class="hljs-literal">False</span>)<br>housing_extra_attribs = attr_adder.transform(housing.values)<br></code></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><br>num_pipeline = Pipeline([<br>        (<span class="hljs-string">&#x27;imputer&#x27;</span>, SimpleImputer(strategy=<span class="hljs-string">&quot;median&quot;</span>)),<br>        <span class="hljs-comment">#(&#x27;attribs_adder&#x27;, CombinedAttributesAdder()),</span><br>        (<span class="hljs-string">&#x27;std_scaler&#x27;</span>, StandardScaler()),<br>    ])<br>titanic_num_tr = num_pipeline.fit_transform(titanic_num)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">titanic_num_tr<br></code></pre></td></tr></table></figure><pre><code>array([[ 0.82524778, -0.07091793, -0.49861561, -0.43255344, -0.47409151],       [ 0.82524778, -0.23259583, -0.49861561, -0.43255344, -0.48861599],       [-0.36331663, -0.79846845, -0.49861561, -0.43255344, -0.14564735],       ...,        [ 0.82524778, -0.03049846, -0.49861561, -0.43255344, -0.33319441],       [ 0.82524778, -0.23259583, -0.49861561, -0.43255344, -0.48806282],       [ 0.82524778, -0.07091793, -0.49861561, -0.43255344, -0.48861599]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.compose <span class="hljs-keyword">import</span> ColumnTransformer<br><br>full_pipeline = ColumnTransformer([<br>        (<span class="hljs-string">&quot;num&quot;</span>, num_pipeline, num_attribs),<br>        (<span class="hljs-string">&quot;cat&quot;</span>, OneHotEncoder(), cat_attribs),<br>    ])<br>titanic_prepared = full_pipeline.fit_transform(titanic_data)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">titanic_prepared.shape<br></code></pre></td></tr></table></figure><pre><code>(916, 8)</code></pre><h1 id="选择和训练模型"><a href="#选择和训练模型" class="headerlink" title="选择和训练模型"></a>选择和训练模型</h1><ul><li>这里选用的是线性回归模型，仅仅是试一试，可以看出效果是相当不好.显然，一个分类问题用回归模型来训练，显然是错误的</li><li>线性回归模型常用均方根来表示误差</li><li>随机梯度下降分类器模型看得出有点效果，性能通常用召回率，准确率来表征，这里没有过多展示。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br>lin_reg = LinearRegression()<br>lin_reg.fit(titanic_prepared, titanic_label)<br></code></pre></td></tr></table></figure><pre><code>LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None,         normalize=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">some_data = test_set.iloc[:<span class="hljs-number">5</span>]<br>some_labels = titanic_label.iloc[:<span class="hljs-number">5</span>]<br>some_data_prepared = full_pipeline.transform(some_data)<br>print(<span class="hljs-string">&quot;Predictions:&quot;</span>, lin_reg.predict(some_data_prepared))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&quot;Labels:&quot;</span>, <span class="hljs-built_in">list</span>(some_labels))<br></code></pre></td></tr></table></figure><pre><code>Labels: [0, 0, 1, 0, 0]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><br>titanic_predictions = lin_reg.predict(titanic_prepared)<br>lin_mse = mean_squared_error(titanic_label, titanic_predictions)<br>lin_rmse = np.sqrt(lin_mse)<br>lin_rmse<br></code></pre></td></tr></table></figure><pre><code>0.44458368170220458</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error<br><br>lin_mae = mean_absolute_error(titanic_label, titanic_predictions)<br>lin_mae<br></code></pre></td></tr></table></figure><pre><code>0.39530930007177417</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<br><br>tree_reg = DecisionTreeRegressor(random_state=<span class="hljs-number">42</span>)<br>tree_reg.fit(titanic_prepared, titanic_label)<br>housing_predictions = tree_reg.predict(titanic_prepared)<br>tree_mse = mean_squared_error(titanic_label, titanic_predictions)<br>tree_rmse = np.sqrt(tree_mse)<br>tree_rmse<br></code></pre></td></tr></table></figure><pre><code>0.44458368170220458</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDClassifier<br><br>sgd_clf = SGDClassifier(max_iter=<span class="hljs-number">5</span>, random_state=<span class="hljs-number">42</span>)<br>sgd_clf.fit(titanic_prepared, titanic_label)<br></code></pre></td></tr></table></figure><pre><code>SGDClassifier(alpha=0.0001, average=False, class_weight=None,       early_stopping=False, epsilon=0.1, eta0=0.0, fit_intercept=True,       l1_ratio=0.15, learning_rate=&#39;optimal&#39;, loss=&#39;hinge&#39;, max_iter=5,       n_iter=None, n_iter_no_change=5, n_jobs=None, penalty=&#39;l2&#39;,       power_t=0.5, random_state=42, shuffle=True, tol=None,       validation_fraction=0.1, verbose=0, warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&quot;Predictions:&quot;</span>, sgd_clf.predict(some_data_prepared))<br></code></pre></td></tr></table></figure><pre><code>Predictions: [0 0 0 0 1]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&quot;Labels:&quot;</span>, <span class="hljs-built_in">list</span>(some_labels))<br></code></pre></td></tr></table></figure><pre><code>Labels: [0, 0, 1, 0, 0]</code></pre><h1 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h1><ul><li>用的最多的就是交叉验证</li><li>其次是对模型调参，参数的搜索</li><li>最后是对各个模型融合进行预测,得到一个最好的模型就完事了</li></ul><h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_val_score<br><br>scores = cross_val_score(tree_reg, titanic_prepared, titanic_label,<br>                         scoring=<span class="hljs-string">&quot;neg_mean_squared_error&quot;</span>, cv=<span class="hljs-number">5</span>)<br>tree_rmse_scores = np.sqrt(-scores)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display_scores</span>(<span class="hljs-params">scores</span>):</span><br>    print(<span class="hljs-string">&quot;Scores:&quot;</span>, scores)<br>    print(<span class="hljs-string">&quot;Mean:&quot;</span>, scores.mean())<br>    print(<span class="hljs-string">&quot;Standard deviation:&quot;</span>, scores.std())<br><br>display_scores(tree_rmse_scores)<br></code></pre></td></tr></table></figure><pre><code>array([ 0.62210924,  0.59404   ,  0.63470788,  0.58847198,  0.56893364])</code></pre><h2 id="参数搜索"><a href="#参数搜索" class="headerlink" title="参数搜索"></a>参数搜索</h2><ul><li>给参数自动进行比较，选出最优参数</li><li>随机搜索最优参数</li></ul><h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor<br><br>forest_reg = RandomForestRegressor(random_state=<span class="hljs-number">42</span>)<br>forest_reg.fit(titanic_prepared, titanic_label)<br></code></pre></td></tr></table></figure><pre><code>D:\Anaconda\Lib\site-packages\sklearn\ensemble\forest.py:248: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22.  &quot;10 in version 0.20 to 100 in 0.22.&quot;, FutureWarning)RandomForestRegressor(bootstrap=True, criterion=&#39;mse&#39;, max_depth=None,           max_features=&#39;auto&#39;, max_leaf_nodes=None,           min_impurity_decrease=0.0, min_impurity_split=None,           min_samples_leaf=1, min_samples_split=2,           min_weight_fraction_leaf=0.0, n_estimators=10, n_jobs=None,           oob_score=False, random_state=42, verbose=0, warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">titanic_predictions = forest_reg.predict(titanic_prepared)<br>forest_mse = mean_squared_error(titanic_label, titanic_predictions)<br>forest_rmse = np.sqrt(forest_mse)<br>forest_rmse<br></code></pre></td></tr></table></figure><pre><code>0.24601252278498684</code></pre><h3 id="给定参数搜索"><a href="#给定参数搜索" class="headerlink" title="给定参数搜索"></a>给定参数搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><br>param_grid = [<br>    <span class="hljs-comment"># try 12 (3×4) combinations of hyperparameters</span><br>    &#123;<span class="hljs-string">&#x27;n_estimators&#x27;</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>], <span class="hljs-string">&#x27;max_features&#x27;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]&#125;,<br>    <span class="hljs-comment"># then try 6 (2×3) combinations with bootstrap set as False</span><br>    &#123;<span class="hljs-string">&#x27;bootstrap&#x27;</span>: [<span class="hljs-literal">False</span>], <span class="hljs-string">&#x27;n_estimators&#x27;</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">10</span>], <span class="hljs-string">&#x27;max_features&#x27;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&#125;,<br>  ]<br><br>forest_reg = RandomForestRegressor(random_state=<span class="hljs-number">42</span>)<br><span class="hljs-comment"># train across 5 folds, that&#x27;s a total of (12+6)*5=90 rounds of training </span><br>grid_search = GridSearchCV(forest_reg, param_grid, cv=<span class="hljs-number">5</span>,<br>                           scoring=<span class="hljs-string">&#x27;neg_mean_squared_error&#x27;</span>, return_train_score=<span class="hljs-literal">True</span>)<br>grid_search.fit(titanic_prepared,titanic_label)<br></code></pre></td></tr></table></figure><pre><code>GridSearchCV(cv=5, error_score=&#39;raise-deprecating&#39;,       estimator=RandomForestRegressor(bootstrap=True, criterion=&#39;mse&#39;, max_depth=None,           max_features=&#39;auto&#39;, max_leaf_nodes=None,           min_impurity_decrease=0.0, min_impurity_split=None,           min_samples_leaf=1, min_samples_split=2,           min_weight_fraction_leaf=0.0, n_estimators=&#39;warn&#39;, n_jobs=None,           oob_score=False, random_state=42, verbose=0, warm_start=False),       fit_params=None, iid=&#39;warn&#39;, n_jobs=None,       param_grid=[&#123;&#39;n_estimators&#39;: [3, 10, 30], &#39;max_features&#39;: [2, 4, 6, 8]&#125;, &#123;&#39;bootstrap&#39;: [False], &#39;n_estimators&#39;: [3, 10], &#39;max_features&#39;: [2, 3, 4]&#125;],       pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=True,       scoring=&#39;neg_mean_squared_error&#39;, verbose=0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">grid_search.best_params_<br></code></pre></td></tr></table></figure><pre><code>&#123;&#39;max_features&#39;: 8, &#39;n_estimators&#39;: 30&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">grid_search.best_estimator_<br></code></pre></td></tr></table></figure><pre><code>RandomForestRegressor(bootstrap=True, criterion=&#39;mse&#39;, max_depth=None,           max_features=8, max_leaf_nodes=None, min_impurity_decrease=0.0,           min_impurity_split=None, min_samples_leaf=1,           min_samples_split=2, min_weight_fraction_leaf=0.0,           n_estimators=30, n_jobs=None, oob_score=False, random_state=42,           verbose=0, warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cvres = grid_search.cv_results_<br><span class="hljs-keyword">for</span> mean_score, params <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(cvres[<span class="hljs-string">&quot;mean_test_score&quot;</span>], cvres[<span class="hljs-string">&quot;params&quot;</span>]):<br>    print(np.sqrt(-mean_score), params)<br></code></pre></td></tr></table></figure><pre><code>0.497131363834 &#123;&#39;max_features&#39;: 2, &#39;n_estimators&#39;: 3&#125;0.480945066964 &#123;&#39;max_features&#39;: 2, &#39;n_estimators&#39;: 10&#125;0.467748997902 &#123;&#39;max_features&#39;: 2, &#39;n_estimators&#39;: 30&#125;0.502741663175 &#123;&#39;max_features&#39;: 4, &#39;n_estimators&#39;: 3&#125;0.476083472783 &#123;&#39;max_features&#39;: 4, &#39;n_estimators&#39;: 10&#125;0.464671414883 &#123;&#39;max_features&#39;: 4, &#39;n_estimators&#39;: 30&#125;0.500998128825 &#123;&#39;max_features&#39;: 6, &#39;n_estimators&#39;: 3&#125;0.4723270942 &#123;&#39;max_features&#39;: 6, &#39;n_estimators&#39;: 10&#125;0.464692668366 &#123;&#39;max_features&#39;: 6, &#39;n_estimators&#39;: 30&#125;0.491656899488 &#123;&#39;max_features&#39;: 8, &#39;n_estimators&#39;: 3&#125;0.468153614704 &#123;&#39;max_features&#39;: 8, &#39;n_estimators&#39;: 10&#125;0.462619186958 &#123;&#39;max_features&#39;: 8, &#39;n_estimators&#39;: 30&#125;0.534684910518 &#123;&#39;bootstrap&#39;: False, &#39;max_features&#39;: 2, &#39;n_estimators&#39;: 3&#125;0.516588728861 &#123;&#39;bootstrap&#39;: False, &#39;max_features&#39;: 2, &#39;n_estimators&#39;: 10&#125;0.535750828291 &#123;&#39;bootstrap&#39;: False, &#39;max_features&#39;: 3, &#39;n_estimators&#39;: 3&#125;0.516586118116 &#123;&#39;bootstrap&#39;: False, &#39;max_features&#39;: 3, &#39;n_estimators&#39;: 10&#125;0.535870542379 &#123;&#39;bootstrap&#39;: False, &#39;max_features&#39;: 4, &#39;n_estimators&#39;: 3&#125;0.512291127875 &#123;&#39;bootstrap&#39;: False, &#39;max_features&#39;: 4, &#39;n_estimators&#39;: 10&#125;</code></pre><h3 id="随机参数搜索"><a href="#随机参数搜索" class="headerlink" title="随机参数搜索"></a>随机参数搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> RandomizedSearchCV<br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> randint<br><br>param_distribs = &#123;<br>        <span class="hljs-string">&#x27;n_estimators&#x27;</span>: randint(low=<span class="hljs-number">1</span>, high=<span class="hljs-number">200</span>),<br>        <span class="hljs-string">&#x27;max_features&#x27;</span>: randint(low=<span class="hljs-number">1</span>, high=<span class="hljs-number">8</span>),<br>    &#125;<br><br>forest_reg = RandomForestRegressor(random_state=<span class="hljs-number">42</span>)<br>rnd_search = RandomizedSearchCV(forest_reg, param_distributions=param_distribs,<br>                                n_iter=<span class="hljs-number">10</span>, cv=<span class="hljs-number">5</span>, scoring=<span class="hljs-string">&#x27;neg_mean_squared_error&#x27;</span>, random_state=<span class="hljs-number">42</span>)<br>rnd_search.fit(titanic_prepared,titanic_label)<br></code></pre></td></tr></table></figure><pre><code>RandomizedSearchCV(cv=5, error_score=&#39;raise-deprecating&#39;,          estimator=RandomForestRegressor(bootstrap=True, criterion=&#39;mse&#39;, max_depth=None,           max_features=&#39;auto&#39;, max_leaf_nodes=None,           min_impurity_decrease=0.0, min_impurity_split=None,           min_samples_leaf=1, min_samples_split=2,           min_weight_fraction_leaf=0.0, n_estimators=&#39;warn&#39;, n_jobs=None,           oob_score=False, random_state=42, verbose=0, warm_start=False),          fit_params=None, iid=&#39;warn&#39;, n_iter=10, n_jobs=None,          param_distributions=&#123;&#39;n_estimators&#39;: &lt;scipy.stats._distn_infrastructure.rv_frozen object at 0x000001D1B51B6198&gt;, &#39;max_features&#39;: &lt;scipy.stats._distn_infrastructure.rv_frozen object at 0x000001D1B51B6978&gt;&#125;,          pre_dispatch=&#39;2*n_jobs&#39;, random_state=42, refit=True,          return_train_score=&#39;warn&#39;, scoring=&#39;neg_mean_squared_error&#39;,          verbose=0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cvres = rnd_search.cv_results_<br><span class="hljs-keyword">for</span> mean_score, params <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(cvres[<span class="hljs-string">&quot;mean_test_score&quot;</span>], cvres[<span class="hljs-string">&quot;params&quot;</span>]):<br>    print(np.sqrt(-mean_score), params)<br></code></pre></td></tr></table></figure><pre><code>0.464039645236 &#123;&#39;max_features&#39;: 7, &#39;n_estimators&#39;: 180&#125;0.471855747311 &#123;&#39;max_features&#39;: 5, &#39;n_estimators&#39;: 15&#125;0.469662076234 &#123;&#39;max_features&#39;: 3, &#39;n_estimators&#39;: 72&#125;0.4681528737 &#123;&#39;max_features&#39;: 5, &#39;n_estimators&#39;: 21&#125;0.464796324533 &#123;&#39;max_features&#39;: 7, &#39;n_estimators&#39;: 122&#125;0.469440835097 &#123;&#39;max_features&#39;: 3, &#39;n_estimators&#39;: 75&#125;0.469061926876 &#123;&#39;max_features&#39;: 3, &#39;n_estimators&#39;: 88&#125;0.464095537716 &#123;&#39;max_features&#39;: 5, &#39;n_estimators&#39;: 100&#125;0.465712273605 &#123;&#39;max_features&#39;: 3, &#39;n_estimators&#39;: 150&#125;0.521753546174 &#123;&#39;max_features&#39;: 5, &#39;n_estimators&#39;: 2&#125;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">feature_importances = grid_search.best_estimator_.feature_importances_<br>feature_importances<br></code></pre></td></tr></table></figure><pre><code>array([ 0.08056266,  0.35015732,  0.0670613 ,  0.052615  ,  0.39991869,        0.01900031,  0.00781355,  0.02287116])</code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>pipeline可以把训练模型这个过程也加进去</li><li>可以用sklearn的模块保存模型，加载模型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">full_pipeline_with_predictor = Pipeline([<br>        (<span class="hljs-string">&quot;preparation&quot;</span>, full_pipeline),<br>        (<span class="hljs-string">&quot;linear&quot;</span>, LinearRegression())<br>    ])<br><br>full_pipeline_with_predictor.fit(titanic_data,titanic_label)<br>full_pipeline_with_predictor.predict(some_data)<br></code></pre></td></tr></table></figure><pre><code>array([ 0.14901183,  0.37719866,  0.18577842,  0.18589226,  0.29765968])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_model = full_pipeline_with_predictor<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.externals <span class="hljs-keyword">import</span> joblib<br>joblib.dump(my_model, <span class="hljs-string">&quot;my_model.pkl&quot;</span>) <span class="hljs-comment"># DIFF</span><br><span class="hljs-comment">#...</span><br>my_model_loaded = joblib.load(<span class="hljs-string">&quot;my_model.pkl&quot;</span>) <span class="hljs-comment"># DIFF</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
