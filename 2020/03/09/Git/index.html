

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Git - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>windilycloud</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Git">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-03-09 00:00" pubdate>
        2020年3月9日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      33.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      393
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Git</h1>
            
            <div class="markdown-body">
              <p>全文参考自书籍Pro Git，<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>
<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p> 版本控制系统是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。因此从大的方向上来说产生了三种版本控制系统——本地版本控制系统，集中式版本控制系统，分布式版本控制系统。</p>
<p>本地式版本控制系统的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新恢复出各个版本的文件内容。缺点是对协同合作不友好。</p>
<p>集中式版本控制系统有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。缺点是如果这个集中管理的服务器出故障，那么所有写作人员都会受到影响。</p>
<p>分布式版本控制系统让客户端并不只提取最新版本的文件，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。而Git就是一个分布式版本控制系统，基于Git有代码托管平台Github。</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="在Linux上安装"><a href="#在Linux上安装" class="headerlink" title="在Linux上安装"></a>在Linux上安装</h3><p>如果你想在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。 如果以 Fedora 上为例，你可以使用 yum：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> sudo yum install git</span><br></code></pre></td></tr></table></figure>
<p>如果你在基于 Debian 的发行版上，请尝试用 apt-get：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install git</span><br></code></pre></td></tr></table></figure>
<p>要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 <a target="_blank" rel="noopener" href="http://git-scm.com/download/linux%E3%80%82">http://git-scm.com/download/linux。</a></p>
<h3 id="在windows上安装"><a href="#在windows上安装" class="headerlink" title="在windows上安装"></a>在windows上安装</h3><p>在 Windows 上安装 Git 也有几种安装方法。 官方版本可以在 Git 官方网站下载。 打开 <a target="_blank" rel="noopener" href="http://git-scm.com/download/win%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%BC%80%E5%A7%8B%E3%80%82">http://git-scm.com/download/win，下载会自动开始。</a> 要注意这是一个名为 Git for Windows 的项目（也叫做 msysGit），和 Git 是分别独立的项目；更多信息请访问 <a target="_blank" rel="noopener" href="http://msysgit.github.io/%E3%80%82">http://msysgit.github.io/。</a></p>
<p>另一个简单的方法是安装 GitHub for Windows。 该安装程序包含图形化和命令行版本的 Git。 它也能支持 Powershell，提供了稳定的凭证缓存和健全的换行设置。 稍后我们会对这方面有更多了解，现在只要一句话就够了，这些都是你所需要的。 你可以在 GitHub for Windows 网站下载，网址为 <a target="_blank" rel="noopener" href="http://windows.github.com/">http://windows.github.com</a>。</p>
<h2 id="初次运行的配置"><a href="#初次运行的配置" class="headerlink" title="初次运行的配置"></a>初次运行的配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置，三种配置优先级依次递增：</p>
<ol>
<li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li>
</ol>
<h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><hr>
<p>我用的是windows10，在运行过程中中文无法正常显示，需要进行以下设置：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global core.quotepath <span class="hljs-literal">false</span></span><br></code></pre></td></tr></table></figure>
<p>这样能显示中文，但是是乱码，接着在git bash的界面中右击空白处，弹出菜单，选择<code>选项-&gt;文本-&gt;本地Locale</code>，设置为<code>zh_CN</code>，而旁边的字符集选框选为<code>UTF-8</code>。英文显示则是：<code>Options-&gt;Text-&gt;Locale改为zh_CN，Character set改为UTF-8</code>。</p>
<p>接着是修改log编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs consol">$ git config --global i18n.commitencoding utf-8  --注释：该命令表示提交命令的时候使用utf-8编码集提交<br><br>$ git config --global i18n.logoutputencoding utf-8 --注释：该命令表示日志输出时使用utf-8编码集显示<br><br>$ export LESSCHARSET&#x3D;utf-8  --注释：设置LESS字符集为utf-8<br></code></pre></td></tr></table></figure>
<hr>
<p>如果你的git bash终端没有菜单选项显示，还可以通过直接修改配置文件的方式来解决中文乱码问题。</p>
<p>进入git的安装目录</p>
<ol>
<li>编辑<code>etc\gitconfig</code>文件，也有些windows系统是存放在<code>C:\Users\Administrator\.gitconfig</code>路径或<code>安装盘符:\Git\mingw64\etc\gitconfig</code>，在文件末尾增加以下内容：</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[gui]</span>  <br>    <span class="hljs-attr">encoding</span> = utf-<span class="hljs-number">8</span>  <br>    <span class="hljs-comment"># 代码库统一使用utf-8  </span><br><span class="hljs-section">[i18n]</span>  <br>    <span class="hljs-attr">commitencoding</span> = utf-<span class="hljs-number">8</span>  <br>    <span class="hljs-comment"># log编码  </span><br><span class="hljs-section">[svn]</span>  <br>    <span class="hljs-attr">pathnameencoding</span> = utf-<span class="hljs-number">8</span>  <br>    <span class="hljs-comment"># 支持中文路径  </span><br><span class="hljs-section">[core]</span><br>    <span class="hljs-attr">quotepath</span> = <span class="hljs-literal">false</span> <br>    <span class="hljs-comment"># status引用路径不再是八进制（反过来说就是允许显示中文了）</span><br></code></pre></td></tr></table></figure>
<ol>
<li>编辑<code>etc\git-completion.bash</code>文件,在文件末尾增加以下内容：</li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 让ls命令能够正常显示中文</span><br><span class="hljs-keyword">alias</span> <span class="hljs-keyword">ls</span>=&#x27;<span class="hljs-keyword">ls</span> <span class="hljs-params">--show-control-chars</span> <span class="hljs-params">--color=auto</span>&#x27; <br></code></pre></td></tr></table></figure>
<ol>
<li>编辑<code>etc\inputrc</code>文件，修改output-meta和convert-meta属性值：</li>
</ol>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">set</span> output-meta <span class="hljs-keyword">on</span>  <span class="hljs-comment"># bash可以正常输入中文  </span><br><span class="hljs-keyword">set</span> convert-meta off  <br></code></pre></td></tr></table></figure>
<ol>
<li>编辑profile文件，在文件末尾添加如下内容：</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LESSHARESET</span>=utf-8<br></code></pre></td></tr></table></figure>
<h3 id="换行符设置"><a href="#换行符设置" class="headerlink" title="换行符设置"></a>换行符设置</h3><p>简单来说，如果core.autocrlf=true ，我们工作区的文件都应该用 CRLF 来换行。如果改动文件时引入了 LF，或者设置 core.autocrlf 之前，工作区已经有 LF 换行符。提交改动时，git 会警告你哪些文件不是纯 CRLF 文件，但 git 不会擅自修改工作区的那些文件，而是对暂存区（我们对工作区的改动）进行修改。也因此，当我们进行 git add 的操作时，只要 git 发现改动的内容里有 LF 换行符，就还会出现这个警告。设置 core.autocrlf=true, 只要保持工作区都是纯 CRLF 文件，编辑器用 CRLF 换行，就不会出现警告了（题主提的问题 2）。git 默认让版本库里用 LF 换行，只要保持这条规则，多人协作就不会出什么大问题。git 的 Windows 客户端基本都会默认设置 core.autocrlf=trueLinux 最好不要设置 core.autocrlf，因为这个配置算是为 Windows 平台定制。如果 Windows 上设置 core.autocrlf=false，仓库里也没有配置 .gitattributes，很容易引入 CRLF 或者混合换行符</p>
<p>我目前的解决办法是：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ git config –-global core.<span class="hljs-built_in">auto</span>crlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">&quot;John Doe&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> git config --global user.email johndoe@example.com</span><br></code></pre></td></tr></table></figure>
<p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p>
<h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>配置默认使用的文本编辑器，可以这样做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global core.editor vim</span><br></code></pre></td></tr></table></figure>
<h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --list</span><br>user.name=John Doe<br>user.email=johndoe@example.com<br>color.status=auto<br>color.branch=auto<br>color.interactive=auto<br>color.diff=auto<br>...<br></code></pre></td></tr></table></figure>
<p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p>
<p>你可以通过输入 <code>git config </code>： 来检查 Git 的某一项配置</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config user.name</span><br>John Doe<br></code></pre></td></tr></table></figure>
<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">help</span> &lt;verb&gt;</span><br><span class="hljs-meta">$</span><span class="bash"> git &lt;verb&gt; --<span class="hljs-built_in">help</span></span><br><span class="hljs-meta">$</span><span class="bash"> man git-&lt;verb&gt;</span><br></code></pre></td></tr></table></figure>
<p>例如，要想获得 config 命令的手册，执行</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">help</span> config</span><br></code></pre></td></tr></table></figure>
<h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h3><p>有两种创建 Git 项目仓库的主要方式。 第一种是将已有项目或目录导入为 Git 仓库； 第二种是从其它服务器克隆一个已存在的 Git 仓库。</p>
<h4 id="在已存在目录中初始化仓库"><a href="#在已存在目录中初始化仓库" class="headerlink" title="在已存在目录中初始化仓库"></a>在已存在目录中初始化仓库</h4><p>如果你打算使用 Git 来对已有项目进行追踪，你需要进入项目目录并输入：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git init</span><br></code></pre></td></tr></table></figure>
<p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p>
<p>如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 <code>git add</code> 命令来指定所需的文件来进行追踪，然后执行 <code>git commit</code> ：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add *.c</span><br><span class="hljs-meta">$</span><span class="bash"> git add LICENSE</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&#x27;initial project version&#x27;</span></span><br></code></pre></td></tr></table></figure>
<p>稍后我们再逐一解释这些指令的行为。 现在，你已经得到了一个存在被追踪文件与初始提交的 Git 仓库。</p>
<h4 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h4><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。</p>
<p>克隆仓库的命令是 <code>git clone [url]</code> 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2</span><br></code></pre></td></tr></table></figure>
<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 <code>libgit2</code> 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></code></pre></td></tr></table></figure>
<p>这将执行与上一条命令相同的操作，但目标目录名变为了 <code>mylibgit</code>。</p>
<p>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 SSH 传输协议，比如 <code>user@server:path/to/repo.git</code> 。 </p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是未修改，已修改或已放入暂存区。 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。</p>
<p><img src="Git%5Cgit%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif" alt="image-20200221093730676"></p>
<h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><p>可以用 <code>git status</code> 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>nothing to commit, working directory clean<br></code></pre></td></tr></table></figure>
<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。</p>
<p>现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;My Project&#x27;</span> &gt; README</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>    README<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br></code></pre></td></tr></table></figure>
<p>在状态报告中可以看到新建的 README 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>
<h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add README</span><br></code></pre></td></tr></table></figure>
<p>此时再运行 <code>git status</code> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br></code></pre></td></tr></table></figure>
<p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 <code>git add</code> 时的版本将被留存在历史记录中。 你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add (files)</code> 命令，开始跟踪当前目录下的文件。 <code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
<h4 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h4><p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 <code>CONTRIBUTING.md</code> 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>文件 <code>CONTRIBUTING.md</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 <code>git add</code> 将”CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 <code>CONTRIBUTING.md</code> 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 <code>git status</code> 看看：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> vim CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br>    modified:   CONTRIBUTING.md<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>怎么回事？ 现在 <code>CONTRIBUTING.md</code> 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本。 如果你现在提交，<code>CONTRIBUTING.md</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p>
<p>总结起来就是每一次修改都需要<code>git add</code> 更新状态：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    new file:   README<br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<h4 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h4><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种格式更为紧凑的输出。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status -s</span><br> M README<br>MM Rakefile<br>A  lib/git.rb<br>M  lib/simplegit.rb<br>?? LICENSE.txt<br></code></pre></td></tr></table></figure>
<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 你可能注意到了 <code>M</code> 有两个可以出现的位置，出现在右边的 <code>M</code> 表示该文件被修改了但是还没被放入暂存区，出现在靠左边的 <code>M</code> 表示该文件被修改了并被放入了暂存区。 例如，上面的状态报告显示： <code>README</code> 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code> 文件被修改了并已将修改后的文件放入了暂存区。 而 <code>Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件的模式。 来看一个实际的 <code>.gitignore</code> 例子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> cat .gitignore</span><br>*.[oa]<br>*~<br></code></pre></td></tr></table></figure>
<p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。 使用两个星号（<code>*</code>）表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> , <code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p>
<p>我们再看一个 .gitignore 文件的例子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">#</span><span class="bash"> no .a files</span><br>*.a<br><br><span class="hljs-meta">#</span><span class="bash"> but <span class="hljs-keyword">do</span> track lib.a, even though you<span class="hljs-string">&#x27;re ignoring .a files above</span></span><br>!lib.a<br><br><span class="hljs-meta">#</span><span class="bash"> only ignore the TODO file <span class="hljs-keyword">in</span> the current directory, not subdir/TODO</span><br>/TODO<br><br><span class="hljs-meta">#</span><span class="bash"> ignore all files <span class="hljs-keyword">in</span> the build/ directory</span><br>build/<br><br><span class="hljs-meta">#</span><span class="bash"> ignore doc/notes.txt, but not doc/server/arch.txt</span><br>doc/*.txt<br><br><span class="hljs-meta">#</span><span class="bash"> ignore all .pdf files <span class="hljs-keyword">in</span> the doc/ directory</span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure>
<blockquote>
<p> GitHub 有一个十分详细的针对数十种项目及语言(包括python，ROS)的 <code>.gitignore</code> 文件列表，你可以在 <a target="_blank" rel="noopener" href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它。</p>
</blockquote>
<h4 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h4><p>如果 <code>git status</code> 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。 稍后我们会详细介绍 <code>git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好下次提交？ 虽然 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，但 <code>git diff</code> 将通过文件补丁的格式更加具体地显示哪些行发生了改变。</p>
<p>假如再次修改 README 文件后暂存，然后编辑 <code>CONTRIBUTING.md</code> 文件后先不暂存， 运行 <code>status</code> 命令将会看到：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    modified:   README<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git diff</span><br>diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md<br>index 8ebb991..643e24f 100644<br>--- a/CONTRIBUTING.md<br>+++ b/CONTRIBUTING.md<br>@@ -65,7 +65,8 @@ branch directly, things can get messy.<br> Please include a nice description of your changes when you submit your PR;<br> if we have to read the whole diff to figure out why you&#x27;re contributing<br> in the first place, you&#x27;re less likely to get feedback and have your change<br>-merged in.<br>+merged in. Also, split your changes into comprehensive chunks if your patch is<br>+longer than a dozen lines.<br><br> If you are starting to work on a particular area, feel free to submit a PR<br> that highlights your work in progress (and note in the PR title that it&#x27;s<br></code></pre></td></tr></table></figure>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git diff --staged</span><br>diff --git a/README b/README<br>new file mode 100644<br>index 0000000..03902a1<br>--- /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+My Project<br></code></pre></td></tr></table></figure>
<p>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p>
<p>像之前说的，暂存 <code>CONTRIBUTING.md</code> 后再编辑，可以使用 <code>git status</code> 查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;# test line&#x27;</span> &gt;&gt; CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    modified:   CONTRIBUTING.md<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>现在运行 <code>git diff</code> 看暂存前后的变化：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git diff</span><br>diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md<br>index 643e24f..87f08c8 100644<br>--- a/CONTRIBUTING.md<br>+++ b/CONTRIBUTING.md<br>@@ -119,3 +119,4 @@ at the<br><span class="hljs-meta"> #</span><span class="bash"><span class="hljs-comment"># Starter Projects</span></span><br><br> See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).<br>+# test line<br></code></pre></td></tr></table></figure>
<p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化：（–staged 和 –cached 是同义词）</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git diff --cached</span><br>diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md<br>index 8ebb991..643e24f 100644<br>--- a/CONTRIBUTING.md<br>+++ b/CONTRIBUTING.md<br>@@ -65,7 +65,8 @@ branch directly, things can get messy.<br> Please include a nice description of your changes when you submit your PR;<br> if we have to read the whole diff to figure out why you&#x27;re contributing<br> in the first place, you&#x27;re less likely to get feedback and have your change<br>-merged in.<br>+merged in. Also, split your changes into comprehensive chunks if your patch is<br>+longer than a dozen lines.<br><br> If you are starting to work on a particular area, feel free to submit a PR<br> that highlights your work in progress (and note in the PR title that it&#x27;s<br></code></pre></td></tr></table></figure>
<h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过但没有暂存的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git commit</span><br></code></pre></td></tr></table></figure>
<p>这种方式会启动文本编辑器以便输入本次提交的说明。 （默认会启用 shell 的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch01-introduction">起步</a> 介绍的方式，使用 <code>git config --global core.editor</code> 命令设定你喜欢的编辑软件。）</p>
<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-meta"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta"># On branch master</span><br><span class="hljs-meta"># Changes to be committed:</span><br><span class="hljs-meta">#	new file:   README</span><br><span class="hljs-meta">#	modified:   CONTRIBUTING.md</span><br><span class="hljs-meta">#</span><br>~<br>~<br>~<br><span class="hljs-string">&quot;.git/COMMIT_EDITMSG&quot;</span> <span class="hljs-number">9</span>L, <span class="hljs-number">283</span>C<br></code></pre></td></tr></table></figure>
<p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。 （如果想要更详细的对修改了哪些内容的提示，可以用 <code>-v</code> 选项，这会将你所做的改变的 diff 输出放到编辑器中从而使你知道本次提交具体做了哪些修改。） 退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。</p>
<p>另外，你也可以在 <code>commit</code> 命令后添加 <code>-m</code> 选项，将提交信息与命令放在同一行，如下所示：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&quot;Story 182: Fix benchmarks for speed&quot;</span></span><br>[master 463dc4f] Story 182: Fix benchmarks for speed<br> 2 files changed, 2 insertions(+)<br> create mode 100644 README<br></code></pre></td></tr></table></figure>
<p>好，现在你已经创建了第一个提交！ 可以看到，提交后它会告诉你，当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p>
<p>请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存文件的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h4 id="跳过暂存区域"><a href="#跳过暂存区域" class="headerlink" title="跳过暂存区域"></a>跳过暂存区域</h4><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;added new benchmarks&#x27;</span></span><br>[master 83e38c7] added new benchmarks<br> 1 file changed, 5 insertions(+), 0 deletions(-)<br></code></pre></td></tr></table></figure>
<p>看到了吗？提交之前不再需要 <code>git add</code> 文件“CONTRIBUTING.md”了。 这是因为 <code>-a</code> 选项使本次提交包含了所有修改过的文件。 这很方便，但是要小心；有时这个选项会将不需要的文件添加到提交中。</p>
<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 <em>未暂存清单</em>）看到：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> rm PROJECTS.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Your branch is up-to-date with &#x27;origin/master&#x27;.<br>Changes not staged for commit:<br>  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        deleted:    PROJECTS.md<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure>
<p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rm PROJECTS.md</span><br>rm &#x27;PROJECTS.md&#x27;<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    deleted:    PROJECTS.md<br></code></pre></td></tr></table></figure>
<p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 <code>.gitignore</code> 文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rm --cached README</span><br></code></pre></td></tr></table></figure>
<p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。 比方说：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rm <span class="hljs-built_in">log</span>/\*.<span class="hljs-built_in">log</span></span><br></code></pre></td></tr></table></figure>
<p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 <code>log/</code> 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rm \*~</span><br></code></pre></td></tr></table></figure>
<p>该命令为删除以 <code>~</code> 结尾的所有文件。</p>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git mv file_from file_to</span><br></code></pre></td></tr></table></figure>
<p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git mv README.md README</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    renamed:    README.md -&gt; README<br></code></pre></td></tr></table></figure>
<p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> mv README.md README</span><br><span class="hljs-meta">$</span><span class="bash"> git rm README.md</span><br><span class="hljs-meta">$</span><span class="bash"> git add README</span><br></code></pre></td></tr></table></figure>
<p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，<code>mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code> 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p>
<p>我们使用一个非常简单的 “simplegit” 项目作为示例。 运行下面的命令获取该项目：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/schacon/simplegit-progit</span><br></code></pre></td></tr></table></figure>
<p>当你在此项目中运行 <code>git log</code> 命令时，可以看到下面的输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span></span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br><br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><br>    removed unnecessary test<br><br>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 10:31:28 2008 -0700<br><br>    first commit<br></code></pre></td></tr></table></figure>
<p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。</p>
<p>其中一个比较有用的选项是 <code>-p</code>，它会显示每次提交所引入的差异。 与此同时，你也可以使用 <code>-2</code> 选项来仅显示最近的两次提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> -p -2</span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br><br>diff --git a/Rakefile b/Rakefile<br>index a874b73..8f94139 100644<br>--- a/Rakefile<br>+++ b/Rakefile<br>@@ -5,7 +5,7 @@ require &#x27;rake/gempackagetask&#x27;<br> spec = Gem::Specification.new do |s|<br>     s.platform  =   Gem::Platform::RUBY<br>     s.name      =   &quot;simplegit&quot;<br>-    s.version   =   &quot;0.1.0&quot;<br>+    s.version   =   &quot;0.1.1&quot;<br>     s.author    =   &quot;Scott Chacon&quot;<br>     s.email     =   &quot;schacon@gee-mail.com&quot;<br>     s.summary   =   &quot;A simple gem for using Git in Ruby code.&quot;<br><br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><br>    removed unnecessary test<br><br>diff --git a/lib/simplegit.rb b/lib/simplegit.rb<br>index a0a60ae..47c6340 100644<br>--- a/lib/simplegit.rb<br>+++ b/lib/simplegit.rb<br>@@ -18,8 +18,3 @@ class SimpleGit<br>     end<br><br> end<br>-<br>-if $0 == __FILE__<br>-  git = SimpleGit.new<br>-  puts git.show<br>-end<br>\ No newline at end of file<br></code></pre></td></tr></table></figure>
<p>该选项除了显示基本信息之外，还附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 <code>--stat</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br><br> Rakefile | 2 +-<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br><br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><br>    removed unnecessary test<br><br> lib/simplegit.rb | 5 -----<br> 1 file changed, 5 deletions(-)<br><br>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 10:31:28 2008 -0700<br><br>    first commit<br><br> README           |  6 ++++++<br> Rakefile         | 23 +++++++++++++++++++++++<br> lib/simplegit.rb | 25 +++++++++++++++++++++++++<br> 3 files changed, 54 insertions(+)<br></code></pre></td></tr></table></figure>
<p>正如你所看到的，<code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p>
<p>另一个非常有用的选项是 <code>--pretty</code>。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 <code>oneline</code> 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 选项，它们展示信息的格式基本一致，但是详尽程度不一：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=oneline</span><br>ca82a6dff817ec66f44342007202690a93763949 changed the version number<br>085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test<br>a11bef06a3f659402fe7563abf99ad00de2209e6 first commit<br></code></pre></td></tr></table></figure>
<p>但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h - %an, %ar : %s&quot;</span></span><br>ca82a6d - Scott Chacon, 6 years ago : changed the version number<br>085bb3b - Scott Chacon, 6 years ago : removed unnecessary test<br>a11bef0 - Scott Chacon, 6 years ago : first commit<br></code></pre></td></tr></table></figure>
<h4 id="定制输出格式"><a href="#定制输出格式" class="headerlink" title="定制输出格式"></a>定制输出格式</h4><p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/rpretty_format"><code>git log --pretty=format</code> 常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%H</code></td>
<td align="left">提交的完整哈希值</td>
</tr>
<tr>
<td align="left"><code>%h</code></td>
<td align="left">提交的简写哈希值</td>
</tr>
<tr>
<td align="left"><code>%T</code></td>
<td align="left">树的完整哈希值</td>
</tr>
<tr>
<td align="left"><code>%t</code></td>
<td align="left">树的简写哈希值</td>
</tr>
<tr>
<td align="left"><code>%P</code></td>
<td align="left">父提交的完整哈希值</td>
</tr>
<tr>
<td align="left"><code>%p</code></td>
<td align="left">父提交的简写哈希值</td>
</tr>
<tr>
<td align="left"><code>%an</code></td>
<td align="left">作者名字</td>
</tr>
<tr>
<td align="left"><code>%ae</code></td>
<td align="left">作者的电子邮件地址</td>
</tr>
<tr>
<td align="left"><code>%ad</code></td>
<td align="left">作者修订日期（可以用 –date= 选项定制格式）</td>
</tr>
<tr>
<td align="left"><code>%ar</code></td>
<td align="left">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td align="left"><code>%cn</code></td>
<td align="left">提交者（committer）的名字</td>
</tr>
<tr>
<td align="left"><code>%ce</code></td>
<td align="left">提交者的电子邮件地址</td>
</tr>
<tr>
<td align="left"><code>%cd</code></td>
<td align="left">提交日期</td>
</tr>
<tr>
<td align="left"><code>%cr</code></td>
<td align="left">提交日期（距今多长时间）</td>
</tr>
<tr>
<td align="left"><code>%s</code></td>
<td align="left">提交说明</td>
</tr>
</tbody></table>
<p>你一定奇怪 <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git">分布式 Git</a> 再详细介绍两者之间的细微差别。</p>
<p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h %s&quot;</span> --graph</span><br>* 2d3acf9 ignore errors from SIGCHLD on trap<br>*  5e3ee11 Merge branch &#x27;master&#x27; of git://github.com/dustin/grit<br>|\<br>| * 420eac9 Added a method for getting the current branch.<br>* | 30e367c timeout code and tests<br>* | 5a09431 add timeout protection to grit<br>* | e1193f8 support for heads with slashes in them<br>|/<br>* d6016bc require time for xmlschema<br>*  11d191e Merge branch &#x27;defunkt&#x27; into local<br></code></pre></td></tr></table></figure>
<p>这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。</p>
<p>以上只是简单介绍了一些 <code>git log</code> 命令支持的选项。 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/rlog_options"><code>git log</code> 的常用选项</a> 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code></td>
<td align="left">按补丁格式显示每个提交引入的差异。</td>
</tr>
<tr>
<td align="left"><code>--stat</code></td>
<td align="left">显示每次提交的文件修改统计信息。</td>
</tr>
<tr>
<td align="left"><code>--shortstat</code></td>
<td align="left">只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td align="left"><code>--name-only</code></td>
<td align="left">仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td align="left"><code>--name-status</code></td>
<td align="left">显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td align="left"><code>--abbrev-commit</code></td>
<td align="left">仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。</td>
</tr>
<tr>
<td align="left"><code>--relative-date</code></td>
<td align="left">使用较短的相对时间而不是完整格式显示日期（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td align="left"><code>--graph</code></td>
<td align="left">在日志旁以 ASCII 图形显示分支与合并历史。</td>
</tr>
<tr>
<td align="left"><code>--pretty</code></td>
<td align="left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（用来定义自己的格式）。</td>
</tr>
</tbody></table>
<h4 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h4><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出一部分的提交。 之前你已经看到过 <code>-2</code> 选项了，它只会显示最近的两条提交， 实际上，你可以使用类似 <code>-</code> 的选项，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的 <code>n</code> 条提交。 不过实践中这个选项不是很常用，因为 Git 默认会将所有的输出传送到分页程序中，所以你一次只会看到一页的内容。</p>
<p>但是，类似 <code>--since</code> 和 <code>--until</code> 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所有提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --since=2.weeks</span><br></code></pre></td></tr></table></figure>
<p>该命令可用的格式十分丰富——可以是类似 <code>&quot;2008-01-15&quot;</code> 的具体的某一天，也可以是类似 <code>&quot;2 years 1 day 3 minutes ago&quot;</code> 的相对日期。</p>
<p>还可以过滤出匹配指定条件的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。 （请注意，如果你要同时对作者和提交说明进行过滤，就必须添加 <code>--all-match</code> 选项，否则该命令将会匹配满足其中任意一个条件的提交）</p>
<p>另一个非常有用的过滤器是 <code>-S</code>，它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> -Sfunction_name</span><br></code></pre></td></tr></table></figure>
<p>最后一个很实用的 <code>git log</code> 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。</p>
<p>在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/rlimit_options">限制 <code>git log</code> 输出的选项</a> 中列出了常用的选项</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-(n)</code></td>
<td align="left">仅显示最近的 n 条提交。</td>
</tr>
<tr>
<td align="left"><code>--since</code>, <code>--after</code></td>
<td align="left">仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td align="left"><code>--until</code>, <code>--before</code></td>
<td align="left">仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td align="left"><code>--author</code></td>
<td align="left">仅显示作者匹配指定字符串的提交。</td>
</tr>
<tr>
<td align="left"><code>--committer</code></td>
<td align="left">仅显示提交者匹配指定字符串的提交。</td>
</tr>
<tr>
<td align="left"><code>--grep</code></td>
<td align="left">仅显示提交说明中包含指定字符串的提交。</td>
</tr>
<tr>
<td align="left"><code>-S</code></td>
<td align="left">仅显示添加或删除内容匹配指定字符串的提交。</td>
</tr>
</tbody></table>
<p>来看一个实际的例子，如果要查看 2008 年 10 月期间 Git 源代码仓库中，由 Junio Hamano 提交的修改了测试文件并且尚未合并的提交，可以使用下面的命令:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%h - %s&quot;</span> --author=gitster --since=<span class="hljs-string">&quot;2008-10-01&quot;</span> \</span><br><span class="bash">   --before=<span class="hljs-string">&quot;2008-11-01&quot;</span> --no-merges -- t/</span><br>5610e3b - Fix testcase failure when extended attributes are in use<br>acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API<br>f563754 - demonstrate breakage of detached checkout with symbolic link HEAD<br>d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths<br>51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD<br>b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch<br></code></pre></td></tr></table></figure>
<p>在近 40000 条提交中，上面的输出仅列出了符合条件的 6 条记录。</p>
<h3 id="取消操作"><a href="#取消操作" class="headerlink" title="取消操作"></a>取消操作</h3><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git commit --amend</span><br></code></pre></td></tr></table></figure>
<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p>
<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&#x27;initial commit&#x27;</span></span><br><span class="hljs-meta">$</span><span class="bash"> git add forgotten_file</span><br><span class="hljs-meta">$</span><span class="bash"> git commit --amend</span><br></code></pre></td></tr></table></figure>
<p>最终你只会有一个提交——第二次提交将代替第一次提交的结果。</p>
<h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add *</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    renamed:    README.md -&gt; README<br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>在 “Changes to be committed” 文字正下方，提示使用 <code>git reset HEAD ...</code> 来取消暂存。 所以，我们可以这样来取消暂存 <code>CONTRIBUTING.md</code> 文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git reset HEAD CONTRIBUTING.md</span><br>Unstaged changes after reset:<br>M	CONTRIBUTING.md<br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    renamed:    README.md -&gt; README<br><br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>这个命令有点儿奇怪，但是起作用了。 <code>CONTRIBUTING.md</code> 文件已经是修改未暂存的状态了。</p>
<p>到目前为止这个神奇的调用就是你需要对 <code>git reset</code> 命令了解的全部。我们将会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_git_reset">重置揭密</a> 中了解 <code>reset</code> 的更多细节以及如何掌握它做一些真正有趣的事。</p>
<h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，<code>git status</code> 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console">Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>    modified:   CONTRIBUTING.md<br></code></pre></td></tr></table></figure>
<p>它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -- CONTRIBUTING.md</span><br><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>Changes to be committed:<br>  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)<br><br>    renamed:    README.md -&gt; README<br></code></pre></td></tr></table></figure>
<p>可以看到那些修改已经被撤消了。</p>
<p>如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 介绍保存进度与分支；这些通常是更好的做法。</p>
<blockquote>
<p>你需要知道 <code>git checkout -- [file]</code> 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失——你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p>
</blockquote>
<p>记住，在 Git 中任何 <em>已提交的</em> 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code> 选项覆盖的提交也可以恢复（阅读 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_data_recovery">数据恢复</a> 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p>
<h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 </p>
<h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/schacon/ticgit</span><br>Cloning into &#x27;ticgit&#x27;...<br>remote: Reusing existing pack: 1857, done.<br>remote: Total 1857 (delta 0), reused 0 (delta 0)<br>Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.<br>Resolving deltas: 100% (772/772), done.<br>Checking connectivity... done.<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ticgit</span><br><span class="hljs-meta">$</span><span class="bash"> git remote</span><br>origin<br></code></pre></td></tr></table></figure>
<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>origin	https://github.com/schacon/ticgit (fetch)<br>origin	https://github.com/schacon/ticgit (push)<br></code></pre></td></tr></table></figure>
<p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> grit</span><br><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>bakkdoor  https://github.com/bakkdoor/grit (fetch)<br>bakkdoor  https://github.com/bakkdoor/grit (push)<br>cho45     https://github.com/cho45/grit (fetch)<br>cho45     https://github.com/cho45/grit (push)<br>defunkt   https://github.com/defunkt/grit (fetch)<br>defunkt   https://github.com/defunkt/grit (push)<br>koke      git://github.com/koke/grit.git (fetch)<br>koke      git://github.com/koke/grit.git (push)<br>origin    git@github.com:mojombo/grit.git (fetch)<br>origin    git@github.com:mojombo/grit.git (push)<br></code></pre></td></tr></table></figure>
<p>这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。</p>
<p>注意这些远程仓库使用了不同的协议；我们将会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server">在服务器上搭建 Git</a> 中了解关于它们的更多信息。</p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 <code>git remote add  </code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote</span><br>origin<br><span class="hljs-meta">$</span><span class="bash"> git remote add pb https://github.com/paulboone/ticgit</span><br><span class="hljs-meta">$</span><span class="bash"> git remote -v</span><br>origin	https://github.com/schacon/ticgit (fetch)<br>origin	https://github.com/schacon/ticgit (push)<br>pb	https://github.com/paulboone/ticgit (fetch)<br>pb	https://github.com/paulboone/ticgit (push)<br></code></pre></td></tr></table></figure>
<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git fetch pb</span><br>remote: Counting objects: 43, done.<br>remote: Compressing objects: 100% (36/36), done.<br>remote: Total 43 (delta 10), reused 31 (delta 5)<br>Unpacking objects: 100% (43/43), done.<br>From https://github.com/paulboone/ticgit<br> * [new branch]      master     -&gt; pb/master<br> * [new branch]      ticgit     -&gt; pb/ticgit<br></code></pre></td></tr></table></figure>
<p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到——你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p>
<h4 id="从远程仓库抓取或拉取"><a href="#从远程仓库抓取或拉取" class="headerlink" title="从远程仓库抓取或拉取"></a>从远程仓库抓取或拉取</h4><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git fetch [remote-name]</span><br></code></pre></td></tr></table></figure>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 了解更多信息），可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin master</span><br></code></pre></td></tr></table></figure>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 阅读 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 了解如何推送到远程仓库服务器的详细信息。</p>
<h4 id="查看远程仓库-1"><a href="#查看远程仓库-1" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote show origin</span><br>* remote origin<br>  Fetch URL: https://github.com/schacon/ticgit<br>  Push  URL: https://github.com/schacon/ticgit<br>  HEAD branch: master<br>  Remote branches:<br>    master                               tracked<br>    dev-branch                           tracked<br>  Local branch configured for &#x27;git pull&#x27;:<br>    master merges with remote master<br>  Local ref configured for &#x27;git push&#x27;:<br>    master pushes to master (up to date)<br></code></pre></td></tr></table></figure>
<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。</p>
<p>这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote show origin</span><br>* remote origin<br>  URL: https://github.com/my-org/complex-project<br>  Fetch URL: https://github.com/my-org/complex-project<br>  Push  URL: https://github.com/my-org/complex-project<br>  HEAD branch: master<br>  Remote branches:<br>    master                           tracked<br>    dev-branch                       tracked<br>    markdown-strip                   tracked<br>    issue-43                         new (next fetch will store in remotes/origin)<br>    issue-45                         new (next fetch will store in remotes/origin)<br>    refs/remotes/origin/issue-11     stale (use &#x27;git remote prune&#x27; to remove)<br>  Local branches configured for &#x27;git pull&#x27;:<br>    dev-branch merges with remote dev-branch<br>    master     merges with remote master<br>  Local refs configured for &#x27;git push&#x27;:<br>    dev-branch                     pushes to dev-branch                     (up to date)<br>    markdown-strip                 pushes to markdown-strip                 (up to date)<br>    master                         pushes to master                         (up to date)<br></code></pre></td></tr></table></figure>
<p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code>git pull</code> 时哪些分支会自动合并。</p>
<h4 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h4><p>如果想要重命名引用的名字可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote rename pb paul</span><br><span class="hljs-meta">$</span><span class="bash"> git remote</span><br>origin<br>paul<br></code></pre></td></tr></table></figure>
<p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 <code>git remote rm</code> ：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote rm paul</span><br><span class="hljs-meta">$</span><span class="bash"> git remote</span><br>origin<br></code></pre></td></tr></table></figure>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p>
<h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 <code>git tag</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v0.1<br>v1.3<br></code></pre></td></tr></table></figure>
<p>这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。</p>
<p>你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag -l <span class="hljs-string">&#x27;v1.8.5*&#x27;</span></span><br>v1.8.5<br>v1.8.5-rc0<br>v1.8.5-rc1<br>v1.8.5-rc2<br>v1.8.5-rc3<br>v1.8.5.1<br>v1.8.5.2<br>v1.8.5.3<br>v1.8.5.4<br>v1.8.5.5<br></code></pre></td></tr></table></figure>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p>一个轻量标签很像一个不会改变的分支——它只是一个特定提交的引用。</p>
<p>然而，附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag -a v1.4 -m <span class="hljs-string">&quot;my version 1.4&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v0.1<br>v1.3<br>v1.4<br></code></pre></td></tr></table></figure>
<p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p>
<p>通过使用 <code>git show</code> 命令可以看到标签信息与对应的提交信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git show v1.4</span><br>tag v1.4<br>Tagger: Ben Straub &lt;ben@straub.cc&gt;<br>Date:   Sat May 3 20:19:12 2014 -0700<br><br>my version 1.4<br><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br></code></pre></td></tr></table></figure>
<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
<h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag v1.4-lw</span><br><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v0.1<br>v1.3<br>v1.4<br>v1.4-lw<br>v1.5<br></code></pre></td></tr></table></figure>
<p>这时，如果在标签上运行 <code>git show</code>，你不会看到额外的标签信息。 命令只会显示出提交信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git show v1.4-lw</span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br></code></pre></td></tr></table></figure>
<h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>你也可以对过去的提交打标签。 假设提交历史是这样的：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=oneline</span><br>15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;<br>a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support<br>0d52aaab4479697da7686c15f77a3d64d9165190 one more thing<br>6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;<br>0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function<br>4682c3261057305bdd616e23b64b0857d832627b added a todo file<br>166ae0c4d3f420721acbb115cc33848dfcc2121a started write support<br>9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile<br>964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo<br>8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme<br></code></pre></td></tr></table></figure>
<p>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag -a v1.2 9fceb02</span><br></code></pre></td></tr></table></figure>
<p>可以看到你已经在那次提交上打上标签了：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag</span><br>v0.1<br>v1.2<br>v1.3<br>v1.4<br>v1.4-lw<br>v1.5<br><br><span class="hljs-meta">$</span><span class="bash"> git show v1.2</span><br>tag v1.2<br>Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Feb 9 15:32:16 2009 -0800<br><br>version 1.2<br>commit 9fceb02d0ae598e95dc970b74767f19372d61af8<br>Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;<br>Date:   Sun Apr 27 20:43:35 2008 -0700<br><br>    updated rakefile<br>...<br></code></pre></td></tr></table></figure>
<h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 <code>git push origin [tagname]</code>。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin v1.5</span><br>Counting objects: 14, done.<br>Delta compression using up to 8 threads.<br>Compressing objects: 100% (12/12), done.<br>Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.<br>Total 14 (delta 3), reused 0 (delta 0)<br>To git@github.com:schacon/simplegit.git<br> * [new tag]         v1.5 -&gt; v1.5<br></code></pre></td></tr></table></figure>
<p>如果想要一次性推送很多标签，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin --tags</span><br>Counting objects: 1, done.<br>Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.<br>Total 1 (delta 0), reused 0 (delta 0)<br>To git@github.com:schacon/simplegit.git<br> * [new tag]         v1.4 -&gt; v1.4<br> * [new tag]         v1.4-lw -&gt; v1.4-lw<br></code></pre></td></tr></table></figure>
<p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p>
<h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p>要删除掉你本地仓库上的标签，可以使用命令 <code>git tag -d </code>。例如，可以使用下面的命令删除掉一个轻量级标签：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git tag -d v1.4-lw</span><br>Deleted tag &#x27;v1.4-lw&#x27; (was e7d5add)<br></code></pre></td></tr></table></figure>
<p>应该注意的是上述命令并不会从任何远程仓库中移除这个标签，你必须使用 <code>git push  :refs/tags/</code> 来更新你的远程仓库：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin :refs/tags/v1.4-lw</span><br>To /git@github.com:schacon/simplegit.git<br> - [deleted]         v1.4-lw<br></code></pre></td></tr></table></figure>
<h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令，虽然说这会使你的仓库处于“分离头指针（detacthed HEAD）”状态——这个状态有些不好的副作用：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout 2.0.0</span><br>Note: checking out &#x27;2.0.0&#x27;.<br><br>You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.<br><br>If you want to create a new branch to retain commits you create, you may<br>do so (now or later) by using -b with the checkout command again. Example:<br><br>  git checkout -b &lt;new-branch&gt;<br><br>HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final<br><br><span class="hljs-meta">$</span><span class="bash"> git checkout 2.0-beta-0.1</span><br>Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final<br>HEAD is now at df3f601... add atlas.json and cover image<br></code></pre></td></tr></table></figure>
<p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。因此，如果你需要进行更改——比如说你正在修复旧版本的错误——这通常需要创建一个新分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b version2 v2.0.0</span><br>Switched to a new branch &#x27;version2&#x27;<br></code></pre></td></tr></table></figure>
<p>当然，如果在这之后又进行了一次提交，<code>version2</code> 分支会因为这个改动向前移动，<code>version2</code> 分支就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就应该当心了。</p>
<h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。</p>
<p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.co checkout</span><br><span class="hljs-meta">$</span><span class="bash"> git config --global alias.br branch</span><br><span class="hljs-meta">$</span><span class="bash"> git config --global alias.ci commit</span><br><span class="hljs-meta">$</span><span class="bash"> git config --global alias.st status</span><br></code></pre></td></tr></table></figure>
<p>这意味着，当要输入 <code>git commit</code> 时，只需要输入 <code>git ci</code>。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。</p>
<p>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.unstage <span class="hljs-string">&#x27;reset HEAD --&#x27;</span></span><br></code></pre></td></tr></table></figure>
<p>这会使下面的两个命令等价：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git unstage fileA</span><br><span class="hljs-meta">$</span><span class="bash"> git reset HEAD -- fileA</span><br></code></pre></td></tr></table></figure>
<p>这样看起来更清楚一些。 通常也会添加一个 <code>last</code> 命令，像这样：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.last <span class="hljs-string">&#x27;log -1 HEAD&#x27;</span></span><br></code></pre></td></tr></table></figure>
<p>这样，可以轻松地看到最后一次提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git last</span><br>commit 66938dae3329c7aebe598c2246a8e6af90d04646<br>Author: Josh Goebel &lt;dreamer3@example.com&gt;<br>Date:   Tue Aug 26 19:48:51 2008 +0800<br><br>    test for current head<br><br>    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;<br></code></pre></td></tr></table></figure>
<p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git config --global alias.visual <span class="hljs-string">&#x27;!gitk&#x27;</span></span><br></code></pre></td></tr></table></figure>
<h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>
<p>有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</p>
<h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。</p>
<p>或许你还记得之前的内容，Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。</p>
<p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p>
<p>为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git add README test.rb LICENSE</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">&#x27;The initial commit of my project&#x27;</span></span><br></code></pre></td></tr></table></figure>
<p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
<p>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<p><img src="Git%5Cgit_%E9%A6%96%E6%AC%A1%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1.png" srcset="/img/loading.gif" alt="image-20200221185759349"></p>
<p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p>
<blockquote>
<p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p>
</blockquote>
<p><img src="Git%5Cgit_%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" alt="image-20200221190056356"></p>
<h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch testing</span><br></code></pre></td></tr></table></figure>
<p>这会在当前所在的提交对象上创建一个指针。</p>
<p><img src="Git%5Cgit_%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" alt="image-20200221190314721"></p>
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p>
<p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate</span><br>f30ab (HEAD, master, testing) add feature #32 - ability to add new<br>34ac2 fixed bug #1328 - stack overflow under certain conditions<br>98ca9 initial commit of my project<br></code></pre></td></tr></table></figure>
<p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p>
<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout testing</span><br></code></pre></td></tr></table></figure>
<p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> vim test.rb</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;made a change&#x27;</span></span><br></code></pre></td></tr></table></figure>
<p><img src="Git%5Cgit_%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" alt="image-20200221190530844"></p>
<p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br></code></pre></td></tr></table></figure>
<p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向另一个方向进行开发。</p>
<blockquote>
<p>分支切换会改变你工作目录中的文件。在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p>
</blockquote>
<p>我们不妨再稍微做些修改并提交：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> vim test.rb</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;made other changes&#x27;</span></span><br></code></pre></td></tr></table></figure>
<p>现在，这个项目的提交历史已经产生了分叉。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p>
<p><img src="Git%5Cgit_%E5%88%86%E6%94%AF%E5%88%86%E5%8F%89.png" srcset="/img/loading.gif" alt="image-20200221190834692"></p>
<p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --oneline --decorate --graph --all</span><br>* c2b9e (HEAD, master) made other changes<br>| * 87ab2 (testing) made a change<br>|/<br>* f30ab add feature #32 - ability to add new formats to the<br>* 34ac2 fixed bug #1328 - stack overflow under certain conditions<br>* 98ca9 initial commit of my project<br></code></pre></td></tr></table></figure>
<p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p>
<p>这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。</p>
<h3 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h3><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p>
<ol>
<li>开发某个网站。</li>
<li>为实现某个新的需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p>
<ol>
<li>切换到你的线上分支（production branch）。</li>
<li>为这个紧急任务新建一个分支，并在其中修复它。</li>
<li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li>
<li>切换回你最初工作的分支上，继续工作。</li>
</ol>
<h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p>
<p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b iss53</span><br>Switched to a new branch &quot;iss53&quot;<br></code></pre></td></tr></table></figure>
<p>它是下面两条命令的简写：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch iss53</span><br><span class="hljs-meta">$</span><span class="bash"> git checkout iss53</span><br></code></pre></td></tr></table></figure>
<p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经在处理该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> vim index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;added a new footer [issue 53]&#x27;</span></span><br></code></pre></td></tr></table></figure>
<p><img src="Git%5Cgit_%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" alt="image-20200221191300889"></p>
<p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p>
<p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_git_stashing">储藏与清理</a> 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br>Switched to branch &#x27;master&#x27;<br></code></pre></td></tr></table></figure>
<p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p>
<p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b hotfix</span><br>Switched to a new branch &#x27;hotfix&#x27;<br><span class="hljs-meta">$</span><span class="bash"> vim index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;fixed the broken email address&#x27;</span></span><br>[hotfix 1fb7853] fixed the broken email address<br> 1 file changed, 2 insertions(+)<br></code></pre></td></tr></table></figure>
<p><img src="Git%5Cgit_%E5%88%86%E6%94%AF2.png" srcset="/img/loading.gif" alt="image-20200221191348528"></p>
<p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge hotfix</span><br>Updating f42c576..3a0874c<br>Fast-forward<br> index.html | 2 ++<br> 1 file changed, 2 insertions(+)<br></code></pre></td></tr></table></figure>
<p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p>
<p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -d hotfix</span><br>Deleted branch hotfix (3a0874c).<br></code></pre></td></tr></table></figure>
<p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout iss53</span><br>Switched to branch &quot;iss53&quot;<br><span class="hljs-meta">$</span><span class="bash"> vim index.html</span><br><span class="hljs-meta">$</span><span class="bash"> git commit -a -m <span class="hljs-string">&#x27;finished the new footer [issue 53]&#x27;</span></span><br>[iss53 ad82d7a] finished the new footer [issue 53]<br>1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure>
<p><img src="Git%5Cgit_%E5%88%86%E6%94%AF3.png" srcset="/img/loading.gif" alt="image-20200221191502537"></p>
<p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p>
<h4 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h4><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br>Switched to branch &#x27;master&#x27;<br><span class="hljs-meta">$</span><span class="bash"> git merge iss53</span><br>Merge made by the &#x27;recursive&#x27; strategy.<br>index.html |    1 +<br>1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure>
<p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。</p>
<p><img src="Git%5Cgit_%E4%B8%89%E6%96%B9%E5%90%88%E5%B9%B6.png" srcset="/img/loading.gif" alt="image-20200221191739143"></p>
<p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p>
<p><img src="Git%5Cgit_%E4%B8%89%E6%96%B9%E5%90%88%E5%B9%B62.png" srcset="/img/loading.gif" alt="image-20200221191815081"></p>
<p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p>
<p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -d iss53</span><br></code></pre></td></tr></table></figure>
<h4 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h4><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git merge iss53</span><br>Auto-merging index.html<br>CONFLICT (content): Merge conflict in index.html<br>Automatic merge failed; fix conflicts and then commit the result.<br></code></pre></td></tr></table></figure>
<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>You have unmerged paths.<br>  (fix conflicts and run &quot;git commit&quot;)<br><br>Unmerged paths:<br>  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)<br><br>    both modified:      index.html<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure>
<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>=======<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br> please contact us at support@github.com<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html<br></code></pre></td></tr></table></figure>
<p>这表示 <code>HEAD</code> 所指示的版本（也就是你的 <code>master</code> 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>iss53</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br>please contact us at email.support@github.com<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p>
<p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git mergetool</span><br><br>This message is displayed because &#x27;merge.tool&#x27; is not configured.<br>See &#x27;git mergetool --tool-help&#x27; or &#x27;git help config&#x27; for more details.<br>&#x27;git mergetool&#x27; will now attempt to use one of the following tools:<br>opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge<br>Merging:<br>index.html<br><br>Normal merge conflict for &#x27;index.html&#x27;:<br>  &#123;local&#125;: modified file<br>  &#123;remote&#125;: modified file<br>Hit return to start merge resolution tool (opendiff):<br></code></pre></td></tr></table></figure>
<p>如果你想使用除默认工具（在这里 Git 使用 <code>opendiff</code> 做为默认的合并工具，因为作者在 Mac 上运行该程序）外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。</p>
<p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git status</span><br>On branch master<br>All conflicts fixed but you are still merging.<br>  (use &quot;git commit&quot; to conclude merge)<br><br>Changes to be committed:<br><br>    modified:   index.html<br></code></pre></td></tr></table></figure>
<p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs console">Merge branch &#x27;iss53&#x27;<br><br>Conflicts:<br>    index.html<br><span class="hljs-meta">#</span><br><span class="bash"><span class="hljs-comment"># It looks like you may be committing a merge.</span></span><br><span class="hljs-meta">#</span><span class="bash"> If this is not correct, please remove the file</span><br><span class="hljs-meta">#</span><span class="bash">	.git/MERGE_HEAD</span><br><span class="hljs-meta">#</span><span class="bash"> and try again.</span><br><br><br><span class="hljs-meta">#</span><span class="bash"> Please enter the commit message <span class="hljs-keyword">for</span> your changes. Lines starting</span><br><span class="hljs-meta">#</span><span class="bash"> with <span class="hljs-string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta">#</span><span class="bash"> On branch master</span><br><span class="hljs-meta">#</span><span class="bash"> All conflicts fixed but you are still merging.</span><br><span class="hljs-meta">#</span><br><span class="bash"><span class="hljs-comment"># Changes to be committed:</span></span><br><span class="hljs-meta">#</span><span class="bash">	modified:   index.html</span><br><span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure>
<p>如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息，添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p>
<p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch</span><br>  iss53<br>* master<br>  testing<br></code></pre></td></tr></table></figure>
<p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -v</span><br>  iss53   93b412c fix javascript issue<br>* master  7a98805 Merge branch &#x27;iss53&#x27;<br>  testing 782fd34 add scott to the author list in the readmes<br></code></pre></td></tr></table></figure>
<p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch --merged</span><br>  iss53<br>* master<br></code></pre></td></tr></table></figure>
<p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p>
<p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch --no-merged</span><br>  testing<br></code></pre></td></tr></table></figure>
<p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -d testing</span><br>error: The branch &#x27;testing&#x27; is not fully merged.<br>If you are sure you want to delete it, run &#x27;git branch -D testing&#x27;.<br></code></pre></td></tr></table></figure>
<p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p>
<h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><p>现在你已经学会新建和合并分支，那么你可以或者应该用它来做些什么呢？ 在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。</p>
<h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p>
<p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p>
<p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p>
<p><img src="Git%5Cgit_%E6%B8%90%E8%BF%9B%E7%A8%B3%E5%AE%9A%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" alt="image-20200221192402784"></p>
<p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p>
<h4 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h4><p>特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（<code>VCS</code>）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。 然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。</p>
<p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p>
<p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code> 分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code> 的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p>
<p><img src="Git%5Cgit_%E7%89%B9%E6%80%A7%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" alt="image-20200221192511297"></p>
<p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p>
<p><img src="Git%5Cgit_%E7%89%B9%E6%80%A7%E5%88%86%E6%94%AF2.png" srcset="/img/loading.gif" alt="image-20200221192546452"></p>
<p>我们将会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git">分布式 Git</a> 中向你揭示更多有关分支工作流的细节，因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。</p>
<p>请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><h4 id="远程分支-1"><a href="#远程分支-1" class="headerlink" title="远程分支"></a>远程分支</h4><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 <code>git ls-remote [remote]</code> 来显式地获得远程引用的完整列表，或者通过 <code>git remote show [remote]</code> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。</p>
<p>远程跟踪分支是远程分支状态的引用。 它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p>
<p>它们以 <code>(remote)/(branch)</code> 形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支；但是在服务器上的分支会指向 <code>origin/iss53</code> 的提交。</p>
<p>这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据，创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p>
<blockquote>
<p>“origin” 并无特殊含义</p>
<p>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 <code>git clone</code> 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。</p>
</blockquote>
<p><img src="Git%5C%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8.png" srcset="/img/loading.gif" alt="image-20200221201134137"></p>
<p>如果你在本地的 <code>master</code> 分支做了一些工作，在同一段时间内有其他人推送提交到 <code>git.ourcompany.com</code> 并且更新了它的 <code>master</code> 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 <code>origin/master</code> 指针就不会移动。</p>
<p><img src="Git%5C%E6%9C%AC%E5%9C%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E5%8F%89.png" srcset="/img/loading.gif" alt="image-20200221201257270"></p>
<p>如果要同步数据，运行 <code>git fetch origin</code> 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动 <code>origin/master</code> 指针到更新之后的位置。</p>
<p><img src="Git%5C%E5%90%8C%E6%AD%A5%E4%BB%93%E5%BA%93.png" srcset="/img/loading.gif" alt="image-20200221201330149"></p>
<p>为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个 sprint 团队。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch02-git-basics">Git 基础</a> 中详细说明。 将这个远程仓库命名为 <code>teamone</code>，将其作为完整 URL 的缩写。</p>
<p><img src="Git%5C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%931.png" srcset="/img/loading.gif" alt="image-20200221201411043"></p>
<p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个子集，所以 Git 并不会抓取数据而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。</p>
<p><img src="C:\Users\www43\AppData\Roaming\Typora\typora-user-images\image-20200221201445030.png" srcset="/img/loading.gif" alt="image-20200221201445030"></p>
<h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p>
<p>如果希望和别人一起在名为 <code>serverfix</code> 的分支上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push (remote) (branch)</code>:</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin serverfix</span><br>Counting objects: 24, done.<br>Delta compression using up to 8 threads.<br>Compressing objects: 100% (15/15), done.<br>Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.<br>Total 24 (delta 2), reused 0 (delta 0)<br>To https://github.com/schacon/simplegit<br> * [new branch]      serverfix -&gt; serverfix<br></code></pre></td></tr></table></figure>
<p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals">Git 内部原理</a> 的 <code>refs/heads/</code> 部分，但是现在可以先把它放在儿。 你也可以运行 <code>git push origin serverfix:serverfix</code>，它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p>
<blockquote>
<p>如何避免每次输入密码</p>
<p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p>
<p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code> </code> 来设置它。</p>
<p>想要了解更多关于不同验证缓存的可用选项，查看 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching">凭证存储</a>。</p>
</blockquote>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git fetch origin</span><br>remote: Counting objects: 7, done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 3 (delta 0)<br>Unpacking objects: 100% (3/3), done.<br>From https://github.com/schacon/simplegit<br> * [new branch]      serverfix    -&gt; origin/serverfix<br></code></pre></td></tr></table></figure>
<p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支——只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p>
<p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b serverfix origin/serverfix</span><br>Branch serverfix set up to track remote branch serverfix from origin.<br>Switched to a new branch &#x27;serverfix&#x27;<br></code></pre></td></tr></table></figure>
<p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p>
<h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 <code>master</code> 分支。 最简单的实例就是像之前看到的那样，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout --track origin/serverfix</span><br>Branch serverfix set up to track remote branch serverfix from origin.<br>Switched to a new branch &#x27;serverfix&#x27;<br></code></pre></td></tr></table></figure>
<p>如果想要将本地分支与远程分支设置为不同名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout -b sf origin/serverfix</span><br>Branch sf set up to track remote branch serverfix from origin.<br>Switched to a new branch &#x27;sf&#x27;<br></code></pre></td></tr></table></figure>
<p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -u origin/serverfix</span><br>Branch serverfix set up to track remote branch serverfix from origin.<br></code></pre></td></tr></table></figure>
<p>如果想要查看设置的所有跟踪分支，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -vv</span><br>  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets<br>  master    1ae2a45 [origin/master] deploying index fix<br>* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it<br>  testing   5ea463a trying something new<br></code></pre></td></tr></table></figure>
<p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p>
<p>需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：<code>$ git fetch --all; git branch -vv</code></p>
<h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 <code>git pull</code> 在大多数情况下它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p>
<h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git push origin --delete serverfix</span><br>To https://github.com/schacon/simplegit<br> - [deleted]         serverfix<br></code></pre></td></tr></table></figure>
<p>基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p>
<h4 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h4><p>请回顾之前在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_basic_merging">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p>
<p><img src="Git%5Cimage-20200221203157771.png" srcset="/img/loading.gif" alt="image-20200221203157771"></p>
<p>整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p>
<p><img src="Git%5Cimage-20200221203219206.png" srcset="/img/loading.gif" alt="image-20200221203219206"></p>
<p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p>
<p>在上面这个例子中，运行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout experiment</span><br><span class="hljs-meta">$</span><span class="bash"> git rebase master</span><br>First, rewinding head to replay your work on top of it...<br>Applying: added staged command<br></code></pre></td></tr></table></figure>
<p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。（译注：写明了 commit id，以便理解，下同）</p>
<p><img src="Git%5Cimage-20200221203308092.png" srcset="/img/loading.gif" alt="image-20200221203308092"></p>
<p>现在回到 <code>master</code> 分支，进行一次快进合并。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge experiment</span><br></code></pre></td></tr></table></figure>
<p><img src="Git%5Cimage-20200221203335262.png" srcset="/img/loading.gif" alt="image-20200221203335262"></p>
<p>此时，<code>C4&#39;</code> 指向的快照就和上面使用 <code>merge</code> 命令的例子中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p>
<p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p>
<p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p>
<h4 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="headerlink" title="更有趣的变基例子"></a>更有趣的变基例子</h4><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_e">从一个特性分支里再分出一个特性分支的提交历史</a> 中的例子那样。 你创建了一个特性分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p>
<p><img src="Git%5Cimage-20200221203426765.png" srcset="/img/loading.gif" alt="image-20200221203426765"></p>
<p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rebase --onto master server client</span><br></code></pre></td></tr></table></figure>
<p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的共同祖先之后的修改，然后把它们在 <code>master</code> 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。</p>
<p><img src="Git%5Cimage-20200221203449597.png" srcset="/img/loading.gif" alt="image-20200221203449597"></p>
<p>现在可以快进合并 <code>master</code> 分支了。（如图 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_g">快进合并 master 分支，使之包含来自 client 分支的修改</a>）：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge client</span><br></code></pre></td></tr></table></figure>
<p><img src="Git%5Cimage-20200221203509968.png" srcset="/img/loading.gif" alt="image-20200221203509968"></p>
<p>接下来你决定将 <code>server</code> 分支中的修改也整合进来。 使用 <code>git rebase [basebranch] [topicbranch]</code> 命令可以直接将特性分支（即本例中的 <code>server</code>）变基到目标分支（即 <code>master</code>）上。这样做能省去你先切换到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git rebase master server</span><br></code></pre></td></tr></table></figure>
<p>如图 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_h">将 server 中的修改变基到 master 上</a> 所示，<code>server</code> 中的代码被“续”到了 <code>master</code> 后面。</p>
<p><img src="Git%5Cimage-20200221203545556.png" srcset="/img/loading.gif" alt="image-20200221203545556"></p>
<p>然后就可以快进合并主分支 master 了：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git checkout master</span><br><span class="hljs-meta">$</span><span class="bash"> git merge server</span><br></code></pre></td></tr></table></figure>
<p>至此，<code>client</code> 和 <code>server</code> 分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成图 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/rrbdiag_i">最终的提交历史</a> 中的样子：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git branch -d client</span><br><span class="hljs-meta">$</span><span class="bash"> git branch -d server</span><br></code></pre></td></tr></table></figure>
<p><img src="Git%5Cimage-20200221203608742.png" srcset="/img/loading.gif" alt="image-20200221203608742"></p>
<h4 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h4><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>
<p><strong>不要对在你的仓库外有副本的分支执行变基。</strong></p>
<p>如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p>
<p><img src="Git%5Cimage-20200221203643244.png" srcset="/img/loading.gif" alt="image-20200221203643244"></p>
<p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p>
<p><img src="Git%5Cimage-20200221203708356.png" srcset="/img/loading.gif" alt="image-20200221203708356"></p>
<p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p>
<p><img src="Git%5Cimage-20200221203726498.png" srcset="/img/loading.gif" alt="image-20200221203726498"></p>
<p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p>
<p><img src="Git%5Cimage-20200221203751115.png" srcset="/img/loading.gif" alt="image-20200221203751115"></p>
<p>此时如果你执行 <code>git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p>
<h4 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a>用变基解决变基</h4><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p>
<p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p>
<p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>
<p>举个例子，如果遇到前面提到的 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_pre_merge_rebase_work">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</a> 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p>
<ul>
<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>
<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>
<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</li>
<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>
</ul>
<p>从而我们将得到与 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_merge_rebase_work">你将相同的内容又合并了一次，生成了一个新的提交</a> 中不同的结果，如图 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_rebase_rebase_work">在一个被变基然后强制推送的分支上再次执行变基</a> 所示。</p>
<p><img src="Git%5Cimage-20200221203831054.png" srcset="/img/loading.gif" alt="image-20200221203831054"></p>
<p>要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p>
<p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p>
<p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p>
<p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p>
<p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p>
<h4 id="变基VS合并"><a href="#变基VS合并" class="headerlink" title="变基VS合并"></a>变基VS合并</h4><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p>
<p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p>
<p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。</p>
<p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p>
<p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>
<h2 id="服务器上的Git协议"><a href="#服务器上的Git协议" class="headerlink" title="服务器上的Git协议"></a>服务器上的Git协议</h2><p>到目前为止，你应该已经有办法使用 Git 来完成日常工作。 然而，为了使用 Git 协作功能，你还需要有远程的 Git 仓库。 尽管在技术上你可以从个人仓库进行推送（push）和拉取（pull）来修改内容，但不鼓励使用这种方法，因为一不留心就很容易弄混其他人的进度。 此外，你希望你的合作者们即使在你的电脑未联机时亦能存取仓库 — 拥有一个更可靠的公用仓库十分有用。 因此，与他人合作的最佳方法即是建立一个你与合作者们都有权利访问，且可从那里推送和拉取资料的共用仓库。</p>
<p>架设一台 Git 服务器并不难。 首先，选择你希望服务器使用的通讯协议。 在本章第一节将介绍可用的协议以及各自优缺点。 下面一节将解释使用那些协议的典型设置及如何在你的服务器上运行。 最后，如果你不介意托管你的代码在其他人的服务器，且不想经历设置与维护自己服务器的麻烦，可以试试我们介绍的几个仓库托管服务。</p>
<p>如果你对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个代码托管服务的帐户然后继续下一章，我们会在那里讨论分散式源码控制环境的林林总总。</p>
<p>一个远程仓库通常只是一个裸仓库（bare repository）——即一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照；存放的只有 Git 的资料。 简单的说，裸仓库就是你工程目录内的 <code>.git</code> 子目录内容，不包含其他资料。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。 在此，我们将会讨论那些协议及哪些情形应该使用（或避免使用）他们。</p>
<h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是硬盘内的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p>
<p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> /opt/git/project.git</span><br></code></pre></td></tr></table></figure>
<p>或你可以执行这个命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> file:///opt/git/project.git</span><br></code></pre></td></tr></table></figure>
<p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references）或对象（object）的干净版本库副本– 通常是在从其他版本控制系统导入后或一些类似情况（参见 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals">Git 内部原理</a> for maintenance tasks）需要这么做。 在此我们将使用普通路径，因为这样通常更快。</p>
<p>要增加一个本地版本库到现有的 Git 项目，可以执行如下的命令：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git remote add local_proj /opt/git/project.git</span><br></code></pre></td></tr></table></figure>
<p>然后，就可以像在网络上一样从远端版本库推送和拉取更新了。</p>
<hr>
<p>优点</p>
<p>基于文件系统的版本库的优点是简单，并且直接使用了现有的文件权限和网络访问权限。 如果你的团队已经有共享文件系统，建立版本库会十分容易。 只需要像设置其他共享目录一样，把一个裸版本库的副本放到大家都可以访问的路径，并设置好读/写的权限，就可以了， 我们会在 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_git_on_the_server">在服务器上搭建 Git</a> 讨论如何导出一个裸版本库。</p>
<p>这也是快速从别人的工作目录中拉取更新的方法。 如果你和别人一起合作一个项目，他想让你从版本库中拉取更新时，运行类似 <code>git pull /home/john/project</code> 的命令比推送到服务器再取回简单多了。</p>
<hr>
<p>缺点</p>
<p>这种方法的缺点是，通常共享文件系统比较难配置，并且比起基本的网络连接访问，这不方便从多个位置访问。 如果你想从家里推送内容，必须先挂载一个远程磁盘，相比网络连接的访问方式，配置不方便，速度也慢。</p>
<p>值得一提的是，如果你使用的是类似于共享挂载的文件系统时，这个方法不一定是最快的。 访问本地版本库的速度与你访问数据的速度是一样的。 在同一个服务器上，如果允许 Git 访问本地硬盘，一般的通过 NFS 访问版本库要比通过 SSH 访问慢。</p>
<p>最终，这个协议并不保护仓库避免意外的损坏。 每一个用户都有“远程”目录的完整 shell 权限，没有方法可以阻止他们修改或删除 Git 内部文件和损坏仓库。</p>
<h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。 我们先了解一下新的“智能” HTTP 协议。</p>
<h5 id="智能（Smart）HTTP协议"><a href="#智能（Smart）HTTP协议" class="headerlink" title="智能（Smart）HTTP协议"></a>智能（Smart）HTTP协议</h5><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p>
<p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p>
<p>事实上，类似 GitHub 的服务，你在网页上看到的 URL （比如， <code>https://github.com/schacon/simplegit[]</code>），和你在克隆、推送（如果你有权限）时使用的是一样的。</p>
<h5 id="哑（Dumb）-HTTP-协议"><a href="#哑（Dumb）-HTTP-协议" class="headerlink" title="哑（Dumb） HTTP 协议"></a>哑（Dumb） HTTP 协议</h5><p>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了（见 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_git_hooks">Git 钩子</a>）。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。 下面是设置从 HTTP 访问版本库的方法：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> /var/www/htdocs/</span><br><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> --bare /path/to/git_project gitproject.git</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> gitproject.git</span><br><span class="hljs-meta">$</span><span class="bash"> mv hooks/post-update.sample hooks/post-update</span><br><span class="hljs-meta">$</span><span class="bash"> chmod a+x hooks/post-update</span><br></code></pre></td></tr></table></figure>
<p>这样就可以了。 Git 自带的 <code>post-update</code> 挂钩会默认执行合适的命令（<code>git update-server-info</code>），来确保通过 HTTP 的获取和克隆操作正常工作。 这条命令会在你通过 SSH 向版本库推送之后被执行；然后别人就可以通过类似下面的命令来克隆：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://example.com/gitproject.git</span><br></code></pre></td></tr></table></figure>
<p>这里我们用了 Apache 里设置了常用的路径 <code>/var/www/htdocs</code>，不过你可以使用任何静态 web 服务器 —— 只需要把裸版本库放到正确的目录下就可以。 Git 的数据是以基本的静态文件形式提供的（详情见 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals">Git 内部原理</a>）。</p>
<p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p>
<hr>
<p>优点</p>
<p>我们将只关注智能 HTTP 协议的优点。</p>
<p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p>
<p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p>
<p>另一个好处是 HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p>
<hr>
<p>缺点</p>
<p>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与 “智能” HTTP 协议相比就几乎没有优势了。</p>
<p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 OSX 的 Keychain 或者 Windows 的凭证管理器。 参考 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching">凭证存储</a> 如何安全地保存 HTTP 密码。</p>
<h4 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h4><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下服务器已经支持通过 SSH 访问 —— 即使没有也很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p>
<p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> ssh://user@server/project.git</span><br></code></pre></td></tr></table></figure>
<p>或者使用一个简短的 scp 式的写法：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> user@server:project.git</span><br></code></pre></td></tr></table></figure>
<p>你也可以不指定用户，Git 会使用当前登录的用户名。</p>
<p>优势<br>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p>
<p>缺点<br>SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。</p>
<h4 id="Git协议"><a href="#Git协议" class="headerlink" title="Git协议"></a>Git协议</h4><p>接下来是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 git-daemon-export-ok 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p>
<p>优点<br>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p>
<p>缺点<br>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 git:// 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 xinetd 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/">编程工具</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Git/">Git</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/03/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">图像处理入门</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/03/02/%E6%94%BF%E5%BA%9C%E5%AE%98%E6%96%B9%E7%BD%91%E7%AB%99/">
                        <span class="hidden-mobile">政府官方网站</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
